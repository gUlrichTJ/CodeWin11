From: <Saved by Blink>
Snapshot-Content-Location: https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html
Subject: The Rust Programming Language
Date: Fri, 19 Jan 2024 16:24:11 +0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----"


------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: text/html
Content-ID: <frame-3A906311D492AE32F8DC70DBC465C692@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html

<!DOCTYPE html><html><head><meta http-equiv=3D"Content-Type" content=3D"tex=
t/html; charset=3DUTF-8"><link rel=3D"stylesheet" type=3D"text/css" href=3D=
"cid:css-0b32818c-8c61-49c0-98aa-bc20aa5b3500@mhtml.blink" /><link rel=3D"s=
tylesheet" type=3D"text/css" href=3D"cid:css-e9ba41b3-219c-440e-ad30-388f4d=
34c3ce@mhtml.blink" /><link rel=3D"stylesheet" type=3D"text/css" href=3D"ci=
d:css-f7d6d5fc-044b-4592-9e4f-f9dfe718106d@mhtml.blink" /><link rel=3D"styl=
esheet" type=3D"text/css" href=3D"cid:css-310c9226-4456-4e42-98b5-aef68f03c=
5de@mhtml.blink" /><link rel=3D"stylesheet" type=3D"text/css" href=3D"cid:c=
ss-76122411-25f7-4e75-b2d6-c955bbfb8df9@mhtml.blink" /><link rel=3D"stylesh=
eet" type=3D"text/css" href=3D"cid:css-e9acce45-c998-4616-9b25-1b2cc40c553b=
@mhtml.blink" /><link rel=3D"stylesheet" type=3D"text/css" href=3D"cid:css-=
77aa0ce5-7c2e-4dee-8b26-1617090c7abd@mhtml.blink" /><link rel=3D"stylesheet=
" type=3D"text/css" href=3D"cid:css-ef9a2406-f6f9-4eb0-8ac3-08b889e46357@mh=
tml.blink" />
 =20
  <meta name=3D"generator" content=3D"pandoc">
  <meta name=3D"viewport" content=3D"width=3Ddevice-width, initial-scale=3D=
1.0, user-scalable=3Dyes">
  <meta name=3D"author" content=3D"The Rust Team">
  <meta name=3D"dcterms.date" content=3D"2015-05-13">
  <title>The Rust Programming Language</title>
  <!--[if lt IE 9]>
    <script src=3D"http://html5shim.googlecode.com/svn/trunk/html5.js"></sc=
ript>
  <![endif]-->
 =20
  <link href=3D"data:text/css,%2F%2A%2A%0A%20%2A%20%23%20Stylesheet%20for%2=
0Pandoc%20Documents%0A%20%2A%2F%0A%0A%2F%2A%2A%0A%20%2A%20%23%23%20Fonts%0A=
%20%2A%2F%0A%0Abody%20%7B%0A%20%20font%2Dfamily%3A%20Georgia%2C%20Palatino%=
2C%20%27Palatino%20Linotype%27%2C%20Times%2C%20%27Times%20New%20Roman%27%2C=
%20serif%3B%0A%20%20font%2Dsize%3A%2012px%3B%0A%20%20line%2Dheight%3A%201%2=
E7%3B%0A%20%20max%2Dwidth%3A%2042em%3B%0A%7D%0A%0A%40media%20only%20screen%=
20and%20%28min%2Dwidth%3A%20480px%29%20%7B%0A%20%20body%20%7B%0A%20%20%20%2=
0font%2Dsize%3A%2014px%3B%0A%20%20%7D%0A%7D%0A%40media%20only%20screen%20an=
d%20%28min%2Dwidth%3A%20768px%29%20%7B%0A%20%20body%20%7B%0A%20%20%20%20fon=
t%2Dsize%3A%2016px%3B%0A%20%20%7D%0A%7D%0A%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%=
20h5%2C%20h6%20%7B%0A%20%20line%2Dheight%3A%20125%25%3B%0A%20%20font%2Dweig=
ht%3A%20normal%3B%0A%7D%0A%0Ah4%2C%20h5%2C%20h6%20%7B%0A%20%20font%2Dweight=
%3A%20bold%3B%0A%7D%0A%0Ah1%20%7B%0A%20%20font%2Dsize%3A%202em%3B%0A%7D%0A%=
0Ah2%20%7B%0A%20%20font%2Dsize%3A%201%2E8em%3B%0A%7D%0A%0Ah3%20%7B%0A%20%20=
font%2Dsize%3A%201%2E5em%3B%0A%7D%0A%0Ah4%20%7B%0A%20%20font%2Dsize%3A%201%=
2E2em%3B%0A%7D%0A%0Ah5%20%7B%0A%20%20font%2Dsize%3A%201em%3B%0A%7D%0A%0Ah6%=
20%7B%0A%20%20font%2Dsize%3A%200%2E9em%3B%0A%7D%0A%0Apre%2C%20code%2C%20kbd=
%2C%20samp%20%7B%0A%20%20font%2Dfamily%3A%20monospace%3B%0A%20%20font%2Dsiz=
e%3A%200%2E98em%3B%0A%7D%0A%0A%2F%2A%2A%0A%20%2A%20%23%23%20Other%20Styles%=
0A%20%2A%2F%0A%0Ahtml%20%7B%0A%20%20font%2Dsize%3A%20100%25%3B%0A%20%20over=
flow%2Dy%3A%20scroll%3B%0A%20%20%2Dwebkit%2Dtext%2Dsize%2Dadjust%3A%20100%2=
5%3B%0A%20%20%2Dms%2Dtext%2Dsize%2Dadjust%3A%20100%25%3B%0A%7D%0A%0Abody%20=
%7B%0A%20%20color%3A%20%23444%3B%0A%20%20padding%3A%201em%3B%0A%20%20margin=
%3A%20auto%3B%0A%20%20background%3A%20%23fefefe%3B%0A%7D%0A%0Aa%20%7B%0A%20=
%20color%3A%20%230645ad%3B%0A%20%20text%2Ddecoration%3A%20none%3B%0A%7D%0A%=
0Aa%3Avisited%20%7B%0A%20%20color%3A%20%230b0080%3B%0A%7D%0A%0Aa%3Ahover%20=
%7B%0A%20%20color%3A%20%2306e%3B%0A%7D%0A%0Aa%3Aactive%20%7B%0A%20%20color%=
3A%20%23faa700%3B%0A%7D%0A%0Aa%3Afocus%20%7B%0A%20%20outline%3A%20thin%20do=
tted%3B%0A%7D%0A%0A%2A%3A%3A%2Dmoz%2Dselection%20%7B%0A%20%20background%3A%=
20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0A%20%20color%3A%20%23000%3B%=
0A%7D%0A%0A%2A%3A%3Aselection%20%7B%0A%20%20background%3A%20rgba%28255%2C%2=
0255%2C%200%2C%200%2E3%29%3B%0A%20%20color%3A%20%23000%3B%0A%7D%0A%0Aa%3A%3=
A%2Dmoz%2Dselection%20%7B%0A%20%20background%3A%20rgba%28255%2C%20255%2C%20=
0%2C%200%2E3%29%3B%0A%20%20color%3A%20%230645ad%3B%0A%7D%0A%0Aa%3A%3Aselect=
ion%20%7B%0A%20%20background%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%=
3B%0A%20%20color%3A%20%230645ad%3B%0A%7D%0A%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C=
%20h5%2C%20h6%20%7B%0A%20%20color%3A%20%23111%3B%0A%20%20line%2Dheight%3A%2=
0125%25%3B%0A%20%20margin%2Dtop%3A%201em%3B%0A%20%20font%2Dweight%3A%20norm=
al%3B%0A%7D%0A%0Ap%20%7B%0A%20%20margin%3A%201em%200%3B%0A%7D%0A%0Aimg%20%7=
B%0A%20%20max%2Dwidth%3A%20100%25%3B%0A%7D%0A%0Aq%20%7B%20quotes%3A%20%22%E=
2%80%9C%22%20%22%E2%80%9D%22%20%22%E2%80%98%22%20%22%E2%80%99%22%3B%20%7D%0=
A%0A%5Blang%3Dde%5D%20q%20%7B%0A%20%20quotes%3A%20%22%5C00bb%22%20%22%5C00a=
b%22%20%22%5C203A%22%20%22%5C2039%22%3B%0A%7D%0A%0Ablockquote%2C%0Aaside%2E=
notes%20%7B%0A%20%20color%3A%20%23666666%3B%0A%20%20margin%3A%200%3B%0A%20%=
20padding%2Dleft%3A%203em%3B%0A%20%20border%2Dleft%3A%200%2E5em%20%23EEE%20=
solid%3B%0A%7D%0A%0Aaside%2Enotes%20%7B%0A%20%20color%3A%20%23999%3B%0A%20%=
20border%2Dleft%2Dcolor%3A%20%23ffa%3B%0A%7D%0A%0Ahr%20%7B%0A%20%20display%=
3A%20block%3B%0A%20%20height%3A%202px%3B%0A%20%20border%3A%200%3B%0A%20%20b=
order%2Dtop%3A%201px%20solid%20%23aaa%3B%0A%20%20border%2Dbottom%3A%201px%2=
0solid%20%23eee%3B%0A%20%20margin%3A%201em%200%3B%0A%20%20padding%3A%200%3B=
%0A%7D%0A%0Apre%2C%20code%2C%20kbd%2C%20samp%20%7B%0A%20%20color%3A%20%2300=
0%3B%0A%7D%0A%0Apre%20%7B%0A%20%20white%2Dspace%3A%20pre%3B%0A%20%20white%2=
Dspace%3A%20pre%2Dwrap%3B%0A%20%20word%2Dwrap%3A%20break%2Dword%3B%0A%20%20=
padding%3A%200%2E1em%200%2E4em%3B%0A%20%20text%2Dindent%3A%201em%3B%0A%7D%0=
A%0Ab%2C%20strong%20%7B%0A%20%20font%2Dweight%3A%20bold%3B%0A%7D%0A%0Adfn%2=
0%7B%0A%20%20font%2Dstyle%3A%20italic%3B%0A%7D%0A%0Ains%20%7B%0A%20%20backg=
round%3A%20%23ff9%3B%0A%20%20color%3A%20%23000%3B%0A%20%20text%2Ddecoration=
%3A%20none%3B%0A%7D%0A%0Amark%20%7B%0A%20%20background%3A%20%23ff0%3B%0A%20=
%20color%3A%20%23000%3B%0A%20%20font%2Dstyle%3A%20italic%3B%0A%20%20font%2D=
weight%3A%20bold%3B%0A%7D%0A%0Asub%2C%20sup%20%7B%0A%20%20font%2Dsize%3A%20=
75%25%3B%0A%20%20line%2Dheight%3A%200%3B%0A%20%20position%3A%20relative%3B%=
0A%20%20vertical%2Dalign%3A%20baseline%3B%0A%7D%0A%0Asup%20%7B%0A%20%20top%=
3A%20%2D0%2E5em%3B%0A%7D%0A%0Asub%20%7B%0A%20%20bottom%3A%20%2D0%2E25em%3B%=
0A%7D%0A%0Aul%2C%20ol%20%7B%0A%20%20margin%3A%201em%200%3B%0A%20%20padding%=
3A%200%200%200%202em%3B%0A%7D%0A%0Ali%20p%3Alast%2Dchild%20%7B%0A%20%20marg=
in%2Dbottom%3A%200%3B%0A%7D%0A%0Aul%20ul%2C%20ol%20ol%20%7B%0A%20%20margin%=
3A%20%2E3em%200%3B%0A%7D%0A%0Adl%20%7B%0A%20%20margin%2Dbottom%3A%201em%3B%=
0A%7D%0A%0Adt%20%7B%0A%20%20font%2Dweight%3A%20bold%3B%0A%20%20margin%2Dbot=
tom%3A%20%2E8em%3B%0A%7D%0A%0Add%20%7B%0A%20%20margin%3A%200%200%20%2E8em%2=
02em%3B%0A%7D%0A%0Add%3Alast%2Dchild%20%7B%0A%20%20margin%2Dbottom%3A%200%3=
B%0A%7D%0A%0Aimg%20%7B%0A%20%20border%3A%200%3B%0A%20%20%2Dms%2Dinterpolati=
on%2Dmode%3A%20bicubic%3B%0A%20%20vertical%2Dalign%3A%20middle%3B%0A%7D%0A%=
0Afigure%20%7B%0A%20%20display%3A%20block%3B%0A%20%20text%2Dalign%3A%20cent=
er%3B%0A%20%20margin%3A%202em%200%3B%0A%7D%0A%0Afigure%20img%20%7B%0A%20%20=
border%3A%20none%3B%0A%20%20margin%3A%200%20auto%201em%3B%0A%7D%0A%0Afigcap=
tion%20%7B%0A%20%20font%2Dsize%3A%200%2E8em%3B%0A%20%20font%2Dstyle%3A%20it=
alic%3B%0A%20%20margin%3A%200%200%20%2E8em%3B%0A%7D%0A%0Atable%20%7B%0A%20%=
20margin%2Dbottom%3A%202em%3B%0A%20%20border%2Dbottom%3A%201px%20solid%20%2=
3ddd%3B%0A%20%20border%2Dright%3A%201px%20solid%20%23ddd%3B%0A%20%20border%=
2Dspacing%3A%200%3B%0A%20%20border%2Dcollapse%3A%20collapse%3B%0A%7D%0A%0At=
able%20th%20%7B%0A%20%20padding%3A%20%2E2em%201em%3B%0A%20%20background%2Dc=
olor%3A%20%23eee%3B%0A%20%20border%2Dtop%3A%201px%20solid%20%23ddd%3B%0A%20=
%20border%2Dleft%3A%201px%20solid%20%23ddd%3B%0A%7D%0A%0Atable%20td%20%7B%0=
A%20%20padding%3A%20%2E2em%201em%3B%0A%20%20border%2Dtop%3A%201px%20solid%2=
0%23ddd%3B%0A%20%20border%2Dleft%3A%201px%20solid%20%23ddd%3B%0A%20%20verti=
cal%2Dalign%3A%20top%3B%0A%7D%0A%0A%2Ebyline%20%7B%0A%20%20font%2Dsize%3A%2=
01%2E2em%3B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0A%0A%2Ereferences%20=
a%2Euri%20%7Bword%2Dbreak%3A%20break%2Dall%3B%7D%0A%0Anav%2Etoc%20ul%20%7B%=
0A%20%20list%2Dstyle%2Dtype%3A%20decimal%3B%0A%7D%0A%0Anav%2Etoc%2Ealready%=
2Dnumbered%20ul%20%7B%0A%20%20list%2Dstyle%2Dtype%3A%20none%3B%0A%7D%0A%0An=
av%2Etoc%2Ealready%2Dnumbered%20%3E%20ul%20%7B%0A%20%20padding%3A%200%3B%0A=
%7D%0A%0A%2F%2A%2A%0A%20%2A%20%23%23%20Print%20Styles%0A%20%2A%2F%0A%0A%40m=
edia%20print%20%7B%0A%20%20%2A%20%7B%0A%20%20%20%20background%3A%20transpar=
ent%20%21important%3B%0A%20%20%20%20color%3A%20black%20%21important%3B%0A%2=
0%20%20%20filter%3A%20none%20%21important%3B%0A%20%20%20%20%2Dms%2Dfilter%3=
A%20none%20%21important%3B%0A%20%20%7D%0A%0A%20%20body%20%7B%0A%20%20%20%20=
font%2Dsize%3A%2010pt%3B%0A%20%20%20%20max%2Dwidth%3A%20100%25%3B%0A%20%20%=
7D%0A%0A%20%20a%2C%20a%3Avisited%20%7B%0A%20%20%20%20text%2Ddecoration%3A%2=
0underline%3B%0A%20%20%7D%0A%0A%20%20hr%20%7B%0A%20%20%20%20height%3A%201px=
%3B%0A%20%20%20%20border%3A%200%3B%0A%20%20%20%20border%2Dbottom%3A%201px%2=
0solid%20black%3B%0A%20%20%7D%0A%0A%20%20%2F%2Aa%5Bhref%5D%3Aafter%20%7B%0A=
%20%20%20%20content%3A%20%22%20%28%22%20attr%28href%29%20%22%29%22%3B%0A%20=
%20%7D%2A%2F%0A%0A%20%20abbr%5Btitle%5D%3Aafter%20%7B%0A%20%20%20%20content=
%3A%20%22%20%28%22%20attr%28title%29%20%22%29%22%3B%0A%20%20%7D%0A%0A%20%20=
%2Eir%20a%3Aafter%2C%20a%5Bhref%5E%3D%22javascript%3A%22%5D%3Aafter%2C%20a%=
5Bhref%5E%3D%22%23%22%5D%3Aafter%20%7B%0A%20%20%20%20content%3A%20%22%22%3B=
%0A%20%20%7D%0A%0A%20%20pre%2C%20blockquote%20%7B%0A%20%20%20%20border%3A%2=
01px%20solid%20%23999%3B%0A%20%20%20%20padding%2Dright%3A%201em%3B%0A%20%20=
%20%20page%2Dbreak%2Dinside%3A%20avoid%3B%0A%20%20%7D%0A%0A%20%20tr%2C%20im=
g%20%7B%0A%20%20%20%20page%2Dbreak%2Dinside%3A%20avoid%3B%0A%20%20%7D%0A%0A=
%20%20img%20%7B%0A%20%20%20%20max%2Dwidth%3A%20100%25%20%21important%3B%0A%=
20%20%7D%0A%0A%20%20%40page%20%3Aleft%20%7B%0A%20%20%20%20margin%3A%2025mm%=
2030mm%2025mm%2020mm%3B%0A%20%20%7D%0A%0A%20%20%40page%20%3Aright%20%7B%0A%=
20%20%20%20margin%3A%2025mm%2020mm%2025mm%2030mm%3B%0A%20%20%7D%0A%0A%20%20=
p%2C%20h2%2C%20h3%20%7B%0A%20%20%20%20orphans%3A%203%3B%0A%20%20%20%20widow=
s%3A%203%3B%0A%20%20%7D%0A%0A%20%20h1%2C%20h2%2C%20h3%2C%20h4%20%7B%0A%20%2=
0%20%20page%2Dbreak%2Dafter%3A%20avoid%3B%0A%20%20%7D%0A%7D%0A" rel=3D"styl=
esheet">
</head>
<body role=3D"document" monica-version=3D"4.6.0" monica-id=3D"ofpnmcalabcbj=
gholdjcjblkibolbppb">


<header>
  <h1 class=3D"title">The Rust Programming Language</h1>

 =20
  <div class=3D"byline vcard">
    <address>
          <p class=3D"author">The Rust Team</p>
        </address>
      <time pubdate=3D"pubdate" date=3D"2015-05-13" class=3D"date">2015-05-=
13</time>
    </div>
</header>


<nav class=3D"toc" id=3D"TOC">
  <h2>Table of Contents</h2>
  <ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#introduction">Introduction</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#contributing">Contributing</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#a-brief-introduction-to-rust">A brief introduction to Rust</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--getting-started">Getting Started</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--installing-rust">Installing Rust</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--hello-world">Hello, world!</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--hello-cargo">Hello, Cargo!</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--learn-rust">Learn Rust</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--guessing-game">Guessing Game</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#set-up">Set up</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#processing-a-guess">Processing a Guess</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#generating-a-secret-number">Generating a secret number</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#comparing-guesses">Comparing guesses</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#looping">Looping</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#complete">Complete!</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--dining-philosophers">Dining Philosophers</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--rust-inside-other-languages">Rust inside other languages</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-problem">The problem</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#a-rust-library">A Rust library</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#ruby">Ruby</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#python">Python</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#node.js">Node.js</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#conclusion">Conclusion</a></li>
  </ul></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--effective-rust">Effective Rust</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--the-stack-and-the-heap">The Stack and the Heap</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#memory-management">Memory management</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-stack">The Stack</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-heap">The Heap</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#arguments-and-borrowing">Arguments and borrowing</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#a-complex-example">A complex example</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#what-do-other-languages-do">What do other languages do?</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#which-to-use">Which to use?</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--testing">Testing</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-test-attribute">The <code>test</code> attribute</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-tests-module">The <code>tests</code> module</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-tests-directory">The <code>tests</code> directory</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#documentation-tests">Documentation tests</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--conditional-compilation">Conditional Compilation</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#cfg_attr">cfg_attr</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#cfg">cfg!</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--documentation">Documentation</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--iterators">Iterators</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--concurrency">Concurrency</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--error-handling">Error Handling</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#failure-vs.panic">Failure vs.&nbsp;Panic</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#handling-errors-with-option-and-result">Handling errors with <code>Option=
</code> and <code>Result</code></a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#non-recoverable-errors-with-panic">Non-recoverable errors with <code>pani=
c!</code></a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#upgrading-failures-to-panics">Upgrading failures to panics</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#using-try">Using <code>try!</code></a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--ffi">FFI</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#introduction-1">Introduction</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#creating-a-safe-interface">Creating a safe interface</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#destructors">Destructors</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#callbacks-from-c-code-to-rust-functions">Callbacks from C code to Rust fu=
nctions</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#linking">Linking</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#unsafe-blocks">Unsafe blocks</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#accessing-foreign-globals">Accessing foreign globals</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#foreign-calling-conventions">Foreign calling conventions</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#interoperability-with-foreign-code">Interoperability with foreign code</a=
></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-nullable-pointer-optimization">The =E2=80=9Cnullable pointer optimiza=
tion=E2=80=9D</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#calling-rust-code-from-c">Calling Rust code from C</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--borrow-and-asref">Borrow and AsRef</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#borrow">Borrow</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#asref">AsRef</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#which-should-i-use">Which should I use?</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--release-channels">Release Channels</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#overview">Overview</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#choosing-a-version">Choosing a version</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#helping-the-ecosystem-through-ci">Helping the ecosystem through CI</a></l=
i>
  </ul></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--syntax-and-semantics">Syntax and Semantics</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--variable-bindings">Variable Bindings</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--functions">Functions</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--primitive-types">Primitive Types</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#booleans">Booleans</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#char"><code>char</code></a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#numeric-types">Numeric types</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#arrays">Arrays</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#slices">Slices</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#str"><code>str</code></a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#tuples">Tuples</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#functions">Functions</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--comments">Comments</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--if">if</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--for-loops">for loops</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--while-loops">while loops</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--ownership">Ownership</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#meta">Meta</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#ownership">Ownership</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#move-semantics">Move semantics</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#more-than-ownership">More than ownership</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--references-and-borrowing">References and Borrowing</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#meta-1">Meta</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#borrowing">Borrowing</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#mut-references">&amp;mut references</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-rules">The Rules</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--lifetimes">Lifetimes</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#meta-2">Meta</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#lifetimes">Lifetimes</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--mutability">Mutability</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#interior-vs.exterior-mutability">Interior vs.&nbsp;Exterior Mutability</a=
></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--structs">Structs</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#update-syntax">Update syntax</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#tuple-structs">Tuple structs</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#unit-like-structs">Unit-like structs</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--enums">Enums</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--match">Match</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#matching-on-enums">Matching on enums</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--patterns">Patterns</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#multiple-patterns">Multiple patterns</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#ranges">Ranges</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#bindings">Bindings</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#ignoring-variants">Ignoring variants</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#guards">Guards</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#ref-and-ref-mut">ref and ref mut</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#destructuring">Destructuring</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#mix-and-match">Mix and Match</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--method-syntax">Method Syntax</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#method-calls">Method calls</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#chaining-method-calls">Chaining method calls</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#associated-functions">Associated functions</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#builder-pattern">Builder Pattern</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--vectors">Vectors</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--strings">Strings</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--generics">Generics</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--traits">Traits</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#multiple-trait-bounds">Multiple trait bounds</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#where-clause">Where clause</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#inheritance">Inheritance</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--drop">Drop</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--if-let">if let</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--trait-objects">Trait Objects</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--closures">Closures</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#syntax">Syntax</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#closures-and-their-environment">Closures and their environment</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#closure-implementation">Closure implementation</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#taking-closures-as-arguments">Taking closures as arguments</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#returning-closures">Returning closures</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--ufcs">Universal Function Call Syntax</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#angle-bracket-form">Angle-bracket Form</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--crates-and-modules">Crates and Modules</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#basic-terminology-crates-and-modules">Basic terminology: Crates and Modul=
es</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#defining-modules">Defining Modules</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#multiple-file-crates">Multiple file crates</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#importing-external-crates">Importing External Crates</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#exporting-a-public-interface">Exporting a Public Interface</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#importing-modules-with-use">Importing Modules with <code>use</code></a></=
li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--const-and-static"><code>const</code> and <code>static</code></a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#static-1"><code>static</code></a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#initializing">Initializing</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#which-construct-should-i-use">Which construct should I use?</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--attributes">Attributes</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--type-aliases"><code>type</code> aliases</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--casting-between-types">Casting between types</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#as"><code>as</code></a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#transmute"><code>transmute</code></a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--associated-types">Associated Types</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--unsized-types">Unsized Types</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sized">?Sized</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--operators-and-overloading">Operators and Overloading</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--deref-coercions">Deref coercions</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--macros">Macros</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#defining-a-macro">Defining a macro</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#hygiene">Hygiene</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#recursive-macros">Recursive macros</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#debugging-macro-code">Debugging macro code</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#syntactic-requirements">Syntactic requirements</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#scoping-and-macro-importexport">Scoping and macro import/export</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-variable-crate">The variable <code>$crate</code></a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#the-deep-end">The deep end</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#common-macros">Common macros</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#procedural-macros">Procedural macros</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--raw-pointers">Raw Pointers</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#basics">Basics</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#ffi">FFI</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#references-and-raw-pointers">References and raw pointers</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--unsafe"><code>unsafe</code></a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#what-does-safe-mean">What does =E2=80=98safe=E2=80=99 mean?</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#unsafe-superpowers">Unsafe Superpowers</a></li>
  </ul></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--nightly-rust">Nightly Rust</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--compiler-plugins">Compiler Plugins</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#introduction-2">Introduction</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#syntax-extensions">Syntax extensions</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#lint-plugins">Lint plugins</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--inline-assembly">Inline Assembly</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--no-stdlib">No stdlib</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--intrinsics">Intrinsics</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--lang-items">Lang items</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--link-args">Link args</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--benchmark-tests">Benchmark Tests</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--box-syntax-and-patterns">Box Syntax and Patterns</a><ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#returning-pointers">Returning Pointers</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--slice-patterns">Slice Patterns</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--associated-constants">Associated Constants</a></li>
  </ul></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--glossary">Glossary</a></li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--academic-research">Academic Research</a></li>
  </ul>
</nav>

<article role=3D"main">
  <h1 id=3D"introduction">Introduction</h1>
  <p>Welcome! This book will teach you about the <a href=3D"http://rust-lan=
g.org/">Rust Programming Language</a>. Rust is a systems programming langua=
ge focused on three goals: safety, speed, and concurrency. It maintains the=
se goals without having a garbage collector, making it a useful language fo=
r a number of use cases other languages aren=E2=80=99t good at: embedding i=
n other languages, programs with specific space and time requirements, and =
writing low-level code, like device drivers and operating systems. It impro=
ves on current languages targeting this space by having a number of compile=
-time safety checks that produce no runtime overhead, while eliminating all=
 data races. Rust also aims to achieve =E2=80=98zero-cost abstractions=E2=
=80=99 even though some of these abstractions feel like those of a high-lev=
el language. Even then, Rust still allows precise control like a low-level =
language would.</p>
  <p>=E2=80=9CThe Rust Programming Language=E2=80=9D is split into seven se=
ctions. This introduction is the first. After this:</p>
  <ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--getting-started">Getting started</a> - Set up your computer for Rust=
 development.</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--learn-rust">Learn Rust</a> - Learn Rust programming through small pr=
ojects.</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--effective-rust">Effective Rust</a> - Higher-level concepts for writi=
ng excellent Rust code.</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--syntax-and-semantics">Syntax and Semantics</a> - Each bit of Rust, b=
roken down into small chunks.</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--nightly-rust">Nightly Rust</a> - Cutting-edge features that aren=E2=
=80=99t in stable builds yet.</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--glossary">Glossary</a> - A reference of terms used in the book.</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--academic-research">Academic Research</a> - Literature that influence=
d Rust.</li>
  </ul>
  <p>After reading this introduction, you=E2=80=99ll want to dive into eith=
er =E2=80=98Learn Rust=E2=80=99 or =E2=80=98Syntax and Semantics=E2=80=99, =
depending on your preference: =E2=80=98Learn Rust=E2=80=99 if you want to d=
ive in with a project, or =E2=80=98Syntax and Semantics=E2=80=99 if you pre=
fer to start small, and learn a single concept thoroughly before moving ont=
o the next. Copious cross-linking connects these parts together.</p>
  <h2 id=3D"contributing">Contributing</h2>
  <p>The source files from which this book is generated can be found on Git=
hub: <a href=3D"https://github.com/rust-lang/rust/tree/master/src/doc/trpl"=
>github.com/rust-lang/rust/tree/master/src/doc/trpl</a></p>
  <h2 id=3D"a-brief-introduction-to-rust">A brief introduction to Rust</h2>
  <p>Is Rust a language you might be interested in? Let=E2=80=99s examine a=
 few small code samples to show off a few of its strengths.</p>
  <p>The main concept that makes Rust unique is called =E2=80=98ownership=
=E2=80=99. Consider this small example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> x =3D <sp=
an class=3D"ot">vec!</span>[<span class=3D"st">"Hello"</span>, <span class=
=3D"st">"world"</span>];
  }</code></pre></div>
  <p>This program makes a <a href=3D"https://killercup.github.io/trpl-ebook=
/trpl-2015-05-13.html#sec--variable-bindings">variable binding</a> named <c=
ode>x</code>. The value of this binding is a <code>Vec&lt;T&gt;</code>, a =
=E2=80=98vector=E2=80=99, that we create through a <a href=3D"https://kille=
rcup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--macros">macro</a> defin=
ed in the standard library. This macro is called <code>vec</code>, and we i=
nvoke macros with a <code>!</code>. This follows a general principle of Rus=
t: make things explicit. Macros can do significantly more complicated thing=
s than function calls, and so they=E2=80=99re visually distinct. The <code>=
!</code> also helps with parsing, making tooling easier to write, which is =
also important.</p>
  <p>We used <code>mut</code> to make <code>x</code> mutable: bindings are =
immutable by default in Rust. We=E2=80=99ll be mutating this vector later i=
n the example.</p>
  <p>It=E2=80=99s also worth noting that we didn=E2=80=99t need a type anno=
tation here: while Rust is statically typed, we didn=E2=80=99t need to expl=
icitly annotate the type. Rust has type inference to balance out the power =
of static typing with the verbosity of annotating types.</p>
  <p>Rust prefers stack allocation to heap allocation: <code>x</code> is pl=
aced directly on the stack. However, the <code>Vec&lt;T&gt;</code> type all=
ocates space for the elements of the vector on the heap. If you=E2=80=99re =
not familiar with this distinction, you can ignore it for now, or check out=
 <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec=
--the-stack-and-the-heap">=E2=80=98The Stack and the Heap=E2=80=99</a>. As =
a systems programming language, Rust gives you the ability to control how y=
our memory is allocated, but when we=E2=80=99re getting started, it=E2=80=
=99s less of a big deal.</p>
  <p>Earlier, we mentioned that =E2=80=98ownership=E2=80=99 is the key new =
concept in Rust. In Rust parlance, <code>x</code> is said to =E2=80=98own=
=E2=80=99 the vector. This means that when <code>x</code> goes out of scope=
, the vector=E2=80=99s memory will be de-allocated. This is done determinis=
tically by the Rust compiler, rather than through a mechanism such as a gar=
bage collector. In other words, in Rust, you don=E2=80=99t call functions l=
ike <code>malloc</code> and <code>free</code> yourself: the compiler static=
ally determines when you need to allocate or deallocate memory, and inserts=
 those calls itself. To err is to be human, but compilers never forget.</p>
  <p>Let=E2=80=99s add another line to our example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> x =3D <sp=
an class=3D"ot">vec!</span>[<span class=3D"st">"Hello"</span>, <span class=
=3D"st">"world"</span>];
 =20
      <span class=3D"kw">let</span> y =3D &amp;x[<span class=3D"dv">0</span=
>];
  }</code></pre></div>
  <p>We=E2=80=99ve introduced another binding, <code>y</code>. In this case=
, <code>y</code> is a =E2=80=98reference=E2=80=99 to the first element of t=
he vector. Rust=E2=80=99s references are similar to pointers in other langu=
ages, but with additional compile-time safety checks. References interact w=
ith the ownership system by <a href=3D"https://killercup.github.io/trpl-ebo=
ok/trpl-2015-05-13.html#sec--references-and-borrowing">=E2=80=98borrowing=
=E2=80=99</a> what they point to, rather than owning it. The difference is,=
 when the reference goes out of scope, it will not deallocate the underlyin=
g memory. If it did, we=E2=80=99d de-allocate twice, which is bad!</p>
  <p>Let=E2=80=99s add a third line. It looks innocent enough, but causes a=
 compiler error:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> x =3D <sp=
an class=3D"ot">vec!</span>[<span class=3D"st">"Hello"</span>, <span class=
=3D"st">"world"</span>];
 =20
      <span class=3D"kw">let</span> y =3D &amp;x[<span class=3D"dv">0</span=
>];
 =20
      x.push(<span class=3D"st">"foo"</span>);
  }</code></pre></div>
  <p><code>push</code> is a method on vectors that appends another element =
to the end of the vector. When we try to compile this program, we get an er=
ror:</p>
  <pre><code>error: cannot borrow `x` as mutable because it is also borrowe=
d as immutable
      x.push("foo");
      ^
  note: previous borrow of `x` occurs here; the immutable borrow prevents
  subsequent moves or mutable borrows of `x` until the borrow ends
      let y =3D &amp;x[0];
               ^
  note: previous borrow ends here
  fn main() {
 =20
  }
  ^</code></pre>
  <p>Whew! The Rust compiler gives quite detailed errors at times, and this=
 is one of those times. As the error explains, while we made our binding mu=
table, we still cannot call <code>push</code>. This is because we already h=
ave a reference to an element of the vector, <code>y</code>. Mutating somet=
hing while another reference exists is dangerous, because we may invalidate=
 the reference. In this specific case, when we create the vector, we may ha=
ve only allocated space for three elements. Adding a fourth would mean allo=
cating a new chunk of memory for all those elements, copying the old values=
 over, and updating the internal pointer to that memory. That all works jus=
t fine. The problem is that <code>y</code> wouldn=E2=80=99t get updated, an=
d so we=E2=80=99d have a =E2=80=98dangling pointer=E2=80=99. That=E2=80=99s=
 bad. Any use of <code>y</code> would be an error in this case, and so the =
compiler has caught this for us.</p>
  <p>So how do we solve this problem? There are two approaches we can take.=
 The first is making a copy rather than using a reference:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> x =3D <sp=
an class=3D"ot">vec!</span>[<span class=3D"st">"Hello"</span>, <span class=
=3D"st">"world"</span>];
 =20
      <span class=3D"kw">let</span> y =3D x[<span class=3D"dv">0</span>].cl=
one();
 =20
      x.push(<span class=3D"st">"foo"</span>);
  }</code></pre></div>
  <p>Rust has move semantics by default, so if we want to make a copy of so=
me data, we call the <code>clone()</code> method. In this example, <code>y<=
/code> is no longer a reference to the vector stored in <code>x</code>, but=
 a copy of its first element, <code>"Hello"</code>. Now that we don=E2=80=
=99t have a reference, our <code>push()</code> works just fine.</p>
  <p>If we truly want a reference, we need the other option: ensure that ou=
r reference goes out of scope before we try to do the mutation. That looks =
like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> x =3D <sp=
an class=3D"ot">vec!</span>[<span class=3D"st">"Hello"</span>, <span class=
=3D"st">"world"</span>];
 =20
      {
          <span class=3D"kw">let</span> y =3D &amp;x[<span class=3D"dv">0</=
span>];
      }
 =20
      x.push(<span class=3D"st">"foo"</span>);
  }</code></pre></div>
  <p>We created an inner scope with an additional set of curly braces. <cod=
e>y</code> will go out of scope before we call <code>push()</code>, and so =
we=E2=80=99re all good.</p>
  <p>This concept of ownership isn=E2=80=99t just good for preventing dangl=
ing pointers, but an entire set of related problems, like iterator invalida=
tion, concurrency, and more.</p>
  <h1 id=3D"sec--getting-started">Getting Started</h1>
  <p>This first section of the book will get you going with Rust and its to=
oling. First, we=E2=80=99ll install Rust. Then, the classic =E2=80=98Hello =
World=E2=80=99 program. Finally, we=E2=80=99ll talk about Cargo, Rust=E2=80=
=99s build system and package manager.</p>
  <h2 id=3D"sec--installing-rust">Installing Rust</h2>
  <p>The first step to using Rust is to install it! There are a number of w=
ays to install Rust, but the easiest is to use the <code>rustup</code> scri=
pt. If you=E2=80=99re on Linux or a Mac, all you need to do is this (note t=
hat you don=E2=80=99t need to type in the <code>$</code>s, they just indica=
te the start of each command):</p>
  <pre><code>$ curl -sf -L https://static.rust-lang.org/rustup.sh | sh</cod=
e></pre>
  <p>If you=E2=80=99re concerned about the <a href=3D"http://curlpipesh.tum=
blr.com/">potential insecurity</a> of using <code>curl | sh</code>, please =
keep reading and see our disclaimer below. And feel free to use a two-step =
version of the installation and examine our installation script:</p>
  <pre><code>$ curl -f -L https://static.rust-lang.org/rustup.sh -O
  $ sh rustup.sh</code></pre>
  <p>If you=E2=80=99re on Windows, please download either the <a href=3D"ht=
tps://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.msi">32=
-bit installer</a> or the <a href=3D"https://static.rust-lang.org/dist/rust=
-1.0.0-beta-x86_64-pc-windows-gnu.msi">64-bit installer</a> and run it.</p>
  <h4 id=3D"uninstalling">Uninstalling</h4>
  <p>If you decide you don=E2=80=99t want Rust anymore, we=E2=80=99ll be a =
bit sad, but that=E2=80=99s okay. Not every programming language is great f=
or everyone. Just run the uninstall script:</p>
  <pre><code>$ sudo /usr/local/lib/rustlib/uninstall.sh</code></pre>
  <p>If you used the Windows installer, just re-run the <code>.msi</code> a=
nd it will give you an uninstall option.</p>
  <p>Some people, and somewhat rightfully so, get very upset when we tell y=
ou to <code>curl | sh</code>. Basically, when you do this, you are trusting=
 that the good people who maintain Rust aren=E2=80=99t going to hack your c=
omputer and do bad things. That=E2=80=99s a good instinct! If you=E2=80=99r=
e one of those people, please check out the documentation on <a href=3D"htt=
ps://github.com/rust-lang/rust#building-from-source">building Rust from Sou=
rce</a>, or <a href=3D"http://www.rust-lang.org/install.html">the official =
binary downloads</a>.</p>
  <p>Oh, we should also mention the officially supported platforms:</p>
  <ul>
  <li>Windows (7, 8, Server 2008 R2)</li>
  <li>Linux (2.6.18 or later, various distributions), x86 and x86-64</li>
  <li>OSX 10.7 (Lion) or greater, x86 and x86-64</li>
  </ul>
  <p>We extensively test Rust on these platforms, and a few others, too, li=
ke Android. But these are the ones most likely to work, as they have the mo=
st testing.</p>
  <p>Finally, a comment about Windows. Rust considers Windows to be a first=
-class platform upon release, but if we=E2=80=99re honest, the Windows expe=
rience isn=E2=80=99t as integrated as the Linux/OS X experience is. We=E2=
=80=99re working on it! If anything does not work, it is a bug. Please let =
us know if that happens. Each and every commit is tested against Windows ju=
st like any other platform.</p>
  <p>If you=E2=80=99ve got Rust installed, you can open up a shell, and typ=
e this:</p>
  <pre><code>$ rustc --version</code></pre>
  <p>You should see the version number, commit hash, commit date and build =
date:</p>
  <pre><code>rustc 1.0.0-beta (9854143cb 2015-04-02) (built 2015-04-02)</co=
de></pre>
  <p>If you did, Rust has been installed successfully! Congrats!</p>
  <p>This installer also installs a copy of the documentation locally, so y=
ou can read it offline. On UNIX systems, <code>/usr/local/share/doc/rust</c=
ode> is the location. On Windows, it=E2=80=99s in a <code>share/doc</code> =
directory, inside wherever you installed Rust to.</p>
  <p>If not, there are a number of places where you can get help. The easie=
st is <a href=3D"irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.=
mozilla.org</a>, which you can access through <a href=3D"http://chat.mibbit=
.com/?server=3Dirc.mozilla.org&amp;channel=3D%23rust">Mibbit</a>. Click tha=
t link, and you=E2=80=99ll be chatting with other Rustaceans (a silly nickn=
ame we call ourselves), and we can help you out. Other great resources incl=
ude <a href=3D"http://users.rust-lang.org/">the user=E2=80=99s forum</a>, a=
nd <a href=3D"http://stackoverflow.com/questions/tagged/rust">Stack Overflo=
w</a>.</p>
  <h2 id=3D"sec--hello-world">Hello, world!</h2>
  <p>Now that you have Rust installed, let=E2=80=99s write your first Rust =
program. It=E2=80=99s traditional to make your first program in any new lan=
guage one that prints the text =E2=80=9CHello, world!=E2=80=9D to the scree=
n. The nice thing about starting with such a simple program is that you can=
 verify that your compiler isn=E2=80=99t just installed, but also working p=
roperly. And printing information to the screen is a pretty common thing to=
 do.</p>
  <p>The first thing that we need to do is make a file to put our code in. =
I like to make a <code>projects</code> directory in my home directory, and =
keep all my projects there. Rust does not care where your code lives.</p>
  <p>This actually leads to one other concern we should address: this guide=
 will assume that you have basic familiarity with the command line. Rust it=
self makes no specific demands on your editing tooling, or where your code =
lives. If you prefer an IDE to the command line, you may want to check out =
<a href=3D"https://github.com/oakes/SolidOak">SolidOak</a>, or wherever plu=
gins are for your favorite IDE. There are a number of extensions of varying=
 quality in development by the community. The Rust team also ships <a href=
=3D"https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">plugi=
ns for various editors</a>. Configuring your editor or IDE is out of the sc=
ope of this tutorial, so check the documentation for your setup, specifical=
ly.</p>
  <p>With that said, let=E2=80=99s make a directory in our projects directo=
ry.</p>
  <pre><code>$ mkdir ~/projects
  $ cd ~/projects
  $ mkdir hello_world
  $ cd hello_world</code></pre>
  <p>If you=E2=80=99re on Windows and not using PowerShell, the <code>~</co=
de> may not work. Consult the documentation for your shell for more details=
.</p>
  <p>Let=E2=80=99s make a new source file next. We=E2=80=99ll call our file=
 <code>main.rs</code>. Rust files always end in a <code>.rs</code> extensio=
n. If you=E2=80=99re using more than one word in your filename, use an unde=
rscore: <code>hello_world.rs</code> rather than <code>helloworld.rs</code>.=
</p>
  <p>Now that you=E2=80=99ve got your file open, type this in:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello, world!"=
</span>);
  }</code></pre></div>
  <p>Save the file, and then type this into your terminal window:</p>
  <pre><code>$ rustc main.rs
  $ ./main # or main.exe on Windows
  Hello, world!</code></pre>
  <p>Success! Let=E2=80=99s go over what just happened in detail.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
 =20
  }</code></pre></div>
  <p>These lines define a <em>function</em> in Rust. The <code>main</code> =
function is special: it=E2=80=99s the beginning of every Rust program. The =
first line says =E2=80=9CI=E2=80=99m declaring a function named <code>main<=
/code> which takes no arguments and returns nothing.=E2=80=9D If there were=
 arguments, they would go inside the parentheses (<code>(</code> and <code>=
)</code>), and because we aren=E2=80=99t returning anything from this funct=
ion, we can omit the return type entirely. We=E2=80=99ll get to it later.</=
p>
  <p>You=E2=80=99ll also note that the function is wrapped in curly braces =
(<code>{</code> and <code>}</code>). Rust requires these around all functio=
n bodies. It is also considered good style to put the opening curly brace o=
n the same line as the function declaration, with one space in between.</p>
  <p>Next up is this line:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    <span class=3D"ot">println!</span>(<span class=3D"st">"=
Hello, world!"</span>);</code></pre></div>
  <p>This line does all of the work in our little program. There are a numb=
er of details that are important here. The first is that it=E2=80=99s inden=
ted with four spaces, not tabs. Please configure your editor of choice to i=
nsert four spaces with the tab key. We provide some <a href=3D"https://gith=
ub.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md">sample configurations=
 for various editors</a>.</p>
  <p>The second point is the <code>println!()</code> part. This is calling =
a Rust <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.ht=
ml#sec--macros">macro</a>, which is how metaprogramming is done in Rust. If=
 it were a function instead, it would look like this: <code>println()</code=
>. For our purposes, we don=E2=80=99t need to worry about this difference. =
Just know that sometimes, you=E2=80=99ll see a <code>!</code>, and that mea=
ns that you=E2=80=99re calling a macro instead of a normal function. Rust i=
mplements <code>println!</code> as a macro rather than a function for good =
reasons, but that=E2=80=99s an advanced topic. One last thing to mention: R=
ust=E2=80=99s macros are significantly different from C macros, if you=E2=
=80=99ve used those. Don=E2=80=99t be scared of using macros. We=E2=80=99ll=
 get to the details eventually, you=E2=80=99ll just have to trust us for no=
w.</p>
  <p>Next, <code>"Hello, world!"</code> is a =E2=80=98string=E2=80=99. Stri=
ngs are a surprisingly complicated topic in a systems programming language,=
 and this is a =E2=80=98statically allocated=E2=80=99 string. If you want t=
o read further about allocation, check out <a href=3D"https://killercup.git=
hub.io/trpl-ebook/trpl-2015-05-13.html#sec--the-stack-and-the-heap">the sta=
ck and the heap</a>, but you don=E2=80=99t need to right now if you don=E2=
=80=99t want to. We pass this string as an argument to <code>println!</code=
>, which prints the string to the screen. Easy enough!</p>
  <p>Finally, the line ends with a semicolon (<code>;</code>). Rust is an =
=E2=80=98expression oriented=E2=80=99 language, which means that most thing=
s are expressions, rather than statements. The <code>;</code> is used to in=
dicate that this expression is over, and the next one is ready to begin. Mo=
st lines of Rust code end with a <code>;</code>.</p>
  <p>Finally, actually compiling and running our program. We can compile wi=
th our compiler, <code>rustc</code>, by passing it the name of our source f=
ile:</p>
  <pre><code>$ rustc main.rs</code></pre>
  <p>This is similar to <code>gcc</code> or <code>clang</code>, if you come=
 from a C or C++ background. Rust will output a binary executable. You can =
see it with <code>ls</code>:</p>
  <pre><code>$ ls
  main  main.rs</code></pre>
  <p>Or on Windows:</p>
  <pre><code>$ dir
  main.exe  main.rs</code></pre>
  <p>There are now two files: our source code, with the <code>.rs</code> ex=
tension, and the executable (<code>main.exe</code> on Windows, <code>main</=
code> everywhere else)</p>
  <pre><code>$ ./main  # or main.exe on Windows</code></pre>
  <p>This prints out our <code>Hello, world!</code> text to our terminal.</=
p>
  <p>If you come from a dynamic language like Ruby, Python, or JavaScript, =
you may not be used to these two steps being separate. Rust is an =E2=80=98=
ahead-of-time compiled language=E2=80=99, which means that you can compile =
a program, give it to someone else, and they don=E2=80=99t need to have Rus=
t installed. If you give someone a <code>.rb</code> or <code>.py</code> or =
<code>.js</code> file, they need to have a Ruby/Python/JavaScript implement=
ation installed, but you just need one command to both compile and run your=
 program. Everything is a tradeoff in language design, and Rust has made it=
s choice.</p>
  <p>Congratulations! You have officially written a Rust program. That make=
s you a Rust programmer! Welcome. =F0=9F=8E=8A=F0=9F=8E=89=F0=9F=91=8D</p>
  <p>Next, I=E2=80=99d like to introduce you to another tool, Cargo, which =
is used to write real-world Rust programs. Just using <code>rustc</code> is=
 nice for simple things, but as your project grows, you=E2=80=99ll want som=
ething to help you manage all of the options that it has, and to make it ea=
sy to share your code with other people and projects.</p>
  <h2 id=3D"sec--hello-cargo">Hello, Cargo!</h2>
  <p><a href=3D"http://doc.crates.io/">Cargo</a> is a tool that Rustaceans =
use to help manage their Rust projects. Cargo is currently in a pre-1.0 sta=
te, and so it is still a work in progress. However, it is already good enou=
gh to use for many Rust projects, and so it is assumed that Rust projects w=
ill use Cargo from the beginning.</p>
  <p>Cargo manages three things: building your code, downloading the depend=
encies your code needs, and building those dependencies. At first, your pro=
gram doesn=E2=80=99t have any dependencies, so we=E2=80=99ll only be using =
the first part of its functionality. Eventually, we=E2=80=99ll add more. Si=
nce we started off by using Cargo, it=E2=80=99ll be easy to add later.</p>
  <p>If you installed Rust via the official installers you will also have C=
argo. If you installed Rust some other way, you may want to <a href=3D"http=
s://github.com/rust-lang/cargo#installing-cargo-from-nightlies">check the C=
argo README</a> for specific instructions about installing it.</p>
  <h4 id=3D"converting-to-cargo">Converting to Cargo</h4>
  <p>Let=E2=80=99s convert Hello World to Cargo.</p>
  <p>To Cargo-ify our project, we need to do two things: Make a <code>Cargo=
.toml</code> configuration file, and put our source file in the right place=
. Let=E2=80=99s do that part first:</p>
  <pre><code>$ mkdir src
  $ mv main.rs src/main.rs</code></pre>
  <p>Note that since we=E2=80=99re creating an executable, we used <code>ma=
in.rs</code>. If we want to make a library instead, we should use <code>lib=
.rs</code>. Custom file locations for the entry point can be specified with=
 a <a href=3D"http://doc.crates.io/manifest.html#configuring-a-target"><cod=
e>[[lib]]</code> or <code>[[bin]]</code></a> key in the TOML file described=
 below.</p>
  <p>Cargo expects your source files to live inside a <code>src</code> dire=
ctory. That leaves the top level for other things, like READMEs, license in=
formation, and anything not related to your code. Cargo helps us keep our p=
rojects nice and tidy. A place for everything, and everything in its place.=
</p>
  <p>Next, our configuration file:</p>
  <pre><code>$ editor Cargo.toml</code></pre>
  <p>Make sure to get this name right: you need the capital <code>C</code>!=
</p>
  <p>Put this inside:</p>
  <pre><code>[package]
 =20
  name =3D "hello_world"
  version =3D "0.0.1"
  authors =3D [ "Your name &lt;you@example.com&gt;" ]</code></pre>
  <p>This file is in the <a href=3D"https://github.com/toml-lang/toml">TOML=
</a> format. Let=E2=80=99s let it explain itself to you:</p>
  <blockquote>
  <p>TOML aims to be a minimal configuration file format that=E2=80=99s eas=
y to read due to obvious semantics. TOML is designed to map unambiguously t=
o a hash table. TOML should be easy to parse into data structures in a wide=
 variety of languages.</p>
  </blockquote>
  <p>TOML is very similar to INI, but with some extra goodies.</p>
  <p>Once you have this file in place, we should be ready to build! Try thi=
s:</p>
  <pre><code>$ cargo build
     Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_wor=
ld)
  $ ./target/debug/hello_world
  Hello, world!</code></pre>
  <p>Bam! We build our project with <code>cargo build</code>, and run it wi=
th <code>./target/debug/hello_world</code>. We can do both in one step with=
 <code>cargo run</code>:</p>
  <pre><code>$ cargo run
       Running `target/debug/hello_world`
  Hello, world!</code></pre>
  <p>Notice that we didn=E2=80=99t re-build the project this time. Cargo fi=
gured out that we hadn=E2=80=99t changed the source file, and so it just ra=
n the binary. If we had made a modification, we would have seen it do both:=
</p>
  <pre><code>$ cargo run
     Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_wor=
ld)
       Running `target/debug/hello_world`
  Hello, world!</code></pre>
  <p>This hasn=E2=80=99t bought us a whole lot over our simple use of <code=
>rustc</code>, but think about the future: when our project gets more compl=
ex, we would need to do more things to get all of the parts to properly com=
pile. With Cargo, as our project grows, we can just <code>cargo build</code=
>, and it=E2=80=99ll work the right way.</p>
  <p>When your project is finally ready for release, you can use <code>carg=
o build --release</code> to compile your project with optimizations.</p>
  <p>You=E2=80=99ll also notice that Cargo has created a new file: <code>Ca=
rgo.lock</code>.</p>
  <pre><code>[root]
  name =3D "hello_world"
  version =3D "0.0.1"</code></pre>
  <p>This file is used by Cargo to keep track of dependencies in your appli=
cation. Right now, we don=E2=80=99t have any, so it=E2=80=99s a bit sparse.=
 You won=E2=80=99t ever need to touch this file yourself, just let Cargo ha=
ndle it.</p>
  <p>That=E2=80=99s it! We=E2=80=99ve successfully built <code>hello_world<=
/code> with Cargo. Even though our program is simple, it=E2=80=99s using mu=
ch of the real tooling that you=E2=80=99ll use for the rest of your Rust ca=
reer. You can expect to do this to get started with virtually all Rust proj=
ects:</p>
  <pre><code>$ git clone someurl.com/foo
  $ cd foo
  $ cargo build</code></pre>
  <h4 id=3D"a-new-project">A New Project</h4>
  <p>You don=E2=80=99t have to go through this whole process every time you=
 want to start a new project! Cargo has the ability to make a bare-bones pr=
oject directory in which you can start developing right away.</p>
  <p>To start a new project with Cargo, use <code>cargo new</code>:</p>
  <pre><code>$ cargo new hello_world --bin</code></pre>
  <p>We=E2=80=99re passing <code>--bin</code> because we=E2=80=99re making =
a binary program: if we were making a library, we=E2=80=99d leave it off.</=
p>
  <p>Let=E2=80=99s check out what Cargo has generated for us:</p>
  <pre><code>$ cd hello_world
  $ tree .
  .
  =E2=94=9C=E2=94=80=E2=94=80 Cargo.toml
  =E2=94=94=E2=94=80=E2=94=80 src
      =E2=94=94=E2=94=80=E2=94=80 main.rs
 =20
  1 directory, 2 files</code></pre>
  <p>If you don=E2=80=99t have the <code>tree</code> command, you can proba=
bly get it from your distribution=E2=80=99s package manager. It=E2=80=99s n=
ot necessary, but it=E2=80=99s certainly useful.</p>
  <p>This is all we need to get started. First, let=E2=80=99s check out <co=
de>Cargo.toml</code>:</p>
  <pre><code>[package]
 =20
  name =3D "hello_world"
  version =3D "0.0.1"
  authors =3D ["Your Name &lt;you@example.com&gt;"]</code></pre>
  <p>Cargo has populated this file with reasonable defaults based off the a=
rguments you gave it and your <code>git</code> global configuration. You ma=
y notice that Cargo has also initialized the <code>hello_world</code> direc=
tory as a <code>git</code> repository.</p>
  <p>Here=E2=80=99s what=E2=80=99s in <code>src/main.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello, world!"=
</span>);
  }</code></pre></div>
  <p>Cargo has generated a =E2=80=9CHello World!=E2=80=9D for us, and you=
=E2=80=99re ready to start coding! Cargo has its own <a href=3D"http://doc.=
crates.io/guide.html">guide</a> which covers Cargo=E2=80=99s features in mu=
ch more depth.</p>
  <p>Now that you=E2=80=99ve got the tools down, let=E2=80=99s actually lea=
rn more about the Rust language itself. These are the basics that will serv=
e you well through the rest of your time with Rust.</p>
  <p>You have two options: Dive into a project with =E2=80=98<a href=3D"htt=
ps://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--learn-rust">L=
earn Rust</a>=E2=80=99, or start from the bottom and work your way up with =
=E2=80=98<a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.=
html#sec--syntax-and-semantics">Syntax and Semantics</a>=E2=80=99. More exp=
erienced systems programmers will probably prefer =E2=80=98Learn Rust=E2=80=
=99, while those from dynamic backgrounds may enjoy either. Different peopl=
e learn differently! Choose whatever=E2=80=99s right for you.</p>
  <h1 id=3D"sec--learn-rust">Learn Rust</h1>
  <p>Welcome! This section has a few tutorials that teach you Rust through =
building projects. You=E2=80=99ll get a high-level overview, but we=E2=80=
=99ll skim over the details.</p>
  <p>If you=E2=80=99d prefer a more =E2=80=98from the ground up=E2=80=99-st=
yle experience, check out <a href=3D"https://killercup.github.io/trpl-ebook=
/trpl-2015-05-13.html#sec--syntax-and-semantics">Syntax and Semantics</a>.<=
/p>
  <h2 id=3D"sec--guessing-game">Guessing Game</h2>
  <p>For our first project, we=E2=80=99ll implement a classic beginner prog=
ramming problem: the guessing game. Here=E2=80=99s how it works: Our progra=
m will generate a random integer between one and a hundred. It will then pr=
ompt us to enter a guess. Upon entering our guess, it will tell us if we=E2=
=80=99re too low or too high. Once we guess correctly, it will congratulate=
 us. Sounds good?</p>
  <h3 id=3D"set-up">Set up</h3>
  <p>Let=E2=80=99s set up a new project. Go to your projects directory. Rem=
ember how we had to create our directory structure and a <code>Cargo.toml</=
code> for <code>hello_world</code>? Cargo has a command that does that for =
us. Let=E2=80=99s give it a shot:</p>
  <pre><code>$ cd ~/projects
  $ cargo new guessing_game --bin
  $ cd guessing_game</code></pre>
  <p>We pass the name of our project to <code>cargo new</code>, and then th=
e <code>--bin</code> flag, since we=E2=80=99re making a binary, rather than=
 a library.</p>
  <p>Check out the generated <code>Cargo.toml</code>:</p>
  <pre><code>[package]
 =20
  name =3D "guessing_game"
  version =3D "0.0.1"
  authors =3D ["Your Name &lt;you@example.com&gt;"]</code></pre>
  <p>Cargo gets this information from your environment. If it=E2=80=99s not=
 correct, go ahead and fix that.</p>
  <p>Finally, Cargo generated a =E2=80=98Hello, world!=E2=80=99 for us. Che=
ck out <code>src/main.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello, world!"=
</span>)
  }</code></pre></div>
  <p>Let=E2=80=99s try compiling what Cargo gave us:</p>
  <pre><code>$ cargo build
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_gam=
e)</code></pre>
  <p>Excellent! Open up your <code>src/main.rs</code> again. We=E2=80=99ll =
be writing all of our code in this file.</p>
  <p>Before we move on, let me show you one more Cargo command: <code>run</=
code>. <code>cargo run</code> is kind of like <code>cargo build</code>, but=
 it also then runs the produced executable. Try it out:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_gam=
e)
       Running `target/debug/guessing_game`
  Hello, world!</code></pre>
  <p>Great! The <code>run</code> command comes in handy when you need to ra=
pidly iterate on a project. Our game is just such a project, we need to qui=
ckly test each iteration before moving on to the next one.</p>
  <h3 id=3D"processing-a-guess">Processing a Guess</h3>
  <p>Let=E2=80=99s get to it! The first thing we need to do for our guessin=
g game is allow our player to input a guess. Put this in your <code>src/mai=
n.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::io;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Guess the numb=
er!"</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"Please input y=
our guess."</span>);
 =20
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> guess =3D=
 String::new();
 =20
      io::stdin().read_line(&amp;<span class=3D"kw">mut</span> guess)
          .ok()
          .expect(<span class=3D"st">"Failed to read line"</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"You guessed: {=
}"</span>, guess);
  }</code></pre></div>
  <p>There=E2=80=99s a lot here! Let=E2=80=99s go over it, bit by bit.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::io;</code></pre></div>
  <p>We=E2=80=99ll need to take user input, and then print the result as ou=
tput. As such, we need the <code>io</code> library from the standard librar=
y. Rust only imports a few things into every program, <a href=3D"http://doc=
.rust-lang.org/std/prelude/index.html">the =E2=80=98prelude=E2=80=99</a>. I=
f it=E2=80=99s not in the prelude, you=E2=80=99ll have to <code>use</code> =
it directly.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {</code></pre></div>
  <p>As you=E2=80=99ve seen before, the <code>main()</code> function is the=
 entry point into your program. The <code>fn</code> syntax declares a new f=
unction, the <code>()</code>s indicate that there are no arguments, and <co=
de>{</code> starts the body of the function. Because we didn=E2=80=99t incl=
ude a return type, it=E2=80=99s assumed to be <code>()</code>, an empty <a =
href=3D"https://killercup.github.io/trpl-ebook/primitive-types.html#tuples"=
>tuple</a>.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    <span class=3D"ot">println!</span>(<span class=3D"st">"=
Guess the number!"</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"Please input y=
our guess."</span>);</code></pre></div>
  <p>We previously learned that <code>println!()</code> is a <a href=3D"htt=
ps://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--macros">macro=
</a> that prints a <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2=
015-05-13.html#sec--strings">string</a> to the screen.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    <span class=3D"kw">let</span> <span class=3D"kw">mut</s=
pan> guess =3D String::new();</code></pre></div>
  <p>Now we=E2=80=99re getting interesting! There=E2=80=99s a lot going on =
in this little line. The first thing to notice is that this is a <a href=3D=
"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--variable-=
bindings">let statement</a>, which is used to create =E2=80=98variable bind=
ings=E2=80=99. They take this form:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> foo =3D bar;</code></pre></di=
v>
  <p>This will create a new binding named <code>foo</code>, and bind it to =
the value <code>bar</code>. In many languages, this is called a =E2=80=98va=
riable=E2=80=99, but Rust=E2=80=99s variable bindings have a few tricks up =
their sleeves.</p>
  <p>For example, they=E2=80=99re <a href=3D"https://killercup.github.io/tr=
pl-ebook/trpl-2015-05-13.html#sec--mutability">immutable</a> by default. Th=
at=E2=80=99s why our example uses <code>mut</code>: it makes a binding muta=
ble, rather than immutable. <code>let</code> doesn=E2=80=99t take a name on=
 the left hand side, it actually accepts a =E2=80=98<a href=3D"https://kill=
ercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--patterns">pattern</a>=
=E2=80=99. We=E2=80=99ll use patterns more later. It=E2=80=99s easy enough =
to use for now:</p>
  <pre><code>let foo =3D 5; // immutable.
  let mut bar =3D 5; // mutable</code></pre>
  <p>Oh, and <code>//</code> will start a comment, until the end of the lin=
e. Rust ignores everything in <a href=3D"https://killercup.github.io/trpl-e=
book/trpl-2015-05-13.html#sec--comments">comments</a>.</p>
  <p>So now we know that <code>let mut guess</code> will introduce a mutabl=
e binding named <code>guess</code>, but we have to look at the other side o=
f the <code>=3D</code> for what it=E2=80=99s bound to: <code>String::new()<=
/code>.</p>
  <p><code>String</code> is a string type, provided by the standard library=
. A <a href=3D"http://doc.rust-lang.org/std/string/struct.String.html"><cod=
e>String</code></a> is a growable, UTF-8 encoded bit of text.</p>
  <p>The <code>::new()</code> syntax uses <code>::</code> because this is a=
n =E2=80=98associated function=E2=80=99 of a particular type. That is to sa=
y, it=E2=80=99s associated with <code>String</code> itself, rather than a p=
articular instance of a <code>String</code>. Some languages call this a =E2=
=80=98static method=E2=80=99.</p>
  <p>This function is named <code>new()</code>, because it creates a new, e=
mpty <code>String</code>. You=E2=80=99ll find a <code>new()</code> function=
 on many types, as it=E2=80=99s a common name for making a new value of som=
e kind.</p>
  <p>Let=E2=80=99s move forward:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    io::stdin().read_line(&amp;<span class=3D"kw">mut</span=
> guess)
          .ok()
          .expect(<span class=3D"st">"Failed to read line"</span>);</code><=
/pre></div>
  <p>That=E2=80=99s a lot more! Let=E2=80=99s go bit-by-bit. The first line=
 has two parts. Here=E2=80=99s the first:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">io::stdin()</code></pre></div>
  <p>Remember how we <code>use</code>d <code>std::io</code> on the first li=
ne of the program? We=E2=80=99re now calling an associated function on it. =
If we didn=E2=80=99t <code>use std::io</code>, we could have written this l=
ine as <code>std::io::stdin()</code>.</p>
  <p>This particular function returns a handle to the standard input for yo=
ur terminal. More specifically, a <a href=3D"http://doc.rust-lang.org/std/i=
o/struct.Stdin.html">std::io::Stdin</a>.</p>
  <p>The next part will use this handle to get input from the user:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">.read_line(&amp;<span class=3D"kw">mut</span> guess)</code>=
</pre></div>
  <p>Here, we call the <a href=3D"http://doc.rust-lang.org/std/io/struct.St=
din.html#method.read_line"><code>read_line()</code></a> method on our handl=
e. <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#s=
ec--method-syntax">Methods</a> are like associated functions, but are only =
available on a particular instance of a type, rather than the type itself. =
We=E2=80=99re also passing one argument to <code>read_line()</code>: <code>=
&amp;mut guess</code>.</p>
  <p>Remember how we bound <code>guess</code> above? We said it was mutable=
. However, <code>read_line</code> doesn=E2=80=99t take a <code>String</code=
> as an argument: it takes a <code>&amp;mut String</code>. Rust has a featu=
re called =E2=80=98<a href=3D"https://killercup.github.io/trpl-ebook/trpl-2=
015-05-13.html#sec--references-and-borrowing">references</a>=E2=80=99, whic=
h allows you to have multiple references to one piece of data, which can re=
duce copying. References are a complex feature, as one of Rust=E2=80=99s ma=
jor selling points is how safe and easy it is to use references. We don=E2=
=80=99t need to know a lot of those details to finish our program right now=
, though. For now, all we need to know is that like <code>let</code> bindin=
gs, references are immutable by default. Hence, we need to write <code>&amp=
;mut guess</code>, rather than <code>&amp;guess</code>.</p>
  <p>Why does <code>read_line()</code> take a mutable reference to a string=
? Its job is to take what the user types into standard input, and place tha=
t into a string. So it takes that string as an argument, and in order to ad=
d the input, it needs to be mutable.</p>
  <p>But we=E2=80=99re not quite done with this line of code, though. While=
 it=E2=80=99s a single line of text, it=E2=80=99s only the first part of th=
e single logical line of code:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">        .ok()
          .expect(<span class=3D"st">"Failed to read line"</span>);</code><=
/pre></div>
  <p>When you call a method with the <code>.foo()</code> syntax, you may in=
troduce a newline and other whitespace. This helps you split up long lines.=
 We <em>could</em> have done:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    io::stdin().read_line(&amp;<span class=3D"kw">mut</span=
> guess).ok().expect(<span class=3D"st">"failed to read line"</span>);</cod=
e></pre></div>
  <p>But that gets hard to read. So we=E2=80=99ve split it up, three lines =
for three method calls. We already talked about <code>read_line()</code>, b=
ut what about <code>ok()</code> and <code>expect()</code>? Well, we already=
 mentioned that <code>read_line()</code> puts what the user types into the =
<code>&amp;mut String</code> we pass it. But it also returns a value: in th=
is case, an <a href=3D"http://doc.rust-lang.org/std/io/type.Result.html"><c=
ode>io::Result</code></a>. Rust has a number of types named <code>Result</c=
ode> in its standard library: a generic <a href=3D"http://doc.rust-lang.org=
/std/result/enum.Result.html"><code>Result</code></a>, and then specific ve=
rsions for sub-libraries, like <code>io::Result</code>.</p>
  <p>The purpose of these <code>Result</code> types is to encode error hand=
ling information. Values of the <code>Result</code> type, like any type, ha=
ve methods defined on them. In this case, <code>io::Result</code> has an <c=
ode>ok()</code> method, which says =E2=80=98we want to assume this value is=
 a successful one. If not, just throw away the error information=E2=80=99. =
Why throw it away? Well, for a basic program, we just want to print a gener=
ic error, as basically any issue means we can=E2=80=99t continue. The <a hr=
ef=3D"http://doc.rust-lang.org/std/result/enum.Result.html#method.ok"><code=
>ok()</code> method</a> returns a value which has another method defined on=
 it: <code>expect()</code>. The <a href=3D"http://doc.rust-lang.org/std/opt=
ion/enum.Option.html#method.expect"><code>expect()</code> method</a> takes =
a value it=E2=80=99s called on, and if it isn=E2=80=99t a successful one, <=
a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--=
error-handling"><code>panic!</code></a>s with a message you passed it. A <c=
ode>panic!</code> like this will cause our program to crash, displaying the=
 message.</p>
  <p>If we leave off calling these two methods, our program will compile, b=
ut we=E2=80=99ll get a warning:</p>
  <pre><code>$ cargo build
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_gam=
e)
  src/main.rs:10:5: 10:39 warning: unused result which must be used,
  #[warn(unused_must_use)] on by default
  src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>Rust warns us that we haven=E2=80=99t used the <code>Result</code> val=
ue. This warning comes from a special annotation that <code>io::Result</cod=
e> has. Rust is trying to tell you that you haven=E2=80=99t handled a possi=
ble error. The right way to suppress the error is to actually write error h=
andling. Luckily, if we just want to crash if there=E2=80=99s a problem, we=
 can use these two little methods. If we can recover from the error somehow=
, we=E2=80=99d do something else, but we=E2=80=99ll save that for a future =
project.</p>
  <p>There=E2=80=99s just one line of this first example left:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    <span class=3D"ot">println!</span>(<span class=3D"st">"=
You guessed: {}"</span>, guess);
  }</code></pre></div>
  <p>This prints out the string we saved our input in. The <code>{}</code>s=
 are a placeholder, and so we pass it <code>guess</code> as an argument. If=
 we had multiple <code>{}</code>s, we would pass multiple arguments:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
  <span class=3D"kw">let</span> y =3D <span class=3D"dv">10</span>;
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"x and y: {} and {}=
"</span>, x, y);</code></pre></div>
  <p>Easy.</p>
  <p>Anyway, that=E2=80=99s the tour. We can run what we have with <code>ca=
rgo run</code>:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_gam=
e)
       Running `target/debug/guessing_game`
  Guess the number!
  Please input your guess.
  6
  You guessed: 6</code></pre>
  <p>All right! Our first part is done: we can get input from the keyboard,=
 and then print it back out.</p>
  <h3 id=3D"generating-a-secret-number">Generating a secret number</h3>
  <p>Next, we need to generate a secret number. Rust does not yet include r=
andom number functionality in its standard library. The Rust team does, how=
ever, provide a <a href=3D"https://crates.io/crates/rand"><code>rand</code>=
 crate</a>. A =E2=80=98crate=E2=80=99 is a package of Rust code. We=E2=80=
=99ve been building a =E2=80=98binary crate=E2=80=99, which is an executabl=
e. <code>rand</code> is a =E2=80=98library crate=E2=80=99, which contains c=
ode that=E2=80=99s intended to be used with other programs.</p>
  <p>Using external crates is where Cargo really shines. Before we can writ=
e the code using <code>rand</code>, we need to modify our <code>Cargo.toml<=
/code>. Open it up, and add these few lines at the bottom:</p>
  <pre><code>[dependencies]
 =20
  rand=3D"0.3.0"</code></pre>
  <p>The <code>[dependencies]</code> section of <code>Cargo.toml</code> is =
like the <code>[package]</code> section: everything that follows it is part=
 of it, until the next section starts. Cargo uses the dependencies section =
to know what dependencies on external crates you have, and what versions yo=
u require. In this case, we=E2=80=99ve used version <code>0.3.0</code>. Car=
go understands <a href=3D"http://semver.org/">Semantic Versioning</a>, whic=
h is a standard for writing version numbers. If we wanted to use the latest=
 version we could use <code>*</code> or we could use a range of versions. <=
a href=3D"http://doc.crates.io/crates-io.html">Cargo=E2=80=99s documentatio=
n</a> contains more details.</p>
  <p>Now, without changing any of our code, let=E2=80=99s build our project=
:</p>
  <pre><code>$ cargo build
      Updating registry `https://github.com/rust-lang/crates.io-index`
   Downloading rand v0.3.8
   Downloading libc v0.1.6
     Compiling libc v0.1.6
     Compiling rand v0.3.8
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_gam=
e)</code></pre>
  <p>(You may see different versions, of course.)</p>
  <p>Lots of new output! Now that we have an external dependency, Cargo fet=
ches the latest versions of everything from the registry, which is a copy o=
f data from <a href=3D"https://crates.io/">Crates.io</a>. Crates.io is wher=
e people in the Rust ecosystem post their open source Rust projects for oth=
ers to use.</p>
  <p>After updating the registry, Cargo checks our <code>[dependencies]</co=
de> and downloads any we don=E2=80=99t have yet. In this case, while we onl=
y said we wanted to depend on <code>rand</code>, we=E2=80=99ve also grabbed=
 a copy of <code>libc</code>. This is because <code>rand</code> depends on =
<code>libc</code> to work. After downloading them, it compiles them, and th=
en compiles our project.</p>
  <p>If we run <code>cargo build</code> again, we=E2=80=99ll get different =
output:</p>
  <pre><code>$ cargo build</code></pre>
  <p>That=E2=80=99s right, no output! Cargo knows that our project has been=
 built, and that all of its dependencies are built, and so there=E2=80=99s =
no reason to do all that stuff. With nothing to do, it simply exits. If we =
open up <code>src/main.rs</code> again, make a trivial change, and then sav=
e it again, we=E2=80=99ll just see one line:</p>
  <pre><code>$ cargo build
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_gam=
e)</code></pre>
  <p>So, we told Cargo we wanted any <code>0.3.x</code> version of <code>ra=
nd</code>, and so it fetched the latest version at the time this was writte=
n, <code>v0.3.8</code>. But what happens when next week, version <code>v0.3=
.9</code> comes out, with an important bugfix? While getting bugfixes is im=
portant, what if <code>0.3.9</code> contains a regression that breaks our c=
ode?</p>
  <p>The answer to this problem is the <code>Cargo.lock</code> file you=E2=
=80=99ll now find in your project directory. When you build your project fo=
r the first time, Cargo figures out all of the versions that fit your crite=
ria, and then writes them to the <code>Cargo.lock</code> file. When you bui=
ld your project in the future, Cargo will see that the <code>Cargo.lock</co=
de> file exists, and then use that specific version rather than do all the =
work of figuring out versions again. This lets you have a repeatable build =
automatically. In other words, we=E2=80=99ll stay at <code>0.3.8</code> unt=
il we explicitly upgrade, and so will anyone who we share our code with, th=
anks to the lock file.</p>
  <p>What about when we <em>do</em> want to use <code>v0.3.9</code>? Cargo =
has another command, <code>update</code>, which says =E2=80=98ignore the lo=
ck, figure out all the latest versions that fit what we=E2=80=99ve specifie=
d. If that works, write those versions out to the lock file=E2=80=99. But, =
by default, Cargo will only look for versions larger than <code>0.3.0</code=
> and smaller than <code>0.4.0</code>. If we want to move to <code>0.4.x</c=
ode>, we=E2=80=99d have to update the <code>Cargo.toml</code> directly. Whe=
n we do, the next time we <code>cargo build</code>, Cargo will update the i=
ndex and re-evaluate our <code>rand</code> requirements.</p>
  <p>There=E2=80=99s a lot more to say about <a href=3D"http://doc.crates.i=
o/">Cargo</a> and <a href=3D"http://doc.crates.io/crates-io.html">its ecosy=
stem</a>, but for now, that=E2=80=99s all we need to know. Cargo makes it r=
eally easy to re-use libraries, and so Rustaceans tend to write smaller pro=
jects which are assembled out of a number of sub-packages.</p>
  <p>Let=E2=80=99s get on to actually <em>using</em> <code>rand</code>. Her=
e=E2=80=99s our next step:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate rand;
 =20
  <span class=3D"kw">use</span> std::io;
  <span class=3D"kw">use</span> rand::Rng;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Guess the numb=
er!"</span>);
 =20
      <span class=3D"kw">let</span> secret_number =3D rand::thread_rng().ge=
n_range(<span class=3D"dv">1</span>, <span class=3D"dv">101</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The secret num=
ber is: {}"</span>, secret_number);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"Please input y=
our guess."</span>);
 =20
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> guess =3D=
 String::new();
 =20
      io::stdin().read_line(&amp;<span class=3D"kw">mut</span> guess)
          .ok()
          .expect(<span class=3D"st">"failed to read line"</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"You guessed: {=
}"</span>, guess);
  }</code></pre></div>
  <p>The first thing we=E2=80=99ve done is change the first line. It now sa=
ys <code>extern crate rand</code>. Because we declared <code>rand</code> in=
 our <code>[dependencies]</code>, we can use <code>extern crate</code> to l=
et Rust know we=E2=80=99ll be making use of it. This also does the equivale=
nt of a <code>use rand;</code> as well, so we can make use of anything in t=
he <code>rand</code> crate by prefixing it with <code>rand::</code>.</p>
  <p>Next, we added another <code>use</code> line: <code>use rand::Rng</cod=
e>. We=E2=80=99re going to use a method in a moment, and it requires that <=
code>Rng</code> be in scope to work. The basic idea is this: methods are de=
fined on something called =E2=80=98traits=E2=80=99, and for the method to w=
ork, it needs the trait to be in scope. For more about the details, read th=
e <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#se=
c--traits">traits</a> section.</p>
  <p>There are two other lines we added, in the middle:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    <span class=3D"kw">let</span> secret_number =3D rand::t=
hread_rng().gen_range(<span class=3D"dv">1</span>, <span class=3D"dv">101</=
span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The secret num=
ber is: {}"</span>, secret_number);</code></pre></div>
  <p>We use the <code>rand::thread_rng()</code> function to get a copy of t=
he random number generator, which is local to the particular <a href=3D"htt=
ps://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--concurrency">=
thread</a> of execution we=E2=80=99re in. Because we <code>use rand::Rng</c=
ode>=E2=80=99d above, it has a <code>gen_range()</code> method available. T=
his method takes two arguments, and generates a number between them. It=E2=
=80=99s inclusive on the lower bound, but exclusive on the upper bound, so =
we need <code>1</code> and <code>101</code> to get a number between one and=
 a hundred.</p>
  <p>The second line just prints out the secret number. This is useful whil=
e we=E2=80=99re developing our program, so we can easily test it out. But w=
e=E2=80=99ll be deleting it for the final version. It=E2=80=99s not much of=
 a game if it prints out the answer when you start it up!</p>
  <p>Try running our new program a few times:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_gam=
e)
       Running `target/debug/guessing_game`
  Guess the number!
  The secret number is: 7
  Please input your guess.
  4
  You guessed: 4
  $ cargo run
       Running `target/debug/guessing_game`
  Guess the number!
  The secret number is: 83
  Please input your guess.
  5
  You guessed: 5</code></pre>
  <p>Great! Next up: let=E2=80=99s compare our guess to the secret guess.</=
p>
  <h3 id=3D"comparing-guesses">Comparing guesses</h3>
  <p>Now that we=E2=80=99ve got user input, let=E2=80=99s compare our guess=
 to the random guess. Here=E2=80=99s our next step, though it doesn=E2=80=
=99t quite work yet:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate rand;
 =20
  <span class=3D"kw">use</span> std::io;
  <span class=3D"kw">use</span> std::cmp::Ordering;
  <span class=3D"kw">use</span> rand::Rng;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Guess the numb=
er!"</span>);
 =20
      <span class=3D"kw">let</span> secret_number =3D rand::thread_rng().ge=
n_range(<span class=3D"dv">1</span>, <span class=3D"dv">101</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The secret num=
ber is: {}"</span>, secret_number);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"Please input y=
our guess."</span>);
 =20
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> guess =3D=
 String::new();
 =20
      io::stdin().read_line(&amp;<span class=3D"kw">mut</span> guess)
          .ok()
          .expect(<span class=3D"st">"failed to read line"</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"You guessed: {=
}"</span>, guess);
 =20
      <span class=3D"kw">match</span> guess.cmp(&amp;secret_number) {
          Ordering::Less    =3D&gt; <span class=3D"ot">println!</span>(<spa=
n class=3D"st">"Too small!"</span>),
          Ordering::Greater =3D&gt; <span class=3D"ot">println!</span>(<spa=
n class=3D"st">"Too big!"</span>),
          Ordering::Equal   =3D&gt; <span class=3D"ot">println!</span>(<spa=
n class=3D"st">"You win!"</span>),
      }
  }</code></pre></div>
  <p>A few new bits here. The first is another <code>use</code>. We bring a=
 type called <code>std::cmp::Ordering</code> into scope. Then, five new lin=
es at the bottom that use it:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">match</span> guess.cmp(&amp;secret_numbe=
r) {
      Ordering::Less    =3D&gt; <span class=3D"ot">println!</span>(<span cl=
ass=3D"st">"Too small!"</span>),
      Ordering::Greater =3D&gt; <span class=3D"ot">println!</span>(<span cl=
ass=3D"st">"Too big!"</span>),
      Ordering::Equal   =3D&gt; <span class=3D"ot">println!</span>(<span cl=
ass=3D"st">"You win!"</span>),
  }</code></pre></div>
  <p>The <code>cmp()</code> method can be called on anything that can be co=
mpared, and it takes a reference to the thing you want to compare it to. It=
 returns the <code>Ordering</code> type we <code>use</code>d earlier. We us=
e a <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#=
sec--match"><code>match</code></a> statement to determine exactly what kind=
 of <code>Ordering</code> it is. <code>Ordering</code> is an <a href=3D"htt=
ps://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--enums"><code>=
enum</code></a>, short for =E2=80=98enumeration=E2=80=99, which looks like =
this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> Foo {
      Bar,
      Baz,
  }</code></pre></div>
  <p>With this definition, anything of type <code>Foo</code> can be either =
a <code>Foo::Bar</code> or a <code>Foo::Baz</code>. We use the <code>::</co=
de> to indicate the namespace for a particular <code>enum</code> variant.</=
p>
  <p>The <a href=3D"http://doc.rust-lang.org/std/cmp/enum.Ordering.html"><c=
ode>Ordering</code></a> enum has three possible variants: <code>Less</code>=
, <code>Equal</code>, and <code>Greater</code>. The <code>match</code> stat=
ement takes a value of a type, and lets you create an =E2=80=98arm=E2=80=99=
 for each possible value. Since we have three types of <code>Ordering</code=
>, we have three arms:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">match</span> guess.cmp(&amp;secret_numbe=
r) {
      Ordering::Less    =3D&gt; <span class=3D"ot">println!</span>(<span cl=
ass=3D"st">"Too small!"</span>),
      Ordering::Greater =3D&gt; <span class=3D"ot">println!</span>(<span cl=
ass=3D"st">"Too big!"</span>),
      Ordering::Equal   =3D&gt; <span class=3D"ot">println!</span>(<span cl=
ass=3D"st">"You win!"</span>),
  }</code></pre></div>
  <p>If it=E2=80=99s <code>Less</code>, we print <code>Too small!</code>, i=
f it=E2=80=99s <code>Greater</code>, <code>Too big!</code>, and if <code>Eq=
ual</code>, <code>You win!</code>. <code>match</code> is really useful, and=
 is used often in Rust.</p>
  <p>I did mention that this won=E2=80=99t quite work yet, though. Let=E2=
=80=99s try it:</p>
  <pre><code>$ cargo build
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_gam=
e)
  src/main.rs:28:21: 28:35 error: mismatched types:
   expected `&amp;collections::string::String`,
      found `&amp;_`
  (expected struct `collections::string::String`,
      found integral variable) [E0308]
  src/main.rs:28     match guess.cmp(&amp;secret_number) {
                                     ^~~~~~~~~~~~~~
  error: aborting due to previous error
  Could not compile `guessing_game`.</code></pre>
  <p>Whew! This is a big error. The core of it is that we have =E2=80=98mis=
matched types=E2=80=99. Rust has a strong, static type system. However, it =
also has type inference. When we wrote <code>let guess =3D String::new()</c=
ode>, Rust was able to infer that <code>guess</code> should be a <code>Stri=
ng</code>, and so it doesn=E2=80=99t make us write out the type. And with o=
ur <code>secret_number</code>, there are a number of types which can have a=
 value between one and a hundred: <code>i32</code>, a thirty-two-bit number=
, or <code>u32</code>, an unsigned thirty-two-bit number, or <code>i64</cod=
e>, a sixty-four-bit number. Or others. So far, that hasn=E2=80=99t mattere=
d, and so Rust defaults to an <code>i32</code>. However, here, Rust doesn=
=E2=80=99t know how to compare the <code>guess</code> and the <code>secret_=
number</code>. They need to be the same type. Ultimately, we want to conver=
t the <code>String</code> we read as input into a real number type, for com=
parison. We can do that with three more lines. Here=E2=80=99s our new progr=
am:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate rand;
 =20
  <span class=3D"kw">use</span> std::io;
  <span class=3D"kw">use</span> std::cmp::Ordering;
  <span class=3D"kw">use</span> rand::Rng;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Guess the numb=
er!"</span>);
 =20
      <span class=3D"kw">let</span> secret_number =3D rand::thread_rng().ge=
n_range(<span class=3D"dv">1</span>, <span class=3D"dv">101</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The secret num=
ber is: {}"</span>, secret_number);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"Please input y=
our guess."</span>);
 =20
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> guess =3D=
 String::new();
 =20
      io::stdin().read_line(&amp;<span class=3D"kw">mut</span> guess)
          .ok()
          .expect(<span class=3D"st">"failed to read line"</span>);
 =20
      <span class=3D"kw">let</span> guess: <span class=3D"kw">u32</span> =
=3D guess.trim().parse()
          .ok()
          .expect(<span class=3D"st">"Please type a number!"</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"You guessed: {=
}"</span>, guess);
 =20
      <span class=3D"kw">match</span> guess.cmp(&amp;secret_number) {
          Ordering::Less    =3D&gt; <span class=3D"ot">println!</span>(<spa=
n class=3D"st">"Too small!"</span>),
          Ordering::Greater =3D&gt; <span class=3D"ot">println!</span>(<spa=
n class=3D"st">"Too big!"</span>),
          Ordering::Equal   =3D&gt; <span class=3D"ot">println!</span>(<spa=
n class=3D"st">"You win!"</span>),
      }
  }</code></pre></div>
  <p>The new three lines:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    <span class=3D"kw">let</span> guess: <span class=3D"kw"=
>u32</span> =3D guess.trim().parse()
          .ok()
          .expect(<span class=3D"st">"Please type a number!"</span>);</code=
></pre></div>
  <p>Wait a minute, I thought we already had a <code>guess</code>? We do, b=
ut Rust allows us to =E2=80=98shadow=E2=80=99 the previous <code>guess</cod=
e> with a new one. This is often used in this exact situation, where <code>=
guess</code> starts as a <code>String</code>, but we want to convert it to =
an <code>u32</code>. Shadowing lets us re-use the <code>guess</code> name, =
rather than forcing us to come up with two unique names like <code>guess_st=
r</code> and <code>guess</code>, or something else.</p>
  <p>We bind <code>guess</code> to an expression that looks like something =
we wrote earlier:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">guess.trim().parse()</code></pre></div>
  <p>Followed by an <code>ok().expect()</code> invocation. Here, <code>gues=
s</code> refers to the old <code>guess</code>, the one that was a <code>Str=
ing</code> with our input in it. The <code>trim()</code> method on <code>St=
ring</code>s will eliminate any white space at the beginning and end of our=
 string. This is important, as we had to press the =E2=80=98return=E2=80=99=
 key to satisfy <code>read_line()</code>. This means that if we type <code>=
5</code> and hit return, <code>guess</code> looks like this: <code>5\n</cod=
e>. The <code>\n</code> represents =E2=80=98newline=E2=80=99, the enter key=
. <code>trim()</code> gets rid of this, leaving our string with just the <c=
ode>5</code>. The <a href=3D"http://doc.rust-lang.org/std/primitive.str.htm=
l#method.parse"><code>parse()</code> method on strings</a> parses a string =
into some kind of number. Since it can parse a variety of numbers, we need =
to give Rust a hint as to the exact type of number we want. Hence, <code>le=
t guess: u32</code>. The colon (<code>:</code>) after <code>guess</code> te=
lls Rust we=E2=80=99re going to annotate its type. <code>u32</code> is an u=
nsigned, thirty-two bit integer. Rust has <a href=3D"https://killercup.gith=
ub.io/trpl-ebook/primitive-types.html#numeric-types">a number of built-in n=
umber types</a>, but we=E2=80=99ve chosen <code>u32</code>. It=E2=80=99s a =
good default choice for a small positive number.</p>
  <p>Just like <code>read_line()</code>, our call to <code>parse()</code> c=
ould cause an error. What if our string contained <code>A=F0=9F=91=8D%</cod=
e>? There=E2=80=99d be no way to convert that to a number. As such, we=E2=
=80=99ll do the same thing we did with <code>read_line()</code>: use the <c=
ode>ok()</code> and <code>expect()</code> methods to crash if there=E2=80=
=99s an error.</p>
  <p>Let=E2=80=99s try our program out!</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_gam=
e)
       Running `target/guessing_game`
  Guess the number!
  The secret number is: 58
  Please input your guess.
    76
  You guessed: 76
  Too big!</code></pre>
  <p>Nice! You can see I even added spaces before my guess, and it still fi=
gured out that I guessed 76. Run the program a few times, and verify that g=
uessing the number works, as well as guessing a number too small.</p>
  <p>Now we=E2=80=99ve got most of the game working, but we can only make o=
ne guess. Let=E2=80=99s change that by adding loops!</p>
  <h3 id=3D"looping">Looping</h3>
  <p>The <code>loop</code> keyword gives us an infinite loop. Let=E2=80=99s=
 add that in:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate rand;
 =20
  <span class=3D"kw">use</span> std::io;
  <span class=3D"kw">use</span> std::cmp::Ordering;
  <span class=3D"kw">use</span> rand::Rng;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Guess the numb=
er!"</span>);
 =20
      <span class=3D"kw">let</span> secret_number =3D rand::thread_rng().ge=
n_range(<span class=3D"dv">1</span>, <span class=3D"dv">101</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The secret num=
ber is: {}"</span>, secret_number);
 =20
      <span class=3D"kw">loop</span> {
          <span class=3D"ot">println!</span>(<span class=3D"st">"Please inp=
ut your guess."</span>);
 =20
          <span class=3D"kw">let</span> <span class=3D"kw">mut</span> guess=
 =3D String::new();
 =20
          io::stdin().read_line(&amp;<span class=3D"kw">mut</span> guess)
              .ok()
              .expect(<span class=3D"st">"failed to read line"</span>);
 =20
          <span class=3D"kw">let</span> guess: <span class=3D"kw">u32</span=
> =3D guess.trim().parse()
              .ok()
              .expect(<span class=3D"st">"Please type a number!"</span>);
 =20
          <span class=3D"ot">println!</span>(<span class=3D"st">"You guesse=
d: {}"</span>, guess);
 =20
          <span class=3D"kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =3D&gt; <span class=3D"ot">println!</span>(=
<span class=3D"st">"Too small!"</span>),
              Ordering::Greater =3D&gt; <span class=3D"ot">println!</span>(=
<span class=3D"st">"Too big!"</span>),
              Ordering::Equal   =3D&gt; <span class=3D"ot">println!</span>(=
<span class=3D"st">"You win!"</span>),
          }
      }
  }</code></pre></div>
  <p>And try it out. But wait, didn=E2=80=99t we just add an infinite loop?=
 Yup. Remember our discussion about <code>parse()</code>? If we give a non-=
number answer, we=E2=80=99ll <code>return</code> and quit. Observe:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_gam=
e)
       Running `target/guessing_game`
  Guess the number!
  The secret number is: 59
  Please input your guess.
  45
  You guessed: 45
  Too small!
  Please input your guess.
  60
  You guessed: 60
  Too big!
  Please input your guess.
  59
  You guessed: 59
  You win!
  Please input your guess.
  quit
  thread '&lt;main&gt;' panicked at 'Please type a number!'</code></pre>
  <p>Ha! <code>quit</code> actually quits. As does any other non-number inp=
ut. Well, this is suboptimal to say the least. First, let=E2=80=99s actuall=
y quit when you win the game:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate rand;
 =20
  <span class=3D"kw">use</span> std::io;
  <span class=3D"kw">use</span> std::cmp::Ordering;
  <span class=3D"kw">use</span> rand::Rng;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Guess the numb=
er!"</span>);
 =20
      <span class=3D"kw">let</span> secret_number =3D rand::thread_rng().ge=
n_range(<span class=3D"dv">1</span>, <span class=3D"dv">101</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The secret num=
ber is: {}"</span>, secret_number);
 =20
      <span class=3D"kw">loop</span> {
          <span class=3D"ot">println!</span>(<span class=3D"st">"Please inp=
ut your guess."</span>);
 =20
          <span class=3D"kw">let</span> <span class=3D"kw">mut</span> guess=
 =3D String::new();
 =20
          io::stdin().read_line(&amp;<span class=3D"kw">mut</span> guess)
              .ok()
              .expect(<span class=3D"st">"failed to read line"</span>);
 =20
          <span class=3D"kw">let</span> guess: <span class=3D"kw">u32</span=
> =3D guess.trim().parse()
              .ok()
              .expect(<span class=3D"st">"Please type a number!"</span>);
 =20
          <span class=3D"ot">println!</span>(<span class=3D"st">"You guesse=
d: {}"</span>, guess);
 =20
          <span class=3D"kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =3D&gt; <span class=3D"ot">println!</span>(=
<span class=3D"st">"Too small!"</span>),
              Ordering::Greater =3D&gt; <span class=3D"ot">println!</span>(=
<span class=3D"st">"Too big!"</span>),
              Ordering::Equal   =3D&gt; {
                  <span class=3D"ot">println!</span>(<span class=3D"st">"Yo=
u win!"</span>);
                  <span class=3D"kw">break</span>;
              }
          }
      }
  }</code></pre></div>
  <p>By adding the <code>break</code> line after the <code>You win!</code>,=
 we=E2=80=99ll exit the loop when we win. Exiting the loop also means exiti=
ng the program, since it=E2=80=99s the last thing in <code>main()</code>. W=
e have just one more tweak to make: when someone inputs a non-number, we do=
n=E2=80=99t want to quit, we just want to ignore it. We can do that like th=
is:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate rand;
 =20
  <span class=3D"kw">use</span> std::io;
  <span class=3D"kw">use</span> std::cmp::Ordering;
  <span class=3D"kw">use</span> rand::Rng;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Guess the numb=
er!"</span>);
 =20
      <span class=3D"kw">let</span> secret_number =3D rand::thread_rng().ge=
n_range(<span class=3D"dv">1</span>, <span class=3D"dv">101</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The secret num=
ber is: {}"</span>, secret_number);
 =20
      <span class=3D"kw">loop</span> {
          <span class=3D"ot">println!</span>(<span class=3D"st">"Please inp=
ut your guess."</span>);
 =20
          <span class=3D"kw">let</span> <span class=3D"kw">mut</span> guess=
 =3D String::new();
 =20
          io::stdin().read_line(&amp;<span class=3D"kw">mut</span> guess)
              .ok()
              .expect(<span class=3D"st">"failed to read line"</span>);
 =20
          <span class=3D"kw">let</span> guess: <span class=3D"kw">u32</span=
> =3D <span class=3D"kw">match</span> guess.trim().parse() {
              <span class=3D"kw">Ok</span>(num) =3D&gt; num,
              <span class=3D"kw">Err</span>(_) =3D&gt; <span class=3D"kw">c=
ontinue</span>,
          };
 =20
          <span class=3D"ot">println!</span>(<span class=3D"st">"You guesse=
d: {}"</span>, guess);
 =20
          <span class=3D"kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =3D&gt; <span class=3D"ot">println!</span>(=
<span class=3D"st">"Too small!"</span>),
              Ordering::Greater =3D&gt; <span class=3D"ot">println!</span>(=
<span class=3D"st">"Too big!"</span>),
              Ordering::Equal   =3D&gt; {
                  <span class=3D"ot">println!</span>(<span class=3D"st">"Yo=
u win!"</span>);
                  <span class=3D"kw">break</span>;
              }
          }
      }
  }</code></pre></div>
  <p>These are the lines that changed:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> guess: <span class=3D"kw">u32=
</span> =3D <span class=3D"kw">match</span> guess.trim().parse() {
      <span class=3D"kw">Ok</span>(num) =3D&gt; num,
      <span class=3D"kw">Err</span>(_) =3D&gt; <span class=3D"kw">continue<=
/span>,
  };</code></pre></div>
  <p>This is how you generally move from =E2=80=98crash on error=E2=80=99 t=
o =E2=80=98actually handle the error=E2=80=99, by switching from <code>ok()=
.expect()</code> to a <code>match</code> statement. The <code>Result</code>=
 returned by <code>parse()</code> is an enum just like <code>Ordering</code=
>, but in this case, each variant has some data associated with it: <code>O=
k</code> is a success, and <code>Err</code> is a failure. Each contains mor=
e information: the successful parsed integer, or an error type. In this cas=
e, we <code>match</code> on <code>Ok(num)</code>, which sets the inner valu=
e of the <code>Ok</code> to the name <code>num</code>, and then we just ret=
urn it on the right-hand side. In the <code>Err</code> case, we don=E2=80=
=99t care what kind of error it is, so we just use <code>_</code> instead o=
f a name. This ignores the error, and <code>continue</code> causes us to go=
 to the next iteration of the <code>loop</code>.</p>
  <p>Now we should be good! Let=E2=80=99s try:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_gam=
e)
       Running `target/guessing_game`
  Guess the number!
  The secret number is: 61
  Please input your guess.
  10
  You guessed: 10
  Too small!
  Please input your guess.
  99
  You guessed: 99
  Too big!
  Please input your guess.
  foo
  Please input your guess.
  61
  You guessed: 61
  You win!</code></pre>
  <p>Awesome! With one tiny last tweak, we have finished the guessing game.=
 Can you think of what it is? That=E2=80=99s right, we don=E2=80=99t want t=
o print out the secret number. It was good for testing, but it kind of ruin=
s the game. Here=E2=80=99s our final source:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate rand;
 =20
  <span class=3D"kw">use</span> std::io;
  <span class=3D"kw">use</span> std::cmp::Ordering;
  <span class=3D"kw">use</span> rand::Rng;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Guess the numb=
er!"</span>);
 =20
      <span class=3D"kw">let</span> secret_number =3D rand::thread_rng().ge=
n_range(<span class=3D"dv">1</span>, <span class=3D"dv">101</span>);
 =20
      <span class=3D"kw">loop</span> {
          <span class=3D"ot">println!</span>(<span class=3D"st">"Please inp=
ut your guess."</span>);
 =20
          <span class=3D"kw">let</span> <span class=3D"kw">mut</span> guess=
 =3D String::new();
 =20
          io::stdin().read_line(&amp;<span class=3D"kw">mut</span> guess)
              .ok()
              .expect(<span class=3D"st">"failed to read line"</span>);
 =20
          <span class=3D"kw">let</span> guess: <span class=3D"kw">u32</span=
> =3D <span class=3D"kw">match</span> guess.trim().parse() {
              <span class=3D"kw">Ok</span>(num) =3D&gt; num,
              <span class=3D"kw">Err</span>(_) =3D&gt; <span class=3D"kw">c=
ontinue</span>,
          };
 =20
          <span class=3D"ot">println!</span>(<span class=3D"st">"You guesse=
d: {}"</span>, guess);
 =20
          <span class=3D"kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =3D&gt; <span class=3D"ot">println!</span>(=
<span class=3D"st">"Too small!"</span>),
              Ordering::Greater =3D&gt; <span class=3D"ot">println!</span>(=
<span class=3D"st">"Too big!"</span>),
              Ordering::Equal   =3D&gt; {
                  <span class=3D"ot">println!</span>(<span class=3D"st">"Yo=
u win!"</span>);
                  <span class=3D"kw">break</span>;
              }
          }
      }
  }</code></pre></div>
  <h3 id=3D"complete">Complete!</h3>
  <p>At this point, you have successfully built the Guessing Game! Congratu=
lations!</p>
  <p>This first project showed you a lot: <code>let</code>, <code>match</co=
de>, methods, associated functions, using external crates, and more. Our ne=
xt project will show off even more.</p>
  <h2 id=3D"sec--dining-philosophers">Dining Philosophers</h2>
  <p>For our second project, let=E2=80=99s look at a classic concurrency pr=
oblem. It=E2=80=99s called =E2=80=98the dining philosophers=E2=80=99. It wa=
s originally conceived by Dijkstra in 1965, but we=E2=80=99ll use the versi=
on from <a href=3D"http://www.usingcsp.com/cspbook.pdf">this paper</a> by T=
ony Hoare in 1985.</p>
  <blockquote>
  <p>In ancient times, a wealthy philanthropist endowed a College to accomm=
odate five eminent philosophers. Each philosopher had a room in which he co=
uld engage in his professional activity of thinking; there was also a commo=
n dining room, furnished with a circular table, surrounded by five chairs, =
each labelled by the name of the philosopher who was to sit in it. They sat=
 anticlockwise around the table. To the left of each philosopher there was =
laid a golden fork, and in the centre stood a large bowl of spaghetti, whic=
h was constantly replenished. A philosopher was expected to spend most of h=
is time thinking; but when he felt hungry, he went to the dining room, sat =
down in his own chair, picked up his own fork on his left, and plunged it i=
nto the spaghetti. But such is the tangled nature of spaghetti that a secon=
d fork is required to carry it to the mouth. The philosopher therefore had =
also to pick up the fork on his right. When we was finished he would put do=
wn both his forks, get up from his chair, and continue thinking. Of course,=
 a fork can be used by only one philosopher at a time. If the other philoso=
pher wants it, he just has to wait until the fork is available again.</p>
  </blockquote>
  <p>This classic problem shows off a few different elements of concurrency=
. The reason is that it=E2=80=99s actually slightly tricky to implement: a =
simple implementation can deadlock. For example, let=E2=80=99s consider a s=
imple algorithm that would solve this problem:</p>
  <ol type=3D"1">
  <li>A philosopher picks up the fork on their left.</li>
  <li>They then pick up the fork on their right.</li>
  <li>They eat.</li>
  <li>They return the forks.</li>
  </ol>
  <p>Now, let=E2=80=99s imagine this sequence of events:</p>
  <ol type=3D"1">
  <li>Philosopher 1 begins the algorithm, picking up the fork on their left=
.</li>
  <li>Philosopher 2 begins the algorithm, picking up the fork on their left=
.</li>
  <li>Philosopher 3 begins the algorithm, picking up the fork on their left=
.</li>
  <li>Philosopher 4 begins the algorithm, picking up the fork on their left=
.</li>
  <li>Philosopher 5 begins the algorithm, picking up the fork on their left=
.</li>
  <li>=E2=80=A6 ? All the forks are taken, but nobody can eat!</li>
  </ol>
  <p>There are different ways to solve this problem. We=E2=80=99ll get to o=
ur solution in the tutorial itself. For now, let=E2=80=99s get started mode=
lling the problem itself. We=E2=80=99ll start with the philosophers:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Philosopher {
      name: String,
  }
 =20
  <span class=3D"kw">impl</span> Philosopher {
      <span class=3D"kw">fn</span> new(name: &amp;<span class=3D"kw">str</s=
pan>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> p1 =3D Philosopher::new(<span class=3D"=
st">"Baruch Spinoza"</span>);
      <span class=3D"kw">let</span> p2 =3D Philosopher::new(<span class=3D"=
st">"Gilles Deleuze"</span>);
      <span class=3D"kw">let</span> p3 =3D Philosopher::new(<span class=3D"=
st">"Karl Marx"</span>);
      <span class=3D"kw">let</span> p4 =3D Philosopher::new(<span class=3D"=
st">"Friedrich Nietzsche"</span>);
      <span class=3D"kw">let</span> p5 =3D Philosopher::new(<span class=3D"=
st">"Michel Foucault"</span>);
  }</code></pre></div>
  <p>Here, we make a [<code>struct</code>][struct] to represent a philosoph=
er. For now, a name is all we need. We choose the [<code>String</code>][str=
ing] type for the name, rather than <code>&amp;str</code>. Generally speaki=
ng, working with a type which owns its data is easier than working with one=
 that uses references.</p>
  <p>Let=E2=80=99s continue:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">impl</span> Philosopher {
      <span class=3D"kw">fn</span> new(name: &amp;<span class=3D"kw">str</s=
pan>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  }</code></pre></div>
  <p>This <code>impl</code> block lets us define things on <code>Philosophe=
r</code> structs. In this case, we define an =E2=80=98associated function=
=E2=80=99 called <code>new</code>. The first line looks like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> new(name: &amp;<span class=3D"=
kw">str</span>) -&gt; Philosopher {</code></pre></div>
  <p>We take one argument, a <code>name</code>, of type <code>&amp;str</cod=
e>. This is a reference to another string. It returns an instance of our <c=
ode>Philosopher</code> struct.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">Philosopher {
      name: name.to_string(),
  }</code></pre></div>
  <p>This creates a new <code>Philosopher</code>, and sets its <code>name</=
code> to our <code>name</code> argument. Not just the argument itself, thou=
gh, as we call <code>.to_string()</code> on it. This will create a copy of =
the string that our <code>&amp;str</code> points to, and give us a new <cod=
e>String</code>, which is the type of the <code>name</code> field of <code>=
Philosopher</code>.</p>
  <p>Why not accept a <code>String</code> directly? It=E2=80=99s nicer to c=
all. If we took a <code>String</code>, but our caller had a <code>&amp;str<=
/code>, they=E2=80=99d have to call this method themselves. The downside of=
 this flexibility is that we <em>always</em> make a copy. For this small pr=
ogram, that=E2=80=99s not particularly important, as we know we=E2=80=99ll =
just be using short strings anyway.</p>
  <p>One last thing you=E2=80=99ll notice: we just define a <code>Philosoph=
er</code>, and seemingly don=E2=80=99t do anything with it. Rust is an =E2=
=80=98expression based=E2=80=99 language, which means that almost everythin=
g in Rust is an expression which returns a value. This is true of functions=
 as well, the last expression is automatically returned. Since we create a =
new <code>Philosopher</code> as the last expression of this function, we en=
d up returning it.</p>
  <p>This name, <code>new()</code>, isn=E2=80=99t anything special to Rust,=
 but it is a convention for functions that create new instances of structs.=
 Before we talk about why, let=E2=80=99s look at <code>main()</code> again:=
</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> p1 =3D Philosopher::new(<span class=3D"=
st">"Baruch Spinoza"</span>);
      <span class=3D"kw">let</span> p2 =3D Philosopher::new(<span class=3D"=
st">"Gilles Deleuze"</span>);
      <span class=3D"kw">let</span> p3 =3D Philosopher::new(<span class=3D"=
st">"Karl Marx"</span>);
      <span class=3D"kw">let</span> p4 =3D Philosopher::new(<span class=3D"=
st">"Friedrich Nietzsche"</span>);
      <span class=3D"kw">let</span> p5 =3D Philosopher::new(<span class=3D"=
st">"Michel Foucault"</span>);
  }</code></pre></div>
  <p>Here, we create five variable bindings with five new philosophers. The=
se are my favorite five, but you can substitute anyone you want. If we <em>=
didn=E2=80=99t</em> define that <code>new()</code> function, it would look =
like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> p1 =3D Philosopher { name: <span class=
=3D"st">"Baruch Spinoza"</span>.to_string() };
      <span class=3D"kw">let</span> p2 =3D Philosopher { name: <span class=
=3D"st">"Gilles Deleuze"</span>.to_string() };
      <span class=3D"kw">let</span> p3 =3D Philosopher { name: <span class=
=3D"st">"Karl Marx"</span>.to_string() };
      <span class=3D"kw">let</span> p4 =3D Philosopher { name: <span class=
=3D"st">"Friedrich Nietzche"</span>.to_string() };
      <span class=3D"kw">let</span> p5 =3D Philosopher { name: <span class=
=3D"st">"Michel Foucault"</span>.to_string() };
  }</code></pre></div>
  <p>That=E2=80=99s much noisier. Using <code>new</code> has other advantag=
es too, but even in this simple case, it ends up being nicer to use.</p>
  <p>Now that we=E2=80=99ve got the basics in place, there=E2=80=99s a numb=
er of ways that we can tackle the broader problem here. I like to start fro=
m the end first: let=E2=80=99s set up a way for each philosopher to finish =
eating. As a tiny step, let=E2=80=99s make a method, and then loop through =
all the philosophers, calling it:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Philosopher {
      name: String,
  }  =20
 =20
  <span class=3D"kw">impl</span> Philosopher {=20
      <span class=3D"kw">fn</span> new(name: &amp;<span class=3D"kw">str</s=
pan>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
     =20
      <span class=3D"kw">fn</span> eat(&amp;<span class=3D"kw">self</span>)=
 {
          <span class=3D"ot">println!</span>(<span class=3D"st">"{} is done=
 eating."</span>, <span class=3D"kw">self</span>.name);
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> philosophers =3D <span class=3D"ot">vec=
!</span>[
          Philosopher::new(<span class=3D"st">"Baruch Spinoza"</span>),
          Philosopher::new(<span class=3D"st">"Gilles Deleuze"</span>),
          Philosopher::new(<span class=3D"st">"Karl Marx"</span>),
          Philosopher::new(<span class=3D"st">"Friedrich Nietzsche"</span>)=
,
          Philosopher::new(<span class=3D"st">"Michel Foucault"</span>),
      ];
 =20
      <span class=3D"kw">for</span> p in &amp;philosophers {
          p.eat();
      }
  }</code></pre></div>
  <p>Let=E2=80=99s look at <code>main()</code> first. Rather than have five=
 individual variable bindings for our philosophers, we make a <code>Vec&lt;=
T&gt;</code> of them instead. <code>Vec&lt;T&gt;</code> is also called a =
=E2=80=98vector=E2=80=99, and it=E2=80=99s a growable array type. We then u=
se a <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html=
#sec--for-loops"><code>for</code></a> loop to iterate through the vector, g=
etting a reference to each philosopher in turn.</p>
  <p>In the body of the loop, we call <code>p.eat()</code>, which is define=
d above:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> eat(&amp;<span class=3D"kw">se=
lf</span>) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{} is done eat=
ing."</span>, <span class=3D"kw">self</span>.name);
  }</code></pre></div>
  <p>In Rust, methods take an explicit <code>self</code> parameter. That=E2=
=80=99s why <code>eat()</code> is a method, but <code>new</code> is an asso=
ciated function: <code>new()</code> has no <code>self</code>. For our first=
 version of <code>eat()</code>, we just print out the name of the philosoph=
er, and mention they=E2=80=99re done eating. Running this program should gi=
ve you the following output:</p>
  <pre><code>Baruch Spinoza is done eating.
  Gilles Deleuze is done eating.
  Karl Marx is done eating.
  Friedrich Nietzsche is done eating.
  Michel Foucault is done eating.</code></pre>
  <p>Easy enough, they=E2=80=99re all done! We haven=E2=80=99t actually imp=
lemented the real problem yet, though, so we=E2=80=99re not done yet!</p>
  <p>Next, we want to make our philosophers not just finish eating, but act=
ually eat. Here=E2=80=99s the next version:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::thread;
 =20
  <span class=3D"kw">struct</span> Philosopher {
      name: String,
  }  =20
 =20
  <span class=3D"kw">impl</span> Philosopher {=20
      <span class=3D"kw">fn</span> new(name: &amp;<span class=3D"kw">str</s=
pan>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
     =20
      <span class=3D"kw">fn</span> eat(&amp;<span class=3D"kw">self</span>)=
 {
          <span class=3D"ot">println!</span>(<span class=3D"st">"{} is eati=
ng."</span>, <span class=3D"kw">self</span>.name);
 =20
          thread::sleep_ms(<span class=3D"dv">1000</span>);
 =20
          <span class=3D"ot">println!</span>(<span class=3D"st">"{} is done=
 eating."</span>, <span class=3D"kw">self</span>.name);
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> philosophers =3D <span class=3D"ot">vec=
!</span>[
          Philosopher::new(<span class=3D"st">"Baruch Spinoza"</span>),
          Philosopher::new(<span class=3D"st">"Gilles Deleuze"</span>),
          Philosopher::new(<span class=3D"st">"Karl Marx"</span>),
          Philosopher::new(<span class=3D"st">"Friedrich Nietzsche"</span>)=
,
          Philosopher::new(<span class=3D"st">"Michel Foucault"</span>),
      ];
 =20
      <span class=3D"kw">for</span> p in &amp;philosophers {
          p.eat();
      }
  }</code></pre></div>
  <p>Just a few changes. Let=E2=80=99s break it down.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::thread;</code></pre></di=
v>
  <p><code>use</code> brings names into scope. We=E2=80=99re going to start=
 using the <code>thread</code> module from the standard library, and so we =
need to <code>use</code> it.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    <span class=3D"kw">fn</span> eat(&amp;<span class=3D"kw=
">self</span>) {
          <span class=3D"ot">println!</span>(<span class=3D"st">"{} is eati=
ng."</span>, <span class=3D"kw">self</span>.name);
 =20
          thread::sleep_ms(<span class=3D"dv">1000</span>);
 =20
          <span class=3D"ot">println!</span>(<span class=3D"st">"{} is done=
 eating."</span>, <span class=3D"kw">self</span>.name);
      }</code></pre></div>
  <p>We now print out two messages, with a <code>sleep_ms()</code> in the m=
iddle. This will simulate the time it takes a philosopher to eat.</p>
  <p>If you run this program, You should see each philosopher eat in turn:<=
/p>
  <pre><code>Baruch Spinoza is eating.
  Baruch Spinoza is done eating.
  Gilles Deleuze is eating.
  Gilles Deleuze is done eating.
  Karl Marx is eating.
  Karl Marx is done eating.
  Friedrich Nietzsche is eating.
  Friedrich Nietzsche is done eating.
  Michel Foucault is eating.
  Michel Foucault is done eating.</code></pre>
  <p>Excellent! We=E2=80=99re getting there. There=E2=80=99s just one probl=
em: we aren=E2=80=99t actually operating in a concurrent fashion, which is =
a core part of the problem!</p>
  <p>To make our philosophers eat concurrently, we need to make a small cha=
nge. Here=E2=80=99s the next iteration:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::thread;
 =20
  <span class=3D"kw">struct</span> Philosopher {
      name: String,
  }  =20
 =20
  <span class=3D"kw">impl</span> Philosopher {=20
      <span class=3D"kw">fn</span> new(name: &amp;<span class=3D"kw">str</s=
pan>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
 =20
      <span class=3D"kw">fn</span> eat(&amp;<span class=3D"kw">self</span>)=
 {
          <span class=3D"ot">println!</span>(<span class=3D"st">"{} is eati=
ng."</span>, <span class=3D"kw">self</span>.name);
 =20
          thread::sleep_ms(<span class=3D"dv">1000</span>);
 =20
          <span class=3D"ot">println!</span>(<span class=3D"st">"{} is done=
 eating."</span>, <span class=3D"kw">self</span>.name);
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> philosophers =3D <span class=3D"ot">vec=
!</span>[
          Philosopher::new(<span class=3D"st">"Baruch Spinoza"</span>),
          Philosopher::new(<span class=3D"st">"Gilles Deleuze"</span>),
          Philosopher::new(<span class=3D"st">"Karl Marx"</span>),
          Philosopher::new(<span class=3D"st">"Friedrich Nietzsche"</span>)=
,
          Philosopher::new(<span class=3D"st">"Michel Foucault"</span>),
      ];
 =20
      <span class=3D"kw">let</span> handles: Vec&lt;_&gt; =3D philosophers.=
into_iter().map(|p| {
          thread::spawn(move || {
              p.eat();
          })
      }).collect();
 =20
      <span class=3D"kw">for</span> h in handles {
          h.join().unwrap();
      }
  }</code></pre></div>
  <p>All we=E2=80=99ve done is change the loop in <code>main()</code>, and =
added a second one! Here=E2=80=99s the first change:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> handles: Vec&lt;_&gt; =3D phi=
losophers.into_iter().map(|p| {
      thread::spawn(move || {
          p.eat();
      })
  }).collect();</code></pre></div>
  <p>While this is only five lines, they=E2=80=99re a dense four. Let=E2=80=
=99s break it down.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> handles: Vec&lt;_&gt; =3D </c=
ode></pre></div>
  <p>We introduce a new binding, called <code>handles</code>. We=E2=80=99ve=
 given it this name because we are going to make some new threads, and that=
 will return some handles to those threads that let us control their operat=
ion. We need to explicitly annotate the type here, though, due to an issue =
we=E2=80=99ll talk about later. The <code>_</code> is a type placeholder. W=
e=E2=80=99re saying =E2=80=9C<code>handles</code> is a vector of something,=
 but you can figure out what that something is, Rust.=E2=80=9D</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">philosophers.into_iter().map(|p| {</code></pre></div>
  <p>We take our list of philosophers and call <code>into_iter()</code> on =
it. This creates an iterator that takes ownership of each philosopher. We n=
eed to do this to pass them to our threads. We take that iterator and call =
<code>map</code> on it, which takes a closure as an argument and calls that=
 closure on each element in turn.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    thread::spawn(move || {
          p.eat();
      })</code></pre></div>
  <p>Here=E2=80=99s where the concurrency happens. The <code>thread::spawn<=
/code> function takes a closure as an argument and executes that closure in=
 a new thread. This closure needs an extra annotation, <code>move</code>, t=
o indicate that the closure is going to take ownership of the values it=E2=
=80=99s capturing. Primarily, the <code>p</code> variable of the <code>map<=
/code> function.</p>
  <p>Inside the thread, all we do is call <code>eat()</code> on <code>p</co=
de>.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">}).collect();</code></pre></div>
  <p>Finally, we take the result of all those <code>map</code> calls and co=
llect them up. <code>collect()</code> will make them into a collection of s=
ome kind, which is why we needed to annotate the return type: we want a <co=
de>Vec&lt;T&gt;</code>. The elements are the return values of the <code>thr=
ead::spawn</code> calls, which are handles to those threads. Whew!</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">for</span> h in handles {
      h.join().unwrap();
  }</code></pre></div>
  <p>At the end of <code>main()</code>, we loop through the handles and cal=
l <code>join()</code> on them, which blocks execution until the thread has =
completed execution. This ensures that the threads complete their work befo=
re the program exits.</p>
  <p>If you run this program, you=E2=80=99ll see that the philosophers eat =
out of order! We have mult-threading!</p>
  <pre><code>Gilles Deleuze is eating.
  Gilles Deleuze is done eating.
  Friedrich Nietzsche is eating.
  Friedrich Nietzsche is done eating.
  Michel Foucault is eating.
  Baruch Spinoza is eating.
  Baruch Spinoza is done eating.
  Karl Marx is eating.
  Karl Marx is done eating.
  Michel Foucault is done eating.</code></pre>
  <p>But what about the forks? We haven=E2=80=99t modeled them at all yet.<=
/p>
  <p>To do that, let=E2=80=99s make a new <code>struct</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::sync::Mutex;
 =20
  <span class=3D"kw">struct</span> Table {
      forks: Vec&lt;Mutex&lt;()&gt;&gt;,
  }</code></pre></div>
  <p>This <code>Table</code> has an vector of <code>Mutex</code>es. A mutex=
 is a way to control concurrency: only one thread can access the contents a=
t once. This is exactly the property we need with our forks. We use an empt=
y tuple, <code>()</code>, inside the mutex, since we=E2=80=99re not actuall=
y going to use the value, just hold onto it.</p>
  <p>Let=E2=80=99s modify the program to use the <code>Table</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::thread;
  <span class=3D"kw">use</span> std::sync::{Mutex, Arc};
 =20
  <span class=3D"kw">struct</span> Philosopher {
      name: String,
      left: usize,
      right: usize,
  }
 =20
  <span class=3D"kw">impl</span> Philosopher {
      <span class=3D"kw">fn</span> new(name: &amp;<span class=3D"kw">str</s=
pan>, left: usize, right: usize) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
              left: left,
              right: right,
          }
      }
 =20
      <span class=3D"kw">fn</span> eat(&amp;<span class=3D"kw">self</span>,=
 table: &amp;Table) {
          <span class=3D"kw">let</span> _left =3D table.forks[<span class=
=3D"kw">self</span>.left].lock().unwrap();
          <span class=3D"kw">let</span> _right =3D table.forks[<span class=
=3D"kw">self</span>.right].lock().unwrap();
 =20
          <span class=3D"ot">println!</span>(<span class=3D"st">"{} is eati=
ng."</span>, <span class=3D"kw">self</span>.name);
 =20
          thread::sleep_ms(<span class=3D"dv">1000</span>);
 =20
          <span class=3D"ot">println!</span>(<span class=3D"st">"{} is done=
 eating."</span>, <span class=3D"kw">self</span>.name);
      }
  }
 =20
  <span class=3D"kw">struct</span> Table {
      forks: Vec&lt;Mutex&lt;()&gt;&gt;,
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> table =3D Arc::new(Table { forks: <span=
 class=3D"ot">vec!</span>[
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
      ]});
 =20
      <span class=3D"kw">let</span> philosophers =3D <span class=3D"ot">vec=
!</span>[
          Philosopher::new(<span class=3D"st">"Baruch Spinoza"</span>, <spa=
n class=3D"dv">0</span>, <span class=3D"dv">1</span>),
          Philosopher::new(<span class=3D"st">"Gilles Deleuze"</span>, <spa=
n class=3D"dv">1</span>, <span class=3D"dv">2</span>),
          Philosopher::new(<span class=3D"st">"Karl Marx"</span>, <span cla=
ss=3D"dv">2</span>, <span class=3D"dv">3</span>),
          Philosopher::new(<span class=3D"st">"Friedrich Nietzsche"</span>,=
 <span class=3D"dv">3</span>, <span class=3D"dv">4</span>),
          Philosopher::new(<span class=3D"st">"Michel Foucault"</span>, <sp=
an class=3D"dv">0</span>, <span class=3D"dv">4</span>),
      ];
 =20
      <span class=3D"kw">let</span> handles: Vec&lt;_&gt; =3D philosophers.=
into_iter().map(|p| {
          <span class=3D"kw">let</span> table =3D table.clone();
 =20
          thread::spawn(move || {
              p.eat(&amp;table);
          })
      }).collect();
 =20
      <span class=3D"kw">for</span> h in handles {
          h.join().unwrap();
      }
  }</code></pre></div>
  <p>Lots of changes! However, with this iteration, we=E2=80=99ve got a wor=
king program. Let=E2=80=99s go over the details:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::sync::{Mutex, Arc};</cod=
e></pre></div>
  <p>We=E2=80=99re going to use another structure from the <code>std::sync<=
/code> package: <code>Arc&lt;T&gt;</code>. We=E2=80=99ll talk more about it=
 when we use it.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Philosopher {
      name: String,
      left: usize,
      right: usize,
  }</code></pre></div>
  <p>We need to add two more fields to our <code>Philosopher</code>. Each p=
hilosopher is going to have two forks: the one on their left, and the one o=
n their right. We=E2=80=99ll use the <code>usize</code> type to indicate th=
em, as it=E2=80=99s the type that you index vectors with. These two values =
will be the indexes into the <code>forks</code> our <code>Table</code> has.=
</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> new(name: &amp;<span class=3D"=
kw">str</span>, left: usize, right: usize) -&gt; Philosopher {
      Philosopher {
          name: name.to_string(),
          left: left,
          right: right,
      }
  }</code></pre></div>
  <p>We now need to construct those <code>left</code> and <code>right</code=
> values, so we add them to <code>new()</code>.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> eat(&amp;<span class=3D"kw">se=
lf</span>, table: &amp;Table) {
      <span class=3D"kw">let</span> _left =3D table.forks[<span class=3D"kw=
">self</span>.left].lock().unwrap();
      <span class=3D"kw">let</span> _right =3D table.forks[<span class=3D"k=
w">self</span>.right].lock().unwrap();
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"{} is eating."=
</span>, <span class=3D"kw">self</span>.name);
 =20
      thread::sleep_ms(<span class=3D"dv">1000</span>);
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"{} is done eat=
ing."</span>, <span class=3D"kw">self</span>.name);
  }</code></pre></div>
  <p>We have two new lines. We=E2=80=99ve also added an argument, <code>tab=
le</code>. We access the <code>Table</code>=E2=80=99s list of forks, and th=
en use <code>self.left</code> and <code>self.right</code> to access the for=
k at that particular index. That gives us access to the <code>Mutex</code> =
at that index, and we call <code>lock()</code> on it. If the mutex is curre=
ntly being accessed by someone else, we=E2=80=99ll block until it becomes a=
vailable.</p>
  <p>The call to <code>lock()</code> might fail, and if it does, we want to=
 crash. In this case, the error that could happen is that the mutex is <a h=
ref=3D"http://doc.rust-lang.org/std/sync/struct.Mutex.html#poisoning">=E2=
=80=98poisoned=E2=80=99</a>, which is what happens when the thread panics w=
hile the lock is held. Since this shouldn=E2=80=99t happen, we just use <co=
de>unwrap()</code>.</p>
  <p>One other odd thing about these lines: we=E2=80=99ve named the results=
 <code>_left</code> and <code>_right</code>. What=E2=80=99s up with that un=
derscore? Well, we aren=E2=80=99t planning on <em>using</em> the value insi=
de the lock. We just want to acquire it. As such, Rust will warn us that we=
 never use the value. By using the underscore, we tell Rust that this is wh=
at we intended, and it won=E2=80=99t throw a warning.</p>
  <p>What about releasing the lock? Well, that will happen when <code>_left=
</code> and <code>_right</code> go out of scope, automatically.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    <span class=3D"kw">let</span> table =3D Arc::new(Table =
{ forks: <span class=3D"ot">vec!</span>[
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
      ]});</code></pre></div>
  <p>Next, in <code>main()</code>, we make a new <code>Table</code> and wra=
p it in an <code>Arc&lt;T&gt;</code>. =E2=80=98arc=E2=80=99 stands for =E2=
=80=98atomic reference count=E2=80=99, and we need that to share our <code>=
Table</code> across multiple threads. As we share it, the reference count w=
ill go up, and when each thread ends, it will go back down.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> philosophers =3D <span class=
=3D"ot">vec!</span>[
      Philosopher::new(<span class=3D"st">"Baruch Spinoza"</span>, <span cl=
ass=3D"dv">0</span>, <span class=3D"dv">1</span>),
      Philosopher::new(<span class=3D"st">"Gilles Deleuze"</span>, <span cl=
ass=3D"dv">1</span>, <span class=3D"dv">2</span>),
      Philosopher::new(<span class=3D"st">"Karl Marx"</span>, <span class=
=3D"dv">2</span>, <span class=3D"dv">3</span>),
      Philosopher::new(<span class=3D"st">"Friedrich Nietzsche"</span>, <sp=
an class=3D"dv">3</span>, <span class=3D"dv">4</span>),
      Philosopher::new(<span class=3D"st">"Michel Foucault"</span>, <span c=
lass=3D"dv">0</span>, <span class=3D"dv">4</span>),
  ];</code></pre></div>
  <p>We need to pass in our <code>left</code> and <code>right</code> values=
 to the constructors for our <code>Philosopher</code>s. But there=E2=80=99s=
 one more detail here, and it=E2=80=99s <em>very</em> important. If you loo=
k at the pattern, it=E2=80=99s all consistent until the very end. Monsieur =
Foucault should have <code>4, 0</code> as arguments, but instead, has <code=
>0, 4</code>. This is what prevents deadlock, actually: one of our philosop=
hers is left handed! This is one way to solve the problem, and in my opinio=
n, it=E2=80=99s the simplest.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> handles: Vec&lt;_&gt; =3D phi=
losophers.into_iter().map(|p| {
      <span class=3D"kw">let</span> table =3D table.clone();
 =20
      thread::spawn(move || {
          p.eat(&amp;table);
      })
  }).collect();</code></pre></div>
  <p>Finally, inside of our <code>map()</code>/<code>collect()</code> loop,=
 we call <code>table.clone()</code>. The <code>clone()</code> method on <co=
de>Arc&lt;T&gt;</code> is what bumps up the reference count, and when it go=
es out of scope, it decrements the count. You=E2=80=99ll notice we can intr=
oduce a new binding to <code>table</code> here, and it will shadow the old =
one. This is often used so that you don=E2=80=99t need to come up with two =
unique names.</p>
  <p>With this, our program works! Only two philosophers can eat at any one=
 time, and so you=E2=80=99ll get some output like this:</p>
  <pre><code>Gilles Deleuze is eating.
  Friedrich Nietzsche is eating.
  Friedrich Nietzsche is done eating.
  Gilles Deleuze is done eating.
  Baruch Spinoza is eating.
  Karl Marx is eating.
  Baruch Spinoza is done eating.
  Michel Foucault is eating.
  Karl Marx is done eating.
  Michel Foucault is done eating.</code></pre>
  <p>Congrats! You=E2=80=99ve implemented a classic concurrency problem in =
Rust.</p>
  <h2 id=3D"sec--rust-inside-other-languages">Rust inside other languages</=
h2>
  <p>For our third project, we=E2=80=99re going to choose something that sh=
ows off one of Rust=E2=80=99s greatest strengths: a lack of a substantial r=
untime.</p>
  <p>As organizations grow, they increasingly rely on a multitude of progra=
mming languages. Different programming languages have different strengths a=
nd weaknesses, and a polyglot stack lets you use a particular language wher=
e its strengths make sense, and use a different language where it=E2=80=99s=
 weak.</p>
  <p>A very common area where many programming languages are weak is in run=
time performance of programs. Often, using a language that is slower, but o=
ffers greater programmer productivity is a worthwhile trade-off. To help mi=
tigate this, they provide a way to write some of your system in C, and then=
 call the C code as though it were written in the higher-level language. Th=
is is called a =E2=80=98foreign function interface=E2=80=99, often shortene=
d to =E2=80=98FFI=E2=80=99.</p>
  <p>Rust has support for FFI in both directions: it can call into C code e=
asily, but crucially, it can also be called <em>into</em> as easily as C. C=
ombined with Rust=E2=80=99s lack of a garbage collector and low runtime req=
uirements, this makes Rust a great candidate to embed inside of other langu=
ages when you need some extra oomph.</p>
  <p>There is a whole <a href=3D"https://killercup.github.io/trpl-ebook/trp=
l-2015-05-13.html#sec--ffi">chapter devoted to FFI</a> and its specifics el=
sewhere in the book, but in this chapter, we=E2=80=99ll examine this partic=
ular use-case of FFI, with three examples, in Ruby, Python, and JavaScript.=
</p>
  <h3 id=3D"the-problem">The problem</h3>
  <p>There are many different projects we could choose here, but we=E2=80=
=99re going to pick an example where Rust has a clear advantage over many o=
ther languages: numeric computing and threading.</p>
  <p>Many languages, for the sake of consistency, place numbers on the heap=
, rather than on the stack. Especially in languages that focus on object-or=
iented programming and use garbage collection, heap allocation is the defau=
lt. Sometimes optimizations can stack allocate particular numbers, but rath=
er than relying on an optimizer to do its job, we may want to ensure that w=
e=E2=80=99re always using primitive number types rather than some sort of o=
bject type.</p>
  <p>Second, many languages have a =E2=80=98global interpreter lock=E2=80=
=99, which limits concurrency in many situations. This is done in the name =
of safety, which is a positive effect, but it limits the amount of work tha=
t can be done at the same time, which is a big negative.</p>
  <p>To emphasize these two aspects, we=E2=80=99re going to create a little=
 project that uses these two aspects heavily. Since the focus of the exampl=
e is the embedding of Rust into the languages, rather than the problem itse=
lf, we=E2=80=99ll just use a toy example:</p>
  <blockquote>
  <p>Start ten threads. Inside each thread, count from one to five million.=
 After All ten threads are finished, print out =E2=80=98done!=E2=80=99.</p>
  </blockquote>
  <p>I chose five million based on my particular computer. Here=E2=80=99s a=
n example of this code in Ruby:</p>
  <pre><code>threads =3D []
 =20
  10.times do
    threads &lt;&lt; Thread.new do
      count =3D 0
 =20
      5_000_000.times do
        count +=3D 1
      end
    end
  end
 =20
  threads.each {|t| t.join }
  puts "done!"</code></pre>
  <p>Try running this example, and choose a number that runs for a few seco=
nds. Depending on your computer=E2=80=99s hardware, you may have to increas=
e or decrease the number.</p>
  <p>On my system, running this program takes <code>2.156</code> seconds. A=
nd, if I use some sort of process monitoring tool, like <code>top</code>, I=
 can see that it only uses one core on my machine. That=E2=80=99s the GIL k=
icking in.</p>
  <p>While it=E2=80=99s true that this is a synthetic program, one can imag=
ine many problems that are similar to this in the real world. For our purpo=
ses, spinning up some busy threads represents some sort of parallel, expens=
ive computation.</p>
  <h3 id=3D"a-rust-library">A Rust library</h3>
  <p>Let=E2=80=99s re-write this problem in Rust. First, let=E2=80=99s make=
 a new project with Cargo:</p>
  <pre><code>$ cargo new embed
  $ cd embed</code></pre>
  <p>This program is fairly easy to write in Rust:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::thread;
 =20
  <span class=3D"kw">fn</span> process() {
      <span class=3D"kw">let</span> handles: Vec&lt;_&gt; =3D (<span class=
=3D"dv">0.</span>.<span class=3D"dv">10</span>).map(|_| {
          thread::spawn(|| {
              <span class=3D"kw">let</span> <span class=3D"kw">mut</span> _=
x =3D <span class=3D"dv">0</span>;
              <span class=3D"kw">for</span> _ in (<span class=3D"dv">0.</sp=
an>.<span class=3D"dv">5_000_001</span>) {
                  _x +=3D <span class=3D"dv">1</span>
              }
          })
      }).collect();
 =20
      <span class=3D"kw">for</span> h in handles {
          h.join().ok().expect(<span class=3D"st">"Could not join a thread!=
"</span>);
      }
  }</code></pre></div>
  <p>Some of this should look familiar from previous examples. We spin up t=
en threads, collecting them into a <code>handles</code> vector. Inside of e=
ach thread, we loop five million times, and add one to <code>_x</code> each=
 time. Why the underscore? Well, if we remove it and compile:</p>
  <pre><code>$ cargo build
     Compiling embed v0.1.0 (file:///home/steve/src/embed)
  src/lib.rs:3:1: 16:2 warning: function is never used: `process`, #[warn(d=
ead_code)] on by default
  src/lib.rs:3 fn process() {
  src/lib.rs:4     let handles: Vec&lt;_&gt; =3D (0..10).map(|_| {
  src/lib.rs:5         thread::spawn(|| {
  src/lib.rs:6             let mut x =3D 0;
  src/lib.rs:7             for _ in (0..5_000_001) {
  src/lib.rs:8                 x +=3D 1
               ...
  src/lib.rs:6:17: 6:22 warning: variable `x` is assigned to, but never use=
d, #[warn(unused_variables)] on by default
  src/lib.rs:6             let mut x =3D 0;
                               ^~~~~</code></pre>
  <p>That first warning is because we are building a library. If we had a t=
est for this function, the warning would go away. But for now, it=E2=80=99s=
 never called.</p>
  <p>The second is related to <code>x</code> versus <code>_x</code>. Becaus=
e we never actually <em>do</em> anything with <code>x</code>, we get a warn=
ing about it. In our case, that=E2=80=99s perfectly okay, as we=E2=80=99re =
just trying to waste CPU cycles. Prefixing <code>x</code> with the undersco=
re removes the warning.</p>
  <p>Finally, we join on each thread.</p>
  <p>Right now, however, this is a Rust library, and it doesn=E2=80=99t exp=
ose anything that=E2=80=99s callable from C. If we tried to hook this up to=
 another language right now, it wouldn=E2=80=99t work. We only need to make=
 two small changes to fix this, though. The first is modify the beginning o=
f our code:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>no_mangle<span class=3D"ot">]</=
span>
  <span class=3D"kw">pub</span> <span class=3D"kw">extern</span> <span clas=
s=3D"kw">fn</span> process() {</code></pre></div>
  <p>We have to add a new attribute, <code>no_mangle</code>. When you creat=
e a Rust library, it changes the name of the function in the compiled outpu=
t. The reasons for this are outside the scope of this tutorial, but in orde=
r for other languages to know how to call the function, we need to not do t=
hat. This attribute turns that behavior off.</p>
  <p>The other change is the <code>pub extern</code>. The <code>pub</code> =
means that this function should be callable from outside of this module, an=
d the <code>extern</code> says that it should be able to be called from C. =
That=E2=80=99s it! Not a whole lot of change.</p>
  <p>The second thing we need to do is to change a setting in our <code>Car=
go.toml</code>. Add this at the bottom:</p>
  <pre><code>[lib]
  name =3D "embed"
  crate-type =3D ["dylib"]</code></pre>
  <p>This tells Rust that we want to compile our library into a standard dy=
namic library. By default, Rust compiles into an =E2=80=98rlib=E2=80=99, a =
Rust-specific format.</p>
  <p>Let=E2=80=99s build the project now:</p>
  <pre><code>$ cargo build --release
     Compiling embed v0.1.0 (file:///home/steve/src/embed)</code></pre>
  <p>We=E2=80=99ve chosen <code>cargo build --release</code>, which builds =
with optimizations on. We want this to be as fast as possible! You can find=
 the output of the library in <code>target/release</code>:</p>
  <pre><code>$ ls target/release/
  build  deps  examples  libembed.so  native</code></pre>
  <p>That <code>libembed.so</code> is our =E2=80=98shared object=E2=80=99 l=
ibrary. We can use this file just like any shared object library written in=
 C! As an aside, this may be <code>embed.dll</code> or <code>libembed.dylib=
</code>, depending on the platform.</p>
  <p>Now that we=E2=80=99ve got our Rust library built, let=E2=80=99s use i=
t from our Ruby.</p>
  <h3 id=3D"ruby">Ruby</h3>
  <p>Open up a <code>embed.rb</code> file inside of our project, and do thi=
s:</p>
  <pre><code>require 'ffi'
 =20
  module Hello
    extend FFI::Library
    ffi_lib 'target/release/libembed.so'
    attach_function :process, [], :void
  end
 =20
  Hello.process
 =20
  puts "done!=E2=80=9D</code></pre>
  <p>Before we can run this, we need to install the <code>ffi</code> gem:</=
p>
  <pre><code>$ gem install ffi # this may need sudo
  Fetching: ffi-1.9.8.gem (100%)
  Building native extensions.  This could take a while...
  Successfully installed ffi-1.9.8
  Parsing documentation for ffi-1.9.8
  Installing ri documentation for ffi-1.9.8
  Done installing documentation for ffi after 0 seconds
  1 gem installed</code></pre>
  <p>And finally, we can try running it:</p>
  <pre><code>$ ruby embed.rb
  done!
  $</code></pre>
  <p>Whoah, that was fast! On my system, this took <code>0.086</code> secon=
ds, rather than the two seconds the pure Ruby version took. Let=E2=80=99s b=
reak down this Ruby code:</p>
  <pre><code>require 'ffi'</code></pre>
  <p>We first need to require the <code>ffi</code> gem. This lets us interf=
ace with our Rust library like a C library.</p>
  <pre><code>module Hello
    extend FFI::Library
    ffi_lib 'target/release/libembed.so'</code></pre>
  <p>The <code>ffi</code> gem=E2=80=99s authors recommend using a module to=
 scope the functions we=E2=80=99ll import from the shared library. Inside, =
we <code>extend</code> the necessary <code>FFI::Library</code> module, and =
then call <code>ffi_lib</code> to load up our shared object library. We jus=
t pass it the path that our library is stored, which as we saw before, is <=
code>target/release/libembed.so</code>.</p>
  <pre><code>attach_function :process, [], :void</code></pre>
  <p>The <code>attach_function</code> method is provided by the FFI gem. It=
=E2=80=99s what connects our <code>process()</code> function in Rust to a R=
uby function of the same name. Since <code>process()</code> takes no argume=
nts, the second parameter is an empty array, and since it returns nothing, =
we pass <code>:void</code> as the final argument.</p>
  <pre><code>Hello.process</code></pre>
  <p>This is the actual call into Rust. The combination of our <code>module=
</code> and the call to <code>attach_function</code> sets this all up. It l=
ooks like a Ruby function, but is actually Rust!</p>
  <pre><code>puts "done!"</code></pre>
  <p>Finally, as per our project=E2=80=99s requirements, we print out <code=
>done!</code>.</p>
  <p>That=E2=80=99s it! As we=E2=80=99ve seen, bridging between the two lan=
guages is really easy, and buys us a lot of performance.</p>
  <p>Next, let=E2=80=99s try Python!</p>
  <h3 id=3D"python">Python</h3>
  <p>Create an <code>embed.py</code> file in this directory, and put this i=
n it:</p>
  <pre><code>from ctypes import cdll
 =20
  lib =3D cdll.LoadLibrary("target/release/libembed.so")
 =20
  lib.process()
 =20
  print("done!")</code></pre>
  <p>Even easier! We use <code>cdll</code> from the <code>ctypes</code> mod=
ule. A quick call to <code>LoadLibrary</code> later, and we can call <code>=
process()</code>.</p>
  <p>On my system, this takes <code>0.017</code> seconds. Speedy!</p>
  <h3 id=3D"node.js">Node.js</h3>
  <p>Node isn=E2=80=99t a language, but it=E2=80=99s currently the dominant=
 implementation of server-side JavaScript.</p>
  <p>In order to do FFI with Node, we first need to install the library:</p=
>
  <pre><code>$ npm install ffi</code></pre>
  <p>After that installs, we can use it:</p>
  <pre><code>var ffi =3D require('ffi');
 =20
  var lib =3D ffi.Library('target/release/libembed', {
    'process': [ 'void', []  ]
  });
 =20
  lib.process();
 =20
  console.log("done!");</code></pre>
  <p>It looks more like the Ruby example than the Python example. We use th=
e <code>ffi</code> module to get access to <code>ffi.Library()</code>, whic=
h loads up our shared object. We need to annotate the return type and argum=
ent types of the function, which are =E2=80=98void=E2=80=99 for return, and=
 an empty array to signify no arguments. From there, we just call it and pr=
int the result.</p>
  <p>On my system, this takes a quick <code>0.092</code> seconds.</p>
  <h3 id=3D"conclusion">Conclusion</h3>
  <p>As you can see, the basics of doing this are <em>very</em> easy. Of co=
urse, there=E2=80=99s a lot more that we could do here. Check out the <a hr=
ef=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--ffi"=
>FFI</a> chapter for more details.</p>
  <h1 id=3D"sec--effective-rust">Effective Rust</h1>
  <p>So you=E2=80=99ve learned how to write some Rust code. But there=E2=80=
=99s a difference between writing <em>any</em> Rust code and writing <em>go=
od</em> Rust code.</p>
  <p>This section consists of relatively independent tutorials which show y=
ou how to take your Rust to the next level. Common patterns and standard li=
brary features will be introduced. Read these sections in any order of your=
 choosing.</p>
  <h2 id=3D"sec--the-stack-and-the-heap">The Stack and the Heap</h2>
  <p>As a systems language, Rust operates at a low level. If you=E2=80=99re=
 coming from a high-level language, there are some aspects of systems progr=
amming that you may not be familiar with. The most important one is how mem=
ory works, with a stack and a heap. If you=E2=80=99re familiar with how C-l=
ike languages use stack allocation, this chapter will be a refresher. If yo=
u=E2=80=99re not, you=E2=80=99ll learn about this more general concept, but=
 with a Rust-y focus.</p>
  <h3 id=3D"memory-management">Memory management</h3>
  <p>These two terms are about memory management. The stack and the heap ar=
e abstractions that help you determine when to allocate and deallocate memo=
ry.</p>
  <p>Here=E2=80=99s a high-level comparison:</p>
  <p>The stack is very fast, and is where memory is allocated in Rust by de=
fault. But the allocation is local to a function call, and is limited in si=
ze. The heap, on the other hand, is slower, and is explicitly allocated by =
your program. But it=E2=80=99s effectively unlimited in size, and is global=
ly accessible.</p>
  <h3 id=3D"the-stack">The Stack</h3>
  <p>Let=E2=80=99s talk about this Rust program:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">42</span>;
  }</code></pre></div>
  <p>This program has one variable binding, <code>x</code>. This memory nee=
ds to be allocated from somewhere. Rust =E2=80=98stack allocates=E2=80=99 b=
y default, which means that basic values =E2=80=98go on the stack=E2=80=99.=
 What does that mean?</p>
  <p>Well, when a function gets called, some memory gets allocated for all =
of its local variables and some other information. This is called a =E2=80=
=98stack frame=E2=80=99, and for the purpose of this tutorial, we=E2=80=99r=
e going to ignore the extra information and just consider the local variabl=
es we=E2=80=99re allocating. So in this case, when <code>main()</code> is r=
un, we=E2=80=99ll allocate a single 32-bit integer for our stack frame. Thi=
s is automatically handled for you, as you can see, we didn=E2=80=99t have =
to write any special Rust code or anything.</p>
  <p>When the function is over, its stack frame gets deallocated. This happ=
ens automatically, we didn=E2=80=99t have to do anything special here.</p>
  <p>That=E2=80=99s all there is for this simple program. The key thing to =
understand here is that stack allocation is very, very fast. Since we know =
all the local variables we have ahead of time, we can grab the memory all a=
t once. And since we=E2=80=99ll throw them all away at the same time as wel=
l, we can get rid of it very fast too.</p>
  <p>The downside is that we can=E2=80=99t keep values around if we need th=
em for longer than a single function. We also haven=E2=80=99t talked about =
what that name, =E2=80=98stack=E2=80=99 means. To do that, we need a slight=
ly more complicated example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo() {
      <span class=3D"kw">let</span> y =3D <span class=3D"dv">5</span>;
      <span class=3D"kw">let</span> z =3D <span class=3D"dv">100</span>;
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">42</span>;
 =20
      foo();
  }</code></pre></div>
  <p>This program has three variables total: two in <code>foo()</code>, one=
 in <code>main()</code>. Just as before, when <code>main()</code> is called=
, a single integer is allocated for its stack frame. But before we can show=
 what happens when <code>foo()</code> is called, we need to visualize what=
=E2=80=99s going on with memory. Your operating system presents a view of m=
emory to your program that=E2=80=99s pretty simple: a huge list of addresse=
s, from 0 to a large number, representing how much RAM your computer has. F=
or example, if you have a gigabyte of RAM, your addresses go from <code>0</=
code> to <code>1,073,741,824</code>. That number comes from 2<sup>30</sup>,=
 the number of bytes in a gigabyte.</p>
  <p>This memory is kind of like a giant array: addresses start at zero and=
 go up to the final number. So here=E2=80=99s a diagram of our first stack =
frame:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>We=E2=80=99ve got <code>x</code> located at address <code>0</code>, wi=
th the value <code>42</code>.</p>
  <p>When <code>foo()</code> is called, a new stack frame is allocated:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">z</td>
  <td style=3D"text-align: left;">100</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Because <code>0</code> was taken by the first frame, <code>1</code> an=
d <code>2</code> are used for <code>foo()</code>=E2=80=99s stack frame. It =
grows upward, the more functions we call.</p>
  <p>There=E2=80=99s some important things we have to take note of here. Th=
e numbers 0, 1, and 2 are all solely for illustrative purposes, and bear no=
 relationship to the actual numbers the computer will actually use. In part=
icular, the series of addresses are in reality going to be separated by som=
e number of bytes that separate each address, and that separation may even =
exceed the size of the value being stored.</p>
  <p>After <code>foo()</code> is over, its frame is deallocated:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then, after <code>main()</code>, even this last value goes away. E=
asy!</p>
  <p>It=E2=80=99s called a =E2=80=98stack=E2=80=99 because it works like a =
stack of dinner plates: the first plate you put down is the last plate to p=
ick back up. Stacks are sometimes called =E2=80=98last in, first out queues=
=E2=80=99 for this reason, as the last value you put on the stack is the fi=
rst one you retrieve from it.</p>
  <p>Let=E2=80=99s try a three-deep example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> bar() {
      <span class=3D"kw">let</span> i =3D <span class=3D"dv">6</span>;
  }
 =20
  <span class=3D"kw">fn</span> foo() {
      <span class=3D"kw">let</span> a =3D <span class=3D"dv">5</span>;
      <span class=3D"kw">let</span> b =3D <span class=3D"dv">100</span>;
      <span class=3D"kw">let</span> c =3D <span class=3D"dv">1</span>;
 =20
      bar();
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">42</span>;
 =20
      foo();
  }</code></pre></div>
  <p>Okay, first, we call <code>main()</code>:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Next up, <code>main()</code> calls <code>foo()</code>:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">c</td>
  <td style=3D"text-align: left;">1</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">b</td>
  <td style=3D"text-align: left;">100</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">a</td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then <code>foo()</code> calls <code>bar()</code>:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">4</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">6</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">c</td>
  <td style=3D"text-align: left;">1</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">b</td>
  <td style=3D"text-align: left;">100</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">a</td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Whew! Our stack is growing tall.</p>
  <p>After <code>bar()</code> is over, its frame is deallocated, leaving ju=
st <code>foo()</code> and <code>main()</code>:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">c</td>
  <td style=3D"text-align: left;">1</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">b</td>
  <td style=3D"text-align: left;">100</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">a</td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then <code>foo()</code> ends, leaving just <code>main()</code></p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then we=E2=80=99re done. Getting the hang of it? It=E2=80=99s like=
 piling up dishes: you add to the top, you take away from the top.</p>
  <h3 id=3D"the-heap">The Heap</h3>
  <p>Now, this works pretty well, but not everything can work like this. So=
metimes, you need to pass some memory between different functions, or keep =
it alive for longer than a single function=E2=80=99s execution. For this, w=
e can use the heap.</p>
  <p>In Rust, you can allocate memory on the heap with the <a href=3D"http:=
//doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code> type</a=
>. Here=E2=80=99s an example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D Box::new(<span class=3D"dv">5</sp=
an>);
      <span class=3D"kw">let</span> y =3D <span class=3D"dv">42</span>;
  }</code></pre></div>
  <p>Here=E2=80=99s what happens in memory when <code>main()</code> is call=
ed:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">??????</td>
  </tr>
  </tbody>
  </table>
  <p>We allocate space for two variables on the stack. <code>y</code> is <c=
ode>42</code>, as it always has been, but what about <code>x</code>? Well, =
<code>x</code> is a <code>Box&lt;i32&gt;</code>, and boxes allocate memory =
on the heap. The actual value of the box is a structure which has a pointer=
 to =E2=80=98the heap=E2=80=99. When we start executing the function, and <=
code>Box::new()</code> is called, it allocates some memory for the heap, an=
d puts <code>5</code> there. The memory now looks like this:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  </tbody>
  </table>
  <p>We have 2<sup>30</sup> in our hypothetical computer with 1GB of RAM. A=
nd since our stack grows from zero, the easiest place to allocate memory is=
 from the other end. So our first value is at the highest place in memory. =
And the value of the struct at <code>x</code> has a <a href=3D"https://kill=
ercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--raw-pointers">raw poin=
ter</a> to the place we=E2=80=99ve allocated on the heap, so the value of <=
code>x</code> is 2<sup>30</sup>, the memory location we=E2=80=99ve asked fo=
r.</p>
  <p>We haven=E2=80=99t really talked too much about what it actually means=
 to allocate and deallocate memory in these contexts. Getting into very dee=
p detail is out of the scope of this tutorial, but what=E2=80=99s important=
 to point out here is that the heap isn=E2=80=99t just a stack that grows f=
rom the opposite end. We=E2=80=99ll have an example of this later in the bo=
ok, but because the heap can be allocated and freed in any order, it can en=
d up with =E2=80=98holes=E2=80=99. Here=E2=80=99s a diagram of the memory l=
ayout of a program which has been running for a while now:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;"></td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;"></td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 3</td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 3</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  </tbody>
  </table>
  <p>In this case, we=E2=80=99ve allocated four things on the heap, but dea=
llocated two of them. There=E2=80=99s a gap between 2<sup>30</sup> and (2<s=
up>30</sup>) - 3 which isn=E2=80=99t currently being used. The specific det=
ails of how and why this happens depends on what kind of strategy you use t=
o manage the heap. Different programs can use different =E2=80=98memory all=
ocators=E2=80=99, which are libraries that manage this for you. Rust progra=
ms use <a href=3D"http://www.canonware.com/jemalloc/">jemalloc</a> for this=
 purpose.</p>
  <p>Anyway, back to our example. Since this memory is on the heap, it can =
stay alive longer than the function which allocates the box. In this case, =
however, it doesn=E2=80=99t.[^moving] When the function is over, we need to=
 free the stack frame for <code>main()</code>. <code>Box&lt;T&gt;</code>, t=
hough, has a trick up its sleve: <a href=3D"https://killercup.github.io/trp=
l-ebook/trpl-2015-05-13.html#sec--drop">Drop</a>. The implementation of <co=
de>Drop</code> for <code>Box</code> deallocates the memory that was allocat=
ed when it was created. Great! So when <code>x</code> goes away, it first f=
rees the memory allocated on the heap:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">??????</td>
  </tr>
  </tbody>
  </table>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">      sometimes called =E2=80=98moving out of the box=E2=80=
=99. More complex examples will
        be covered later.</code></pre></div>
  <p>And then the stack frame goes away, freeing all of our memory.</p>
  <h3 id=3D"arguments-and-borrowing">Arguments and borrowing</h3>
  <p>We=E2=80=99ve got some basic examples with the stack and the heap goin=
g, but what about function arguments and borrowing? Here=E2=80=99s a small =
Rust program:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(i: &amp;<span class=3D"kw"=
>i32</span>) {
      <span class=3D"kw">let</span> z =3D <span class=3D"dv">42</span>;
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">5</span>;
      <span class=3D"kw">let</span> y =3D &amp;x;
 =20
      foo(y);
  }</code></pre></div>
  <p>When we enter <code>main()</code>, memory looks like this:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  </tbody>
  </table>
  <p><code>x</code> is a plain old <code>5</code>, and <code>y</code> is a =
reference to <code>x</code>. So its value is the memory location that <code=
>x</code> lives at, which in this case is <code>0</code>.</p>
  <p>What about when we call <code>foo()</code>, passing <code>y</code> as =
an argument?</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">z</td>
  <td style=3D"text-align: left;">42</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  </tbody>
  </table>
  <p>Stack frames aren=E2=80=99t just for local bindings, they=E2=80=99re f=
or arguments too. So in this case, we need to have both <code>i</code>, our=
 argument, and <code>z</code>, our local variable binding. <code>i</code> i=
s a copy of the argument, <code>y</code>. Since <code>y</code>=E2=80=99s va=
lue is <code>0</code>, so is <code>i</code>=E2=80=99s.</p>
  <p>This is one reason why borrowing a variable doesn=E2=80=99t deallocate=
 any memory: the value of a reference is just a pointer to a memory locatio=
n. If we got rid of the underlying memory, things wouldn=E2=80=99t work ver=
y well.</p>
  <h3 id=3D"a-complex-example">A complex example</h3>
  <p>Okay, let=E2=80=99s go through this complex program step-by-step:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(x: &amp;<span class=3D"kw"=
>i32</span>) {
      <span class=3D"kw">let</span> y =3D <span class=3D"dv">10</span>;
      <span class=3D"kw">let</span> z =3D &amp;y;
 =20
      baz(z);
      bar(x, z);
  }
 =20
  <span class=3D"kw">fn</span> bar(a: &amp;<span class=3D"kw">i32</span>, b=
: &amp;<span class=3D"kw">i32</span>) {
      <span class=3D"kw">let</span> c =3D <span class=3D"dv">5</span>;
      <span class=3D"kw">let</span> d =3D Box::new(<span class=3D"dv">5</sp=
an>);
      <span class=3D"kw">let</span> e =3D &amp;d;
 =20
      baz(e);
  }
 =20
  <span class=3D"kw">fn</span> baz(f: &amp;<span class=3D"kw">i32</span>) {
      <span class=3D"kw">let</span> g =3D <span class=3D"dv">100</span>;
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> h =3D <span class=3D"dv">3</span>;
      <span class=3D"kw">let</span> i =3D Box::new(<span class=3D"dv">20</s=
pan>);
      <span class=3D"kw">let</span> j =3D &amp;h;
 =20
      foo(j);
  }</code></pre></div>
  <p>First, we call <code>main()</code>:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">20</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">j</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">h</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>We allocate memory for <code>j</code>, <code>i</code>, and <code>h</co=
de>. <code>i</code> is on the heap, and so has a value pointing there.</p>
  <p>Next, at the end of <code>main()</code>, <code>foo()</code> gets calle=
d:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">20</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">5</td>
  <td style=3D"text-align: left;">z</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">4</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">10</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">j</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">h</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Space gets allocated for <code>x</code>, <code>y</code>, and <code>z</=
code>. The argument <code>x</code> has the same value as <code>j</code>, si=
nce that=E2=80=99s what we passed it in. It=E2=80=99s a pointer to the <cod=
e>0</code> address, since <code>j</code> points at <code>h</code>.</p>
  <p>Next, <code>foo()</code> calls <code>baz()</code>, passing <code>z</co=
de>:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">20</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">7</td>
  <td style=3D"text-align: left;">g</td>
  <td style=3D"text-align: left;">100</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">6</td>
  <td style=3D"text-align: left;">f</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">5</td>
  <td style=3D"text-align: left;">z</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">4</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">10</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">j</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">h</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>We=E2=80=99ve allocated memory for <code>f</code> and <code>g</code>. =
<code>baz()</code> is very short, so when it=E2=80=99s over, we get rid of =
its stack frame:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">20</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">5</td>
  <td style=3D"text-align: left;">z</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">4</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">10</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">j</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">h</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Next, <code>foo()</code> calls <code>bar()</code> with <code>x</code> =
and <code>z</code>:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">20</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">10</td>
  <td style=3D"text-align: left;">e</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">9</td>
  <td style=3D"text-align: left;">d</td>
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 1</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">8</td>
  <td style=3D"text-align: left;">c</td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">7</td>
  <td style=3D"text-align: left;">b</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">6</td>
  <td style=3D"text-align: left;">a</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">5</td>
  <td style=3D"text-align: left;">z</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">4</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">10</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">j</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">h</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>We end up allocating another value on the heap, and so we have to subt=
ract one from 2<sup>30</sup>. It=E2=80=99s easier to just write that than <=
code>1,073,741,823</code>. In any case, we set up the variables as usual.</=
p>
  <p>At the end of <code>bar()</code>, it calls <code>baz()</code>:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">20</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">12</td>
  <td style=3D"text-align: left;">g</td>
  <td style=3D"text-align: left;">100</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">11</td>
  <td style=3D"text-align: left;">f</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">10</td>
  <td style=3D"text-align: left;">e</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">9</td>
  <td style=3D"text-align: left;">d</td>
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 1</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">8</td>
  <td style=3D"text-align: left;">c</td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">7</td>
  <td style=3D"text-align: left;">b</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">6</td>
  <td style=3D"text-align: left;">a</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">5</td>
  <td style=3D"text-align: left;">z</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">4</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">10</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">j</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">h</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>With this, we=E2=80=99re at our deepest point! Whew! Congrats for foll=
owing along this far.</p>
  <p>After <code>baz()</code> is over, we get rid of <code>f</code> and <co=
de>g</code>:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">20</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">10</td>
  <td style=3D"text-align: left;">e</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">9</td>
  <td style=3D"text-align: left;">d</td>
  <td style=3D"text-align: left;">(2<sup>30</sup>) - 1</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">8</td>
  <td style=3D"text-align: left;">c</td>
  <td style=3D"text-align: left;">5</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">7</td>
  <td style=3D"text-align: left;">b</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">6</td>
  <td style=3D"text-align: left;">a</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">5</td>
  <td style=3D"text-align: left;">z</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">4</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">10</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">j</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">h</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Next, we return from <code>bar()</code>. <code>d</code> in this case i=
s a <code>Box&lt;T&gt;</code>, so it also frees what it points to: (2<sup>3=
0</sup>) - 1.</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">20</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">5</td>
  <td style=3D"text-align: left;">z</td>
  <td style=3D"text-align: left;">4</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">4</td>
  <td style=3D"text-align: left;">y</td>
  <td style=3D"text-align: left;">10</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">x</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">j</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">h</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>And after that, <code>foo()</code> returns:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">Address</th>
  <th style=3D"text-align: left;">Name</th>
  <th style=3D"text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  <td style=3D"text-align: left;"></td>
  <td style=3D"text-align: left;">20</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  <td style=3D"text-align: left;">=E2=80=A6</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">j</td>
  <td style=3D"text-align: left;">0</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">i</td>
  <td style=3D"text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">h</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>And then, finally, <code>main()</code>, which cleans the rest up. When=
 <code>i</code> is <code>Drop</code>ped, it will clean up the last of the h=
eap too.</p>
  <h3 id=3D"what-do-other-languages-do">What do other languages do?</h3>
  <p>Most languages with a garbage collector heap-allocate by default. This=
 means that every value is boxed. There are a number of reasons why this is=
 done, but they=E2=80=99re out of scope for this tutorial. There are some p=
ossible optimizations that don=E2=80=99t make it true 100% of the time, too=
. Rather than relying on the stack and <code>Drop</code> to clean up memory=
, the garbage collector deals with the heap instead.</p>
  <h3 id=3D"which-to-use">Which to use?</h3>
  <p>So if the stack is faster and easier to manage, why do we need the hea=
p? A big reason is that Stack-allocation alone means you only have LIFO sem=
antics for reclaiming storage. Heap-allocation is strictly more general, al=
lowing storage to be taken from and returned to the pool in arbitrary order=
, but at a complexity cost.</p>
  <p>Generally, you should prefer stack allocation, and so, Rust stack-allo=
cates by default. The LIFO model of the stack is simpler, at a fundamental =
level. This has two big impacts: runtime efficiency and semantic impact.</p=
>
  <h4 id=3D"runtime-efficiency.">Runtime Efficiency.</h4>
  <p>Managing the memory for the stack is trivial: The machine just increme=
nts or decrements a single value, the so-called =E2=80=9Cstack pointer=E2=
=80=9D. Managing memory for the heap is non-trivial: heap-allocated memory =
is freed at arbitrary points, and each block of heap-allocated memory can b=
e of arbitrary size, the memory manager must generally work much harder to =
identify memory for reuse.</p>
  <p>If you=E2=80=99d like to dive into this topic in greater detail, <a hr=
ef=3D"http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf">this pap=
er</a> is a great introduction.</p>
  <h4 id=3D"semantic-impact">Semantic impact</h4>
  <p>Stack-allocation impacts the Rust language itself, and thus the develo=
per=E2=80=99s mental model. The LIFO semantics is what drives how the Rust =
language handles automatic memory management. Even the deallocation of a un=
iquely-owned heap-allocated box can be driven by the stack-based LIFO seman=
tics, as discussed throughout this chapter. The flexibility (i.e.&nbsp;expr=
essiveness) of non LIFO-semantics means that in general the compiler cannot=
 automatically infer at compile-time where memory should be freed; it has t=
o rely on dynamic protocols, potentially from outside the language itself, =
to drive deallocation (reference counting, as used by <code>Rc&lt;T&gt;</co=
de> and <code>Arc&lt;T&gt;</code>, is one example of this).</p>
  <p>When taken to the extreme, the increased expressive power of heap allo=
cation comes at the cost of either significant runtime support (e.g.&nbsp;i=
n the form of a garbage collector) or significant programmer effort (in the=
 form of explicit memory management calls that require verification not pro=
vided by the Rust compiler).</p>
  <h2 id=3D"sec--testing">Testing</h2>
  <blockquote>
  <p>Program testing can be a very effective way to show the presence of bu=
gs, but it is hopelessly inadequate for showing their absence.</p>
  <p>Edsger W. Dijkstra, =E2=80=9CThe Humble Programmer=E2=80=9D (1972)</p>
  </blockquote>
  <p>Let=E2=80=99s talk about how to test Rust code. What we will not be ta=
lking about is the right way to test Rust code. There are many schools of t=
hought regarding the right and wrong way to write tests. All of these appro=
aches use the same basic tools, and so we=E2=80=99ll show you the syntax fo=
r using them.</p>
  <h3 id=3D"the-test-attribute">The <code>test</code> attribute</h3>
  <p>At its simplest, a test in Rust is a function that=E2=80=99s annotated=
 with the <code>test</code> attribute. Let=E2=80=99s make a new project wit=
h Cargo called <code>adder</code>:</p>
  <pre><code>$ cargo new adder
  $ cd adder</code></pre>
  <p>Cargo will automatically generate a simple test when you make a new pr=
oject. Here=E2=80=99s the contents of <code>src/lib.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
  <span class=3D"kw">fn</span> it_works() {
  }</code></pre></div>
  <p>Note the <code>#[test]</code>. This attribute indicates that this is a=
 test function. It currently has no body. That=E2=80=99s good enough to pas=
s! We can run the tests with <code>cargo test</code>:</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
 =20
  running 1 test
  test it_works ... ok
 =20
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
 =20
     Doc-tests adder
 =20
  running 0 tests
 =20
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>Cargo compiled and ran our tests. There are two sets of output here: o=
ne for the test we wrote, and another for documentation tests. We=E2=80=99l=
l talk about those later. For now, see this line:</p>
  <pre><code>test it_works ... ok</code></pre>
  <p>Note the <code>it_works</code>. This comes from the name of our functi=
on:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> it_works() {</code></pre></div=
>
  <p>We also get a summary line:</p>
  <pre><code>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured</co=
de></pre>
  <p>So why does our do-nothing test pass? Any test which doesn=E2=80=99t <=
code>panic!</code> passes, and any test that does <code>panic!</code> fails=
. Let=E2=80=99s make our test fail:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
  <span class=3D"kw">fn</span> it_works() {
      <span class=3D"ot">assert!</span>(<span class=3D"kw">false</span>);
  }</code></pre></div>
  <p><code>assert!</code> is a macro provided by Rust which takes one argum=
ent: if the argument is <code>true</code>, nothing happens. If the argument=
 is false, it <code>panic!</code>s. Let=E2=80=99s run our tests again:</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
 =20
  running 1 test
  test it_works ... FAILED
 =20
  failures:
 =20
  ---- it_works stdout ----
          thread 'it_works' panicked at 'assertion failed: false', /home/st=
eve/tmp/adder/src/lib.rs:3
 =20
 =20
 =20
  failures:
      it_works
 =20
  test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
 =20
  thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/ru=
st/src/libtest/lib.rs:247</code></pre>
  <p>Rust indicates that our test failed:</p>
  <pre><code>test it_works ... FAILED</code></pre>
  <p>And that=E2=80=99s reflected in the summary line:</p>
  <pre><code>test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured=
</code></pre>
  <p>We also get a non-zero status code:</p>
  <pre><code>$ echo $?
  101</code></pre>
  <p>This is useful if you want to integrate <code>cargo test</code> into o=
ther tooling.</p>
  <p>We can invert our test=E2=80=99s failure with another attribute: <code=
>should_panic</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
  <span class=3D"ot">#[</span>should_panic<span class=3D"ot">]</span>
  <span class=3D"kw">fn</span> it_works() {
      <span class=3D"ot">assert!</span>(<span class=3D"kw">false</span>);
  }</code></pre></div>
  <p>This test will now succeed if we <code>panic!</code> and fail if we co=
mplete. Let=E2=80=99s try it:</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
 =20
  running 1 test
  test it_works ... ok
 =20
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
 =20
     Doc-tests adder
 =20
  running 0 tests
 =20
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>Rust provides another macro, <code>assert_eq!</code>, that compares tw=
o arguments for equality:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
  <span class=3D"ot">#[</span>should_panic<span class=3D"ot">]</span>
  <span class=3D"kw">fn</span> it_works() {
      <span class=3D"ot">assert_eq!</span>(<span class=3D"st">"Hello"</span=
>, <span class=3D"st">"world"</span>);
  }</code></pre></div>
  <p>Does this test pass or fail? Because of the <code>should_panic</code> =
attribute, it passes:</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
 =20
  running 1 test
  test it_works ... ok
 =20
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
 =20
     Doc-tests adder
 =20
  running 0 tests
 =20
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p><code>should_panic</code> tests can be fragile, as it=E2=80=99s hard t=
o guarantee that the test didn=E2=80=99t fail for an unexpected reason. To =
help with this, an optional <code>expected</code> parameter can be added to=
 the <code>should_panic</code> attribute. The test harness will make sure t=
hat the failure message contains the provided text. A safer version of the =
example above would be:</p>
  <pre><code>#[test]
  #[should_panic(expected =3D "assertion failed")]
  fn it_works() {
      assert_eq!("Hello", "world");
  }</code></pre>
  <p>That=E2=80=99s all there is to the basics! Let=E2=80=99s write one =E2=
=80=98real=E2=80=99 test:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">fn</span> =
add_two(a: <span class=3D"kw">i32</span>) -&gt; <span class=3D"kw">i32</spa=
n> {
      a + <span class=3D"dv">2</span>
  }
 =20
  <span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
  <span class=3D"kw">fn</span> it_works() {
      <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">4</span>, add=
_two(<span class=3D"dv">2</span>));
  }</code></pre></div>
  <p>This is a very common use of <code>assert_eq!</code>: call some functi=
on with some known arguments and compare it to the expected output.</p>
  <h3 id=3D"the-tests-module">The <code>tests</code> module</h3>
  <p>There is one way in which our existing example is not idiomatic: it=E2=
=80=99s missing the <code>tests</code> module. The idiomatic way of writing=
 our example looks like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">fn</span> =
add_two(a: <span class=3D"kw">i32</span>) -&gt; <span class=3D"kw">i32</spa=
n> {
      a + <span class=3D"dv">2</span>
  }
 =20
  <span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>test<span class=
=3D"ot">)]</span>
  <span class=3D"kw">mod</span> tests {
      <span class=3D"kw">use</span> <span class=3D"kw">super</span>::add_tw=
o;
 =20
      <span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
      <span class=3D"kw">fn</span> it_works() {
          <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">4</span>,=
 add_two(<span class=3D"dv">2</span>));
      }
  }</code></pre></div>
  <p>There=E2=80=99s a few changes here. The first is the introduction of a=
 <code>mod tests</code> with a <code>cfg</code> attribute. The module allow=
s us to group all of our tests together, and to also define helper function=
s if needed, that don=E2=80=99t become a part of the rest of our crate. The=
 <code>cfg</code> attribute only compiles our test code if we=E2=80=99re cu=
rrently trying to run the tests. This can save compile time, and also ensur=
es that our tests are entirely left out of a normal build.</p>
  <p>The second change is the <code>use</code> declaration. Because we=E2=
=80=99re in an inner module, we need to bring our test function into scope.=
 This can be annoying if you have a large module, and so this is a common u=
se of the <code>glob</code> feature. Let=E2=80=99s change our <code>src/lib=
.rs</code> to make use of it:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">
  <span class=3D"kw">pub</span> <span class=3D"kw">fn</span> add_two(a: <sp=
an class=3D"kw">i32</span>) -&gt; <span class=3D"kw">i32</span> {
      a + <span class=3D"dv">2</span>
  }
 =20
  <span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>test<span class=
=3D"ot">)]</span>
  <span class=3D"kw">mod</span> tests {
      <span class=3D"kw">use</span> <span class=3D"kw">super</span>::*;
 =20
      <span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
      <span class=3D"kw">fn</span> it_works() {
          <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">4</span>,=
 add_two(<span class=3D"dv">2</span>));
      }
  }</code></pre></div>
  <p>Note the different <code>use</code> line. Now we run our tests:</p>
  <pre><code>$ cargo test
      Updating registry `https://github.com/rust-lang/crates.io-index`
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
 =20
  running 1 test
  test tests::it_works ... ok
 =20
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
 =20
     Doc-tests adder
 =20
  running 0 tests
 =20
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>It works!</p>
  <p>The current convention is to use the <code>tests</code> module to hold=
 your =E2=80=9Cunit-style=E2=80=9D tests. Anything that just tests one smal=
l bit of functionality makes sense to go here. But what about =E2=80=9Cinte=
gration-style=E2=80=9D tests instead? For that, we have the <code>tests</co=
de> directory</p>
  <h3 id=3D"the-tests-directory">The <code>tests</code> directory</h3>
  <p>To write an integration test, let=E2=80=99s make a <code>tests</code> =
directory, and put a <code>tests/lib.rs</code> file inside, with this as it=
s contents:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate adder;
 =20
  <span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
  <span class=3D"kw">fn</span> it_works() {
      <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">4</span>, add=
er::add_two(<span class=3D"dv">2</span>));
  }</code></pre></div>
  <p>This looks similar to our previous tests, but slightly different. We n=
ow have an <code>extern crate adder</code> at the top. This is because the =
tests in the <code>tests</code> directory are an entirely separate crate, a=
nd so we need to import our library. This is also why <code>tests</code> is=
 a suitable place to write integration-style tests: they use the library li=
ke any other consumer of it would.</p>
  <p>Let=E2=80=99s run them:</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
 =20
  running 1 test
  test tests::it_works ... ok
 =20
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
 =20
       Running target/lib-c18e7d3494509e74
 =20
  running 1 test
  test it_works ... ok
 =20
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
 =20
     Doc-tests adder
 =20
  running 0 tests
 =20
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>Now we have three sections: our previous test is also run, as well as =
our new one.</p>
  <p>That=E2=80=99s all there is to the <code>tests</code> directory. The <=
code>tests</code> module isn=E2=80=99t needed here, since the whole thing i=
s focused on tests.</p>
  <p>Let=E2=80=99s finally check out that third section: documentation test=
s.</p>
  <h3 id=3D"documentation-tests">Documentation tests</h3>
  <p>Nothing is better than documentation with examples. Nothing is worse t=
han examples that don=E2=80=99t actually work, because the code has changed=
 since the documentation has been written. To this end, Rust supports autom=
atically running examples in your documentation. Here=E2=80=99s a fleshed-o=
ut <code>src/lib.rs</code> with examples:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"co">//! The `adder` crate provides functions=
 that add numbers to other numbers.</span>
  <span class=3D"co">//!</span>
  <span class=3D"co">//! # Examples</span>
  <span class=3D"co">//!</span>
  <span class=3D"co">//! ```</span>
  <span class=3D"co">//! assert_eq!(4, adder::add_two(2));</span>
  <span class=3D"co">//! ```</span>
 =20
  <span class=3D"co">/// This function adds two to its argument.</span>
  <span class=3D"co">///</span>
  <span class=3D"co">/// # Examples</span>
  <span class=3D"co">///</span>
  <span class=3D"co">/// ```</span>
  <span class=3D"co">/// use adder::add_two;</span>
  <span class=3D"co">///</span>
  <span class=3D"co">/// assert_eq!(4, add_two(2));</span>
  <span class=3D"co">/// ```</span>
  <span class=3D"kw">pub</span> <span class=3D"kw">fn</span> add_two(a: <sp=
an class=3D"kw">i32</span>) -&gt; <span class=3D"kw">i32</span> {
      a + <span class=3D"dv">2</span>
  }
 =20
  <span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>test<span class=
=3D"ot">)]</span>
  <span class=3D"kw">mod</span> tests {
      <span class=3D"kw">use</span> <span class=3D"kw">super</span>::*;
 =20
      <span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
      <span class=3D"kw">fn</span> it_works() {
          <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">4</span>,=
 add_two(<span class=3D"dv">2</span>));
      }
  }</code></pre></div>
  <p>Note the module-level documentation with <code>//!</code> and the func=
tion-level documentation with <code>///</code>. Rust=E2=80=99s documentatio=
n supports Markdown in comments, and so triple graves mark code blocks. It =
is conventional to include the <code># Examples</code> section, exactly lik=
e that, with examples following.</p>
  <p>Let=E2=80=99s run the tests again:</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
       Running target/adder-91b3e234d4ed382a
 =20
  running 1 test
  test tests::it_works ... ok
 =20
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
 =20
       Running target/lib-c18e7d3494509e74
 =20
  running 1 test
  test it_works ... ok
 =20
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
 =20
     Doc-tests adder
 =20
  running 2 tests
  test add_two_0 ... ok
  test _0 ... ok
 =20
  test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>Now we have all three kinds of tests running! Note the names of the do=
cumentation tests: the <code>_0</code> is generated for the module test, an=
d <code>add_two_0</code> for the function test. These will auto increment w=
ith names like <code>add_two_1</code> as you add more examples.</p>
  <h2 id=3D"sec--conditional-compilation">Conditional Compilation</h2>
  <p>Rust has a special attribute, <code>#[cfg]</code>, which allows you to=
 compile code based on a flag passed to the compiler. It has two forms:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>f=
oo<span class=3D"ot">)]</span>
 =20
  <span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>bar <span class=
=3D"ot">=3D</span> <span class=3D"st">"baz"</span><span class=3D"ot">)]</sp=
an></code></pre></div>
  <p>They also have some helpers:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>a=
ny<span class=3D"ot">(</span>unix<span class=3D"ot">,</span> windows<span c=
lass=3D"ot">))]</span>
 =20
  <span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>all<span class=
=3D"ot">(</span>unix<span class=3D"ot">,</span> target_pointer_width <span =
class=3D"ot">=3D</span> <span class=3D"st">"32"</span><span class=3D"ot">))=
]</span>
 =20
  <span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>not<span class=
=3D"ot">(</span>foo<span class=3D"ot">))]</span></code></pre></div>
  <p>These can nest arbitrarily:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>a=
ny<span class=3D"ot">(</span>not<span class=3D"ot">(</span>unix<span class=
=3D"ot">),</span> all<span class=3D"ot">(</span>target_os<span class=3D"ot"=
>=3D</span><span class=3D"st">"macos"</span><span class=3D"ot">,</span> tar=
get_arch <span class=3D"ot">=3D</span> <span class=3D"st">"powerpc"</span><=
span class=3D"ot">)))]</span></code></pre></div>
  <p>As for how to enable or disable these switches, if you=E2=80=99re usin=
g Cargo, they get set in the <a href=3D"http://doc.crates.io/manifest.html#=
the-[features]-section"><code>[features]</code> section</a> of your <code>C=
argo.toml</code>:</p>
  <pre><code>[features]
  # no features by default
  default =3D []
 =20
  # The =E2=80=9Csecure-password=E2=80=9D feature depends on the bcrypt pac=
kage.
  secure-password =3D ["bcrypt"]</code></pre>
  <p>When you do this, Cargo passes along a flag to <code>rustc</code>:</p>
  <pre><code>--cfg feature=3D"${feature_name}"</code></pre>
  <p>The sum of these <code>cfg</code> flags will determine which ones get =
activated, and therefore, which code gets compiled. Let=E2=80=99s take this=
 code:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>f=
eature <span class=3D"ot">=3D</span> <span class=3D"st">"foo"</span><span c=
lass=3D"ot">)]</span>
  <span class=3D"kw">mod</span> foo {
  }</code></pre></div>
  <p>If we compile it with <code>cargo build --features "foo"</code>, it wi=
ll send the <code>--cfg feature=3D"foo"</code> flag to <code>rustc</code>, =
and the output will have the <code>mod foo</code> in it. If we compile it w=
ith a regular <code>cargo build</code>, no extra flags get passed on, and s=
o, no <code>foo</code> module will exist.</p>
  <h3 id=3D"cfg_attr">cfg_attr</h3>
  <p>You can also set another attribute based on a <code>cfg</code> variabl=
e with <code>cfg_attr</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>cfg_attr<span class=3D"ot">(</s=
pan>a<span class=3D"ot">,</span> b<span class=3D"ot">)]</span></code></pre>=
</div>
  <p>Will be the same as <code>#[b]</code> if <code>a</code> is set by <cod=
e>cfg</code> attribute, and nothing otherwise.</p>
  <h3 id=3D"cfg">cfg!</h3>
  <p>The <code>cfg!</code> <a href=3D"https://killercup.github.io/trpl-eboo=
k/trpl-2015-05-13.html#sec--compiler-plugins">syntax extension</a> lets you=
 use these kinds of flags elsewhere in your code, too:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">if</span> <span class=3D"ot">cfg!</span>=
(target_os =3D <span class=3D"st">"macos"</span>) || <span class=3D"ot">cfg=
!</span>(target_os =3D <span class=3D"st">"ios"</span>) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Think Differen=
t!"</span>);
  }</code></pre></div>
  <p>These will be replaced by a <code>true</code> or <code>false</code> at=
 compile-time, depending on the configuration settings.</p>
  <h2 id=3D"sec--documentation">Documentation</h2>
  <p>Documentation is an important part of any software project, and it=E2=
=80=99s first-class in Rust. Let=E2=80=99s talk about the tooling Rust give=
s you to document your project.</p>
  <h4 id=3D"about-rustdoc">About <code>rustdoc</code></h4>
  <p>The Rust distribution includes a tool, <code>rustdoc</code>, that gene=
rates documentation. <code>rustdoc</code> is also used by Cargo through <co=
de>cargo doc</code>.</p>
  <p>Documentation can be generated in two ways: from source code, and from=
 standalone Markdown files.</p>
  <h4 id=3D"documenting-source-code">Documenting source code</h4>
  <p>The primary way of documenting a Rust project is through annotating th=
e source code. You can use documentation comments for this purpose:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"co">/// Constructs a new `Rc&lt;T&gt;`.</spa=
n>
  <span class=3D"co">///</span>
  <span class=3D"co">/// # Examples</span>
  <span class=3D"co">///</span>
  <span class=3D"co">/// ```</span>
  <span class=3D"co">/// use std::rc::Rc;</span>
  <span class=3D"co">///</span>
  <span class=3D"co">/// let five =3D Rc::new(5);</span>
  <span class=3D"co">/// ```</span>
  <span class=3D"kw">pub</span> <span class=3D"kw">fn</span> new(value: T) =
-&gt; Rc&lt;T&gt; {
      <span class=3D"co">// implementation goes here</span>
  }</code></pre></div>
  <p>This code generates documentation that looks <a href=3D"http://doc.rus=
t-lang.org/nightly/std/rc/struct.Rc.html#method.new">like this</a>. I=E2=80=
=99ve left the implementation out, with a regular comment in its place. Tha=
t=E2=80=99s the first thing to notice about this annotation: it uses <code>=
///</code>, instead of <code>//</code>. The triple slash indicates a docume=
ntation comment.</p>
  <p>Documentation comments are written in Markdown.</p>
  <p>Rust keeps track of these comments, and uses them when generating docu=
mentation. This is important when documenting things like enums:</p>
  <pre><code>/// The `Option` type. See [the module level documentation](..=
/) for more.
  enum Option&lt;T&gt; {
      /// No value
      None,
      /// Some value `T`
      Some(T),
  }</code></pre>
  <p>The above works, but this does not:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"co">/// The `Option` type. See [the module l=
evel documentation](../) for more.</span>
  <span class=3D"kw">enum</span> <span class=3D"kw">Option</span>&lt;T&gt; =
{
      <span class=3D"kw">None</span>, <span class=3D"co">/// No value</span=
>
      <span class=3D"kw">Some</span>(T), <span class=3D"co">/// Some value =
`T`</span>
  }</code></pre></div>
  <p>You=E2=80=99ll get an error:</p>
  <pre><code>hello.rs:4:1: 4:2 error: expected ident, found `}`
  hello.rs:4 }
             ^</code></pre>
  <p>This <a href=3D"https://github.com/rust-lang/rust/issues/22547">unfort=
unate error</a> is correct: documentation comments apply to the thing after=
 them, and there=E2=80=99s no thing after that last comment.</p>
  <h5 id=3D"writing-documentation-comments">Writing documentation comments<=
/h5>
  <p>Anyway, let=E2=80=99s cover each part of this comment in detail:</p>
  <pre><code>/// Constructs a new `Rc&lt;T&gt;`.
  # fn foo() {}</code></pre>
  <p>The first line of a documentation comment should be a short summary of=
 its functionality. One sentence. Just the basics. High level.</p>
  <pre><code>///
  /// Other details about constructing `Rc&lt;T&gt;`s, maybe describing com=
plicated
  /// semantics, maybe additional options, all kinds of stuff.
  ///
  # fn foo() {}</code></pre>
  <p>Our original example had just a summary line, but if we had more thing=
s to say, we could have added more explanation in a new paragraph.</p>
  <h6 id=3D"special-sections">Special sections</h6>
  <pre><code>/// # Examples
  # fn foo() {}</code></pre>
  <p>Next, are special sections. These are indicated with a header, <code>#=
</code>. There are three kinds of headers that are commonly used. They aren=
=E2=80=99t special syntax, just convention, for now.</p>
  <pre><code>/// # Panics
  # fn foo() {}</code></pre>
  <p>Unrecoverable misuses of a function (i.e.&nbsp;programming errors) in =
Rust are usually indicated by panics, which kill the whole current thread a=
t the very least. If your function has a non-trivial contract like this, th=
at is detected/enforced by panics, documenting it is very important.</p>
  <pre><code>/// # Failures
  # fn foo() {}</code></pre>
  <p>If your function or method returns a <code>Result&lt;T, E&gt;</code>, =
then describing the conditions under which it returns <code>Err(E)</code> i=
s a nice thing to do. This is slightly less important than <code>Panics</co=
de>, because failure is encoded into the type system, but it=E2=80=99s stil=
l a good thing to do.</p>
  <pre><code>/// # Safety
  # fn foo() {}</code></pre>
  <p>If your function is <code>unsafe</code>, you should explain which inva=
riants the caller is responsible for upholding.</p>
  <pre><code>/// # Examples
  ///
  /// ```
  /// use std::rc::Rc;
  ///
  /// let five =3D Rc::new(5);
  /// ```
  # fn foo() {}</code></pre>
  <p>Third, <code>Examples</code>. Include one or more examples of using yo=
ur function or method, and your users will love you for it. These examples =
go inside of code block annotations, which we=E2=80=99ll talk about in a mo=
ment, and can have more than one section:</p>
  <pre><code>/// # Examples
  ///
  /// Simple `&amp;str` patterns:
  ///
  /// ```
  /// let v: Vec&lt;&amp;str&gt; =3D "Mary had a little lamb".split(' ').co=
llect();
  /// assert_eq!(v, vec!["Mary", "had", "a", "little", "lamb"]);
  /// ```
  ///
  /// More complex patterns with a lambda:
  ///
  /// ```
  /// let v: Vec&lt;&amp;str&gt; =3D "abc1def2ghi".split(|c: char| c.is_num=
eric()).collect();
  /// assert_eq!(v, vec!["abc", "def", "ghi"]);
  /// ```
  # fn foo() {}</code></pre>
  <p>Let=E2=80=99s discuss the details of these code blocks.</p>
  <h6 id=3D"code-block-annotations">Code block annotations</h6>
  <p>To write some Rust code in a comment, use the triple graves:</p>
  <pre><code>/// ```
  /// println!("Hello, world");
  /// ```
  # fn foo() {}</code></pre>
  <p>If you want something that=E2=80=99s not Rust code, you can add an ann=
otation:</p>
  <pre><code>/// ```c
  /// printf("Hello, world\n");
  /// ```
  # fn foo() {}</code></pre>
  <p>This will highlight according to whatever language you=E2=80=99re show=
ing off. If you=E2=80=99re just showing plain text, choose <code>text</code=
>.</p>
  <p>It=E2=80=99s important to choose the correct annotation here, because =
<code>rustdoc</code> uses it in an interesting way: It can be used to actua=
lly test your examples, so that they don=E2=80=99t get out of date. If you =
have some C code but <code>rustdoc</code> thinks it=E2=80=99s Rust because =
you left off the annotation, <code>rustdoc</code> will complain when trying=
 to generate the documentation.</p>
  <h4 id=3D"documentation-as-tests">Documentation as tests</h4>
  <p>Let=E2=80=99s discuss our sample example documentation:</p>
  <pre><code>/// ```
  /// println!("Hello, world");
  /// ```
  # fn foo() {}</code></pre>
  <p>You=E2=80=99ll notice that you don=E2=80=99t need a <code>fn main()</c=
ode> or anything here. <code>rustdoc</code> will automatically add a main()=
 wrapper around your code, and in the right place. For example:</p>
  <pre><code>/// ```
  /// use std::rc::Rc;
  ///
  /// let five =3D Rc::new(5);
  /// ```
  # fn foo() {}</code></pre>
  <p>This will end up testing:</p>
  <pre><code>fn main() {
      use std::rc::Rc;
      let five =3D Rc::new(5);
  }</code></pre>
  <p>Here=E2=80=99s the full algorithm rustdoc uses to postprocess examples=
:</p>
  <ol type=3D"1">
  <li>Any leading <code>#![foo]</code> attributes are left intact as crate =
attributes.</li>
  <li>Some common <code>allow</code> attributes are inserted, including <co=
de>unused_variables</code>, <code>unused_assignments</code>, <code>unused_m=
ut</code>, <code>unused_attributes</code>, and <code>dead_code</code>. Smal=
l examples often trigger these lints.</li>
  <li>If the example does not contain <code>extern crate</code>, then <code=
>extern crate    &lt;mycrate&gt;;</code> is inserted.</li>
  <li>Finally, if the example does not contain <code>fn main</code>, the re=
mainder of the text is wrapped in <code>fn main() { your_code }</code></li>
  </ol>
  <p>Sometimes, this isn=E2=80=99t enough, though. For example, all of thes=
e code samples with <code>///</code> we=E2=80=99ve been talking about? The =
raw text:</p>
  <pre><code>/// Some documentation.
  # fn foo() {}</code></pre>
  <p>looks different than the output:</p>
  <pre><code>/// Some documentation.
  # fn foo() {}</code></pre>
  <p>Yes, that=E2=80=99s right: you can add lines that start with <code>#</=
code>, and they will be hidden from the output, but will be used when compi=
ling your code. You can use this to your advantage. In this case, documenta=
tion comments need to apply to some kind of function, so if I want to show =
you just a documentation comment, I need to add a little function definitio=
n below it. At the same time, it=E2=80=99s just there to satisfy the compil=
er, so hiding it makes the example more clear. You can use this technique t=
o explain longer examples in detail, while still preserving the testability=
 of your documentation. For example, this code:</p>
  <pre><code>let x =3D 5;
  let y =3D 6;
  println!("{}", x + y);</code></pre>
  <p>Here=E2=80=99s an explanation, rendered:</p>
  <p>First, we set <code>x</code> to five:</p>
  <pre><code>let x =3D 5;
  # let y =3D 6;
  # println!("{}", x + y);</code></pre>
  <p>Next, we set <code>y</code> to six:</p>
  <pre><code># let x =3D 5;
  let y =3D 6;
  # println!("{}", x + y);</code></pre>
  <p>Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
  <pre><code># let x =3D 5;
  # let y =3D 6;
  println!("{}", x + y);</code></pre>
  <p>Here=E2=80=99s the same explanation, in raw text:</p>
  <blockquote>
  <p>First, we set <code>x</code> to five:</p>
  <pre class=3D"text"><code>let x =3D 5;
  # let y =3D 6;
  # println!("{}", x + y);</code></pre>
  <p>Next, we set <code>y</code> to six:</p>
  <pre class=3D"text"><code># let x =3D 5;
  let y =3D 6;
  # println!("{}", x + y);</code></pre>
  <p>Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
  <pre class=3D"text"><code># let x =3D 5;
  # let y =3D 6;
  println!("{}", x + y);</code></pre>
  </blockquote>
  <p>By repeating all parts of the example, you can ensure that your exampl=
e still compiles, while only showing the parts that are relevant to that pa=
rt of your explanation.</p>
  <h5 id=3D"documenting-macros">Documenting macros</h5>
  <p>Here=E2=80=99s an example of documenting a macro:</p>
  <pre><code>/// Panic with a given message unless an expression evaluates =
to true.
  ///
  /// # Examples
  ///
  /// ```
  /// # #[macro_use] extern crate foo;
  /// # fn main() {
  /// panic_unless!(1 + 1 =3D=3D 2, =E2=80=9CMath is broken.=E2=80=9D);
  /// # }
  /// ```
  ///
  /// ```should_panic
  /// # #[macro_use] extern crate foo;
  /// # fn main() {
  /// panic_unless!(true =3D=3D false, =E2=80=9CI=E2=80=99m broken.=E2=80=
=9D);
  /// # }
  /// ```
  #[macro_export]
  macro_rules! panic_unless {
      ($condition:expr, $($rest:expr),+) =3D&gt; ({ if ! $condition { panic=
!($($rest),+); } });
  }
  # fn main() {}</code></pre>
  <p>You=E2=80=99ll note three things: we need to add our own <code>extern =
crate</code> line, so that we can add the <code>#[macro_use]</code> attribu=
te. Second, we=E2=80=99ll need to add our own <code>main()</code> as well. =
Finally, a judicious use of <code>#</code> to comment out those two things,=
 so they don=E2=80=99t show up in the output.</p>
  <h5 id=3D"running-documentation-tests">Running documentation tests</h5>
  <p>To run the tests, either</p>
  <pre><code>$ rustdoc --test path/to/my/crate/root.rs
  # or
  $ cargo test</code></pre>
  <p>That=E2=80=99s right, <code>cargo test</code> tests embedded documenta=
tion too. However, <code>cargo test</code> will not test binary crates, onl=
y library ones. This is due to the way <code>rustdoc</code> works: it links=
 against the library to be tested, but with a binary, there=E2=80=99s nothi=
ng to link to.</p>
  <p>There are a few more annotations that are useful to help <code>rustdoc=
</code> do the right thing when testing your code:</p>
  <pre><code>/// ```ignore
  /// fn foo() {
  /// ```
  # fn foo() {}</code></pre>
  <p>The <code>ignore</code> directive tells Rust to ignore your code. This=
 is almost never what you want, as it=E2=80=99s the most generic. Instead, =
consider annotating it with <code>text</code> if it=E2=80=99s not code, or =
using <code>#</code>s to get a working example that only shows the part you=
 care about.</p>
  <pre><code>/// ```should_panic
  /// assert!(false);
  /// ```
  # fn foo() {}</code></pre>
  <p><code>should_panic</code> tells <code>rustdoc</code> that the code sho=
uld compile correctly, but not actually pass as a test.</p>
  <pre><code>/// ```no_run
  /// loop {
  ///     println!("Hello, world");
  /// }
  /// ```
  # fn foo() {}</code></pre>
  <p>The <code>no_run</code> attribute will compile your code, but not run =
it. This is important for examples such as =E2=80=9CHere=E2=80=99s how to s=
tart up a network service,=E2=80=9D which you would want to make sure compi=
le, but might run in an infinite loop!</p>
  <h5 id=3D"documenting-modules">Documenting modules</h5>
  <p>Rust has another kind of doc comment, <code>//!</code>. This comment d=
oesn=E2=80=99t document the next item, but the enclosing item. In other wor=
ds:</p>
  <pre><code>mod foo {
      //! This is documentation for the `foo` module.
      //!
      //! # Examples
 =20
      // ...
  }</code></pre>
  <p>This is where you=E2=80=99ll see <code>//!</code> used most often: for=
 module documentation. If you have a module in <code>foo.rs</code>, you=E2=
=80=99ll often open its code and see this:</p>
  <pre><code>//! A module for using `foo`s.
  //!
  //! The `foo` module contains a lot of useful functionality blah blah bla=
h</code></pre>
  <h5 id=3D"documentation-comment-style">Documentation comment style</h5>
  <p>Check out <a href=3D"https://github.com/rust-lang/rfcs/blob/master/tex=
t/0505-api-comment-conventions.md">RFC 505</a> for full conventions around =
the style and format of documentation.</p>
  <h4 id=3D"other-documentation">Other documentation</h4>
  <p>All of this behavior works in non-Rust source files too. Because comme=
nts are written in Markdown, they=E2=80=99re often <code>.md</code> files.<=
/p>
  <p>When you write documentation in Markdown files, you don=E2=80=99t need=
 to prefix the documentation with comments. For example:</p>
  <pre><code>/// # Examples
  ///
  /// ```
  /// use std::rc::Rc;
  ///
  /// let five =3D Rc::new(5);
  /// ```
  # fn foo() {}</code></pre>
  <p>is just</p>
  <pre><code># Examples
  </code></pre>
  <p>use std::rc::Rc;</p>
  <p>let five =3D Rc::new(5);</p>
  <pre><code></code></pre>
  <p>when it=E2=80=99s in a Markdown file. There is one wrinkle though: Mar=
kdown files need to have a title like this:</p>
  <pre><code>% The title
 =20
  This is the example documentation.</code></pre>
  <p>This <code>%</code> line needs to be the very first line of the file.<=
/p>
  <h4 id=3D"doc-attributes"><code>doc</code> attributes</h4>
  <p>At a deeper level, documentation comments are sugar for documentation =
attributes:</p>
  <pre><code>/// this
  # fn foo() {}
 =20
  #[doc=3D"this"]
  # fn bar() {}</code></pre>
  <p>are the same, as are these:</p>
  <pre><code>//! this
 =20
  #![doc=3D"/// this"]</code></pre>
  <p>You won=E2=80=99t often see this attribute used for writing documentat=
ion, but it can be useful when changing some options, or when writing a mac=
ro.</p>
  <h5 id=3D"re-exports">Re-exports</h5>
  <p><code>rustdoc</code> will show the documentation for a public re-expor=
t in both places:</p>
  <pre><code>extern crate foo;
 =20
  pub use foo::bar;</code></pre>
  <p>This will create documentation for bar both inside the documentation f=
or the crate <code>foo</code>, as well as the documentation for your crate.=
 It will use the same documentation in both places.</p>
  <p>This behavior can be suppressed with <code>no_inline</code>:</p>
  <pre><code>extern crate foo;
 =20
  #[doc(no_inline)]
  pub use foo::bar;</code></pre>
  <h5 id=3D"controlling-html">Controlling HTML</h5>
  <p>You can control a few aspects of the HTML that <code>rustdoc</code> ge=
nerates through the <code>#![doc]</code> version of the attribute:</p>
  <pre><code>#![doc(html_logo_url =3D "http://www.rust-lang.org/logos/rust-=
logo-128x128-blk-v2.png",
         html_favicon_url =3D "http://www.rust-lang.org/favicon.ico",
         html_root_url =3D "http://doc.rust-lang.org/")];</code></pre>
  <p>This sets a few different options, with a logo, favicon, and a root UR=
L.</p>
  <h4 id=3D"generation-options">Generation options</h4>
  <p><code>rustdoc</code> also contains a few other options on the command =
line, for further customization:</p>
  <ul>
  <li><code>--html-in-header FILE</code>: includes the contents of FILE at =
the end of the <code>&lt;head&gt;...&lt;/head&gt;</code> section.</li>
  <li><code>--html-before-content FILE</code>: includes the contents of FIL=
E directly after <code>&lt;body&gt;</code>, before the rendered content (in=
cluding the search bar).</li>
  <li><code>--html-after-content FILE</code>: includes the contents of FILE=
 after all the rendered content.</li>
  </ul>
  <h4 id=3D"security-note">Security note</h4>
  <p>The Markdown in documentation comments is placed without processing in=
to the final webpage. Be careful with literal HTML:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"co">/// &lt;script&gt;alert(document.cookie)=
&lt;/script&gt;</span></code></pre></div>
  <h2 id=3D"sec--iterators">Iterators</h2>
  <p>Let=E2=80=99s talk about loops.</p>
  <p>Remember Rust=E2=80=99s <code>for</code> loop? Here=E2=80=99s an examp=
le:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">for</span> x in <span class=3D"dv">0.</s=
pan>.<span class=3D"dv">10</span> {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
;
  }</code></pre></div>
  <p>Now that you know more Rust, we can talk in detail about how this work=
s. Ranges (the <code>0..10</code>) are =E2=80=98iterators=E2=80=99. An iter=
ator is something that we can call the <code>.next()</code> method on repea=
tedly, and it gives us a sequence of things.</p>
  <p>Like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 range =3D <span class=3D"dv">0.</span>.<span class=3D"dv">10</span>;
 =20
  <span class=3D"kw">loop</span> {
      <span class=3D"kw">match</span> range.next() {
          <span class=3D"kw">Some</span>(x) =3D&gt; {
              <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</s=
pan>, x);
          },
          <span class=3D"kw">None</span> =3D&gt; { <span class=3D"kw">break=
</span> }
      }
  }</code></pre></div>
  <p>We make a mutable binding to the range, which is our iterator. We then=
 <code>loop</code>, with an inner <code>match</code>. This <code>match</cod=
e> is used on the result of <code>range.next()</code>, which gives us a ref=
erence to the next value of the iterator. <code>next</code> returns an <cod=
e>Option&lt;i32&gt;</code>, in this case, which will be <code>Some(i32)</co=
de> when we have a value and <code>None</code> once we run out. If we get <=
code>Some(i32)</code>, we print it out, and if we get <code>None</code>, we=
 <code>break</code> out of the loop.</p>
  <p>This code sample is basically the same as our <code>for</code> loop ve=
rsion. The <code>for</code> loop is just a handy way to write this <code>lo=
op</code>/<code>match</code>/<code>break</code> construct.</p>
  <p><code>for</code> loops aren=E2=80=99t the only thing that uses iterato=
rs, however. Writing your own iterator involves implementing the <code>Iter=
ator</code> trait. While doing that is outside of the scope of this guide, =
Rust provides a number of useful iterators to accomplish various threads. B=
efore we talk about those, we should talk about a Rust anti-pattern. And th=
at=E2=80=99s using ranges like this.</p>
  <p>Yes, we just talked about how ranges are cool. But ranges are also ver=
y primitive. For example, if you needed to iterate over the contents of a v=
ector, you may be tempted to write this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> nums =3D <span class=3D"ot">v=
ec!</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span =
class=3D"dv">3</span>];
 =20
  <span class=3D"kw">for</span> i in <span class=3D"dv">0.</span>.nums.len(=
) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, nu=
ms[i]);
  }</code></pre></div>
  <p>This is strictly worse than using an actual iterator. You can iterate =
over vectors directly, so write this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> nums =3D <span class=3D"ot">v=
ec!</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span =
class=3D"dv">3</span>];
 =20
  <span class=3D"kw">for</span> num in &amp;nums {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, nu=
m);
  }</code></pre></div>
  <p>There are two reasons for this. First, this more directly expresses wh=
at we mean. We iterate through the entire vector, rather than iterating thr=
ough indexes, and then indexing the vector. Second, this version is more ef=
ficient: the first version will have extra bounds checking because it used =
indexing, <code>nums[i]</code>. But since we yield a reference to each elem=
ent of the vector in turn with the iterator, there=E2=80=99s no bounds chec=
king in the second example. This is very common with iterators: we can igno=
re unnecessary bounds checks, but still know that we=E2=80=99re safe.</p>
  <p>There=E2=80=99s another detail here that=E2=80=99s not 100% clear beca=
use of how <code>println!</code> works. <code>num</code> is actually of typ=
e <code>&amp;i32</code>. That is, it=E2=80=99s a reference to an <code>i32<=
/code>, not an <code>i32</code> itself. <code>println!</code> handles the d=
ereferencing for us, so we don=E2=80=99t see it. This code works fine too:<=
/p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> nums =3D <span class=3D"ot">v=
ec!</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span =
class=3D"dv">3</span>];
 =20
  <span class=3D"kw">for</span> num in &amp;nums {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, *n=
um);
  }</code></pre></div>
  <p>Now we=E2=80=99re explicitly dereferencing <code>num</code>. Why does =
<code>&amp;nums</code> give us references? Firstly, because we explicitly a=
sked it to with <code>&amp;</code>. Secondly, if it gave us the data itself=
, we would have to be its owner, which would involve making a copy of the d=
ata and giving us the copy. With references, we=E2=80=99re just borrowing a=
 reference to the data, and so it=E2=80=99s just passing a reference, witho=
ut needing to do the move.</p>
  <p>So, now that we=E2=80=99ve established that ranges are often not what =
you want, let=E2=80=99s talk about what you do want instead.</p>
  <p>There are three broad classes of things that are relevant here: iterat=
ors, <em>iterator adapters</em>, and <em>consumers</em>. Here=E2=80=99s som=
e definitions:</p>
  <ul>
  <li><em>iterators</em> give you a sequence of values.</li>
  <li><em>iterator adapters</em> operate on an iterator, producing a new it=
erator with a different output sequence.</li>
  <li><em>consumers</em> operate on an iterator, producing some final set o=
f values.</li>
  </ul>
  <p>Let=E2=80=99s talk about consumers first, since you=E2=80=99ve already=
 seen an iterator, ranges.</p>
  <h4 id=3D"consumers">Consumers</h4>
  <p>A <em>consumer</em> operates on an iterator, returning some kind of va=
lue or values. The most common consumer is <code>collect()</code>. This cod=
e doesn=E2=80=99t quite compile, but it shows the intention:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> one_to_one_hundred =3D (<span=
 class=3D"dv">1.</span>.<span class=3D"dv">101</span>).collect();</code></p=
re></div>
  <p>As you can see, we call <code>collect()</code> on our iterator. <code>=
collect()</code> takes as many values as the iterator will give it, and ret=
urns a collection of the results. So why won=E2=80=99t this compile? Rust c=
an=E2=80=99t determine what type of things you want to collect, and so you =
need to let it know. Here=E2=80=99s the version that does compile:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> one_to_one_hundred =3D (<span=
 class=3D"dv">1.</span>.<span class=3D"dv">101</span>).collect::&lt;Vec&lt;=
<span class=3D"kw">i32</span>&gt;&gt;();</code></pre></div>
  <p>If you remember, the <code>::&lt;&gt;</code> syntax allows us to give =
a type hint, and so we tell it that we want a vector of integers. You don=
=E2=80=99t always need to use the whole type, though. Using a <code>_</code=
> will let you provide a partial hint:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> one_to_one_hundred =3D (<span=
 class=3D"dv">1.</span>.<span class=3D"dv">101</span>).collect::&lt;Vec&lt;=
_&gt;&gt;();</code></pre></div>
  <p>This says =E2=80=9CCollect into a <code>Vec&lt;T&gt;</code>, please, b=
ut infer what the <code>T</code> is for me.=E2=80=9D <code>_</code> is some=
times called a =E2=80=9Ctype placeholder=E2=80=9D for this reason.</p>
  <p><code>collect()</code> is the most common consumer, but there are othe=
rs too. <code>find()</code> is one:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> greater_than_forty_two =3D (<=
span class=3D"dv">0.</span>.<span class=3D"dv">100</span>)
                               .find(|x| *x &gt; <span class=3D"dv">42</spa=
n>);
 =20
  <span class=3D"kw">match</span> greater_than_forty_two {
      <span class=3D"kw">Some</span>(_) =3D&gt; <span class=3D"ot">println!=
</span>(<span class=3D"st">"We got some numbers!"</span>),
      <span class=3D"kw">None</span> =3D&gt; <span class=3D"ot">println!</s=
pan>(<span class=3D"st">"No numbers found :("</span>),
  }</code></pre></div>
  <p><code>find</code> takes a closure, and works on a reference to each el=
ement of an iterator. This closure returns <code>true</code> if the element=
 is the element we=E2=80=99re looking for, and <code>false</code> otherwise=
. Because we might not find a matching element, <code>find</code> returns a=
n <code>Option</code> rather than the element itself.</p>
  <p>Another important consumer is <code>fold</code>. Here=E2=80=99s what i=
t looks like:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> sum =3D (<span class=3D"dv">1=
.</span>.<span class=3D"dv">4</span>).fold(<span class=3D"dv">0</span>, |su=
m, x| sum + x);</code></pre></div>
  <p><code>fold()</code> is a consumer that looks like this: <code>fold(bas=
e, |accumulator, element| ...)</code>. It takes two arguments: the first is=
 an element called the <em>base</em>. The second is a closure that itself t=
akes two arguments: the first is called the <em>accumulator</em>, and the s=
econd is an <em>element</em>. Upon each iteration, the closure is called, a=
nd the result is the value of the accumulator on the next iteration. On the=
 first iteration, the base is the value of the accumulator.</p>
  <p>Okay, that=E2=80=99s a bit confusing. Let=E2=80=99s examine the values=
 of all of these things in this iterator:</p>
  <table>
  <thead>
  <tr class=3D"header">
  <th style=3D"text-align: left;">base</th>
  <th style=3D"text-align: left;">accumulator</th>
  <th style=3D"text-align: left;">element</th>
  <th style=3D"text-align: left;">closure result</th>
  </tr>
  </thead>
  <tbody>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">1</td>
  </tr>
  <tr class=3D"even">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">1</td>
  <td style=3D"text-align: left;">2</td>
  <td style=3D"text-align: left;">3</td>
  </tr>
  <tr class=3D"odd">
  <td style=3D"text-align: left;">0</td>
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">3</td>
  <td style=3D"text-align: left;">6</td>
  </tr>
  </tbody>
  </table>
  <p>We called <code>fold()</code> with these arguments:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">.fold(<span class=3D"dv">0</span>, |sum, x| sum + x);</code=
></pre></div>
  <p>So, <code>0</code> is our base, <code>sum</code> is our accumulator, a=
nd <code>x</code> is our element. On the first iteration, we set <code>sum<=
/code> to <code>0</code>, and <code>x</code> is the first element of <code>=
nums</code>, <code>1</code>. We then add <code>sum</code> and <code>x</code=
>, which gives us <code>0 + 1 =3D 1</code>. On the second iteration, that v=
alue becomes our accumulator, <code>sum</code>, and the element is the seco=
nd element of the array, <code>2</code>. <code>1 + 2 =3D 3</code>, and so t=
hat becomes the value of the accumulator for the last iteration. On that it=
eration, <code>x</code> is the last element, <code>3</code>, and <code>3 + =
3 =3D 6</code>, which is our final result for our sum. <code>1 + 2 + 3 =3D =
6</code>, and that=E2=80=99s the result we got.</p>
  <p>Whew. <code>fold</code> can be a bit strange the first few times you s=
ee it, but once it clicks, you can use it all over the place. Any time you =
have a list of things, and you want a single result, <code>fold</code> is a=
ppropriate.</p>
  <p>Consumers are important due to one additional property of iterators we=
 haven=E2=80=99t talked about yet: laziness. Let=E2=80=99s talk some more a=
bout iterators, and you=E2=80=99ll see why consumers matter.</p>
  <h4 id=3D"iterators">Iterators</h4>
  <p>As we=E2=80=99ve said before, an iterator is something that we can cal=
l the <code>.next()</code> method on repeatedly, and it gives us a sequence=
 of things. Because you need to call the method, this means that iterators =
can be <em>lazy</em> and not generate all of the values upfront. This code,=
 for example, does not actually generate the numbers <code>1-100</code>, in=
stead creating a value that merely represents the sequence:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> nums =3D <span class=3D"dv">1=
.</span>.<span class=3D"dv">100</span>;</code></pre></div>
  <p>Since we didn=E2=80=99t do anything with the range, it didn=E2=80=99t =
generate the sequence. Let=E2=80=99s add the consumer:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> nums =3D (<span class=3D"dv">=
1.</span>.<span class=3D"dv">100</span>).collect::&lt;Vec&lt;<span class=3D=
"kw">i32</span>&gt;&gt;();</code></pre></div>
  <p>Now, <code>collect()</code> will require that the range gives it some =
numbers, and so it will do the work of generating the sequence.</p>
  <p>Ranges are one of two basic iterators that you=E2=80=99ll see. The oth=
er is <code>iter()</code>. <code>iter()</code> can turn a vector into a sim=
ple iterator that gives you each element in turn:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> nums =3D <span class=3D"ot">v=
ec!</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span =
class=3D"dv">3</span>];
 =20
  <span class=3D"kw">for</span> num in nums.iter() {
     <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, num=
);
  }</code></pre></div>
  <p>These two basic iterators should serve you well. There are some more a=
dvanced iterators, including ones that are infinite.</p>
  <p>That=E2=80=99s enough about iterators. Iterator adapters are the last =
concept we need to talk about with regards to iterators. Let=E2=80=99s get =
to it!</p>
  <h4 id=3D"iterator-adapters">Iterator adapters</h4>
  <p><em>Iterator adapters</em> take an iterator and modify it somehow, pro=
ducing a new iterator. The simplest one is called <code>map</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">(<span class=3D"dv">1.</span>.<span class=3D"dv">100</span>=
).map(|x| x + <span class=3D"dv">1</span>);</code></pre></div>
  <p><code>map</code> is called upon another iterator, and produces a new i=
terator where each element reference has the closure it=E2=80=99s been give=
n as an argument called on it. So this would give us the numbers from <code=
>2-100</code>. Well, almost! If you compile the example, you=E2=80=99ll get=
 a warning:</p>
  <pre><code>warning: unused result which must be used: iterator adaptors a=
re lazy and
           do nothing unless consumed, #[warn(unused_must_use)] on by defau=
lt
  (1..100).map(|x| x + 1);
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>Laziness strikes again! That closure will never execute. This example =
doesn=E2=80=99t print any numbers:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">(<span class=3D"dv">1.</span>.<span class=3D"dv">100</span>=
).map(|x| <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>=
, x));</code></pre></div>
  <p>If you are trying to execute a closure on an iterator for its side eff=
ects, just use <code>for</code> instead.</p>
  <p>There are tons of interesting iterator adapters. <code>take(n)</code> =
will return an iterator over the next <code>n</code> elements of the origin=
al iterator. Note that this has no side effect on the original iterator. Le=
t=E2=80=99s try it out with our infinite iterator from before:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">for</span> i in (<span class=3D"dv">1.</=
span>.).step_by(<span class=3D"dv">5</span>).take(<span class=3D"dv">5</spa=
n>) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, i)=
;
  }</code></pre></div>
  <p>This will print</p>
  <pre><code>1
  6
  11
  16
  21</code></pre>
  <p><code>filter()</code> is an adapter that takes a closure as an argumen=
t. This closure returns <code>true</code> or <code>false</code>. The new it=
erator <code>filter()</code> produces only the elements that that closure r=
eturns <code>true</code> for:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">for</span> i in (<span class=3D"dv">1.</=
span>.<span class=3D"dv">100</span>).filter(|&amp;x| x % <span class=3D"dv"=
>2</span> =3D=3D <span class=3D"dv">0</span>) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, i)=
;
  }</code></pre></div>
  <p>This will print all of the even numbers between one and a hundred. (No=
te that because <code>filter</code> doesn=E2=80=99t consume the elements th=
at are being iterated over, it is passed a reference to each element, and t=
hus the filter predicate uses the <code>&amp;x</code> pattern to extract th=
e integer itself.)</p>
  <p>You can chain all three things together: start with an iterator, adapt=
 it a few times, and then consume the result. Check it out:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">(<span class=3D"dv">1.</span>.<span class=3D"dv">1000</span=
>)
      .filter(|&amp;x| x % <span class=3D"dv">2</span> =3D=3D <span class=
=3D"dv">0</span>)
      .filter(|&amp;x| x % <span class=3D"dv">3</span> =3D=3D <span class=
=3D"dv">0</span>)
      .take(<span class=3D"dv">5</span>)
      .collect::&lt;Vec&lt;<span class=3D"kw">i32</span>&gt;&gt;();</code><=
/pre></div>
  <p>This will give you a vector containing <code>6</code>, <code>12</code>=
, <code>18</code>, <code>24</code>, and <code>30</code>.</p>
  <p>This is just a small taste of what iterators, iterator adapters, and c=
onsumers can help you with. There are a number of really useful iterators, =
and you can write your own as well. Iterators provide a safe, efficient way=
 to manipulate all kinds of lists. They=E2=80=99re a little unusual at firs=
t, but if you play with them, you=E2=80=99ll get hooked. For a full list of=
 the different iterators and consumers, check out the <a href=3D"http://doc=
.rust-lang.org/std/iter/index.html">iterator module documentation</a>.</p>
  <h2 id=3D"sec--concurrency">Concurrency</h2>
  <p>Concurrency and parallelism are incredibly important topics in compute=
r science, and are also a hot topic in industry today. Computers are gainin=
g more and more cores, yet many programmers aren=E2=80=99t prepared to full=
y utilize them.</p>
  <p>Rust=E2=80=99s memory safety features also apply to its concurrency st=
ory too. Even concurrent Rust programs must be memory safe, having no data =
races. Rust=E2=80=99s type system is up to the thread, and gives you powerf=
ul ways to reason about concurrent code at compile time.</p>
  <p>Before we talk about the concurrency features that come with Rust, it=
=E2=80=99s important to understand something: Rust is low-level enough that=
 all of this is provided by the standard library, not by the language. This=
 means that if you don=E2=80=99t like some aspect of the way Rust handles c=
oncurrency, you can implement an alternative way of doing things. <a href=
=3D"https://github.com/carllerche/mio">mio</a> is a real-world example of t=
his principle in action.</p>
  <h4 id=3D"background-send-and-sync">Background: <code>Send</code> and <co=
de>Sync</code></h4>
  <p>Concurrency is difficult to reason about. In Rust, we have a strong, s=
tatic type system to help us reason about our code. As such, Rust gives us =
two traits to help us make sense of code that can possibly be concurrent.</=
p>
  <h5 id=3D"send"><code>Send</code></h5>
  <p>The first trait we=E2=80=99re going to talk about is <a href=3D"http:/=
/doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>. When =
a type <code>T</code> implements <code>Send</code>, it indicates to the com=
piler that something of this type is able to have ownership transferred saf=
ely between threads.</p>
  <p>This is important to enforce certain restrictions. For example, if we =
have a channel connecting two threads, we would want to be able to send som=
e data down the channel and to the other thread. Therefore, we=E2=80=99d en=
sure that <code>Send</code> was implemented for that type.</p>
  <p>In the opposite way, if we were wrapping a library with FFI that isn=
=E2=80=99t threadsafe, we wouldn=E2=80=99t want to implement <code>Send</co=
de>, and so the compiler will help us enforce that it can=E2=80=99t leave t=
he current thread.</p>
  <h5 id=3D"sync"><code>Sync</code></h5>
  <p>The second of these traits is called <a href=3D"http://doc.rust-lang.o=
rg/std/marker/trait.Sync.html"><code>Sync</code></a>. When a type <code>T</=
code> implements <code>Sync</code>, it indicates to the compiler that somet=
hing of this type has no possibility of introducing memory unsafety when us=
ed from multiple threads concurrently.</p>
  <p>For example, sharing immutable data with an atomic reference count is =
threadsafe. Rust provides a type like this, <code>Arc&lt;T&gt;</code>, and =
it implements <code>Sync</code>, so it is safe to share between threads.</p=
>
  <p>These two traits allow you to use the type system to make strong guara=
ntees about the properties of your code under concurrency. Before we demons=
trate why, we need to learn how to create a concurrent Rust program in the =
first place!</p>
  <h4 id=3D"threads">Threads</h4>
  <p>Rust=E2=80=99s standard library provides a library for threads, which =
allow you to run Rust code in parallel. Here=E2=80=99s a basic example of u=
sing <code>std::thread</code>:</p>
  <pre><code>use std::thread;
 =20
  fn main() {
      thread::spawn(|| {
          println!("Hello from a thread!");
      });
  }</code></pre>
  <p>The <code>thread::spawn()</code> method accepts a closure, which is ex=
ecuted in a new thread. It returns a handle to the thread, that can be used=
 to wait for the child thread to finish and extract its result:</p>
  <pre><code>use std::thread;
 =20
  fn main() {
      let handle =3D thread::spawn(|| {
          "Hello from a thread!"
      });
 =20
      println!("{}", handle.join().unwrap());
  }</code></pre>
  <p>Many languages have the ability to execute threads, but it=E2=80=99s w=
ildly unsafe. There are entire books about how to prevent errors that occur=
 from shared mutable state. Rust helps out with its type system here as wel=
l, by preventing data races at compile time. Let=E2=80=99s talk about how y=
ou actually share things between threads.</p>
  <h4 id=3D"safe-shared-mutable-state">Safe Shared Mutable State</h4>
  <p>Due to Rust=E2=80=99s type system, we have a concept that sounds like =
a lie: =E2=80=9Csafe shared mutable state.=E2=80=9D Many programmers agree =
that shared mutable state is very, very bad.</p>
  <p>Someone once said this:</p>
  <blockquote>
  <p>Shared mutable state is the root of all evil. Most languages attempt t=
o deal with this problem through the =E2=80=98mutable=E2=80=99 part, but Ru=
st deals with it by solving the =E2=80=98shared=E2=80=99 part.</p>
  </blockquote>
  <p>The same <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-0=
5-13.html#sec--ownership">ownership system</a> that helps prevent using poi=
nters incorrectly also helps rule out data races, one of the worst kinds of=
 concurrency bugs.</p>
  <p>As an example, here is a Rust program that would have a data race in m=
any languages. It will not compile:</p>
  <pre><code>use std::thread;
 =20
  fn main() {
      let mut data =3D vec![1u32, 2, 3];
 =20
      for i in 0..3 {
          thread::spawn(move || {
              data[i] +=3D 1;
          });
      }
 =20
      thread::sleep_ms(50);
  }</code></pre>
  <p>This gives us an error:</p>
  <pre><code>8:17 error: capture of moved value: `data`
          data[i] +=3D 1;
          ^~~~</code></pre>
  <p>In this case, we know that our code <em>should</em> be safe, but Rust =
isn=E2=80=99t sure. And it=E2=80=99s actually not safe: if we had a referen=
ce to <code>data</code> in each thread, and the thread takes ownership of t=
he reference, we have three owners! That=E2=80=99s bad. We can fix this by =
using the <code>Arc&lt;T&gt;</code> type, which is an atomic reference coun=
ted pointer. The =E2=80=98atomic=E2=80=99 part means that it=E2=80=99s safe=
 to share across threads.</p>
  <p><code>Arc&lt;T&gt;</code> assumes one more property about its contents=
 to ensure that it is safe to share across threads: it assumes its contents=
 are <code>Sync</code>. But in our case, we want to be able to mutate the v=
alue. We need a type that can ensure only one person at a time can mutate w=
hat=E2=80=99s inside. For that, we can use the <code>Mutex&lt;T&gt;</code> =
type. Here=E2=80=99s the second version of our code. It still doesn=E2=80=
=99t work, but for a different reason:</p>
  <pre><code>use std::thread;
  use std::sync::Mutex;
 =20
  fn main() {
      let mut data =3D Mutex::new(vec![1u32, 2, 3]);
 =20
      for i in 0..3 {
          let data =3D data.lock().unwrap();
          thread::spawn(move || {
              data[i] +=3D 1;
          });
      }
 =20
      thread::sleep_ms(50);
  }</code></pre>
  <p>Here=E2=80=99s the error:</p>
  <pre><code>&lt;anon&gt;:9:9: 9:22 error: the trait `core::marker::Send` i=
s not implemented for the type `std::sync::mutex::MutexGuard&lt;'_, collect=
ions::vec::Vec&lt;u32&gt;&gt;` [E0277]
  &lt;anon&gt;:11         thread::spawn(move || {
                    ^~~~~~~~~~~~~
  &lt;anon&gt;:9:9: 9:22 note: `std::sync::mutex::MutexGuard&lt;'_, collect=
ions::vec::Vec&lt;u32&gt;&gt;` cannot be sent between threads safely
  &lt;anon&gt;:11         thread::spawn(move || {
                    ^~~~~~~~~~~~~</code></pre>
  <p>You see, <a href=3D"http://doc.rust-lang.org/std/sync/struct.Mutex.htm=
l"><code>Mutex</code></a> has a <a href=3D"http://doc.rust-lang.org/std/syn=
c/struct.Mutex.html#method.lock"><code>lock</code></a> method which has thi=
s signature:</p>
  <pre><code>fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;=
</code></pre>
  <p>Because <code>Send</code> is not implemented for <code>MutexGuard&lt;T=
&gt;</code>, we can=E2=80=99t transfer the guard across thread boundaries, =
which gives us our error.</p>
  <p>We can use <code>Arc&lt;T&gt;</code> to fix this. Here=E2=80=99s the w=
orking version:</p>
  <pre><code>use std::sync::{Arc, Mutex};
  use std::thread;
 =20
  fn main() {
      let data =3D Arc::new(Mutex::new(vec![1u32, 2, 3]));
 =20
      for i in 0..3 {
          let data =3D data.clone();
          thread::spawn(move || {
              let mut data =3D data.lock().unwrap();
              data[i] +=3D 1;
          });
      }
 =20
      thread::sleep_ms(50);
  }</code></pre>
  <p>We now call <code>clone()</code> on our <code>Arc</code>, which increa=
ses the internal count. This handle is then moved into the new thread. Let=
=E2=80=99s examine the body of the thread more closely:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">thread::spawn(move || {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> data =3D =
data.lock().unwrap();
      data[i] +=3D <span class=3D"dv">1</span>;
  });</code></pre></div>
  <p>First, we call <code>lock()</code>, which acquires the mutex=E2=80=99s=
 lock. Because this may fail, it returns an <code>Result&lt;T, E&gt;</code>=
, and because this is just an example, we <code>unwrap()</code> it to get a=
 reference to the data. Real code would have more robust error handling her=
e. We=E2=80=99re then free to mutate it, since we have the lock.</p>
  <p>Lastly, while the threads are running, we wait on a short timer. But t=
his is not ideal: we may have picked a reasonable amount of time to wait bu=
t it=E2=80=99s more likely we=E2=80=99ll either be waiting longer than nece=
ssary or not long enough, depending on just how much time the threads actua=
lly take to finish computing when the program runs.</p>
  <p>A more precise alternative to the timer would be to use one of the mec=
hanisms provided by the Rust standard library for synchronizing threads wit=
h each other. Let=E2=80=99s talk about one of them: channels.</p>
  <h4 id=3D"channels">Channels</h4>
  <p>Here=E2=80=99s a version of our code that uses channels for synchroniz=
ation, rather than waiting for a specific time:</p>
  <pre><code>use std::sync::{Arc, Mutex};
  use std::thread;
  use std::sync::mpsc;
 =20
  fn main() {
      let data =3D Arc::new(Mutex::new(0u32));
 =20
      let (tx, rx) =3D mpsc::channel();
 =20
      for _ in 0..10 {
          let (data, tx) =3D (data.clone(), tx.clone());
 =20
          thread::spawn(move || {
              let mut data =3D data.lock().unwrap();
              *data +=3D 1;
 =20
              tx.send(());
          });
      }
 =20
      for _ in 0..10 {
          rx.recv();
      }
  }</code></pre>
  <p>We use the <code>mpsc::channel()</code> method to construct a new chan=
nel. We just <code>send</code> a simple <code>()</code> down the channel, a=
nd then wait for ten of them to come back.</p>
  <p>While this channel is just sending a generic signal, we can send any d=
ata that is <code>Send</code> over the channel!</p>
  <pre><code>use std::thread;
  use std::sync::mpsc;
 =20
  fn main() {
      let (tx, rx) =3D mpsc::channel();
 =20
      for _ in 0..10 {
          let tx =3D tx.clone();
 =20
          thread::spawn(move || {
              let answer =3D 42u32;
 =20
              tx.send(answer);
          });
      }
 =20
     rx.recv().ok().expect("Could not receive answer");
  }</code></pre>
  <p>A <code>u32</code> is <code>Send</code> because we can make a copy. So=
 we create a thread, ask it to calculate the answer, and then it <code>send=
()</code>s us the answer over the channel.</p>
  <h4 id=3D"panics">Panics</h4>
  <p>A <code>panic!</code> will crash the currently executing thread. You c=
an use Rust=E2=80=99s threads as a simple isolation mechanism:</p>
  <pre><code>use std::thread;
 =20
  let result =3D thread::spawn(move || {
      panic!("oops!");
  }).join();
 =20
  assert!(result.is_err());</code></pre>
  <p>Our <code>Thread</code> gives us a <code>Result</code> back, which all=
ows us to check if the thread has panicked or not.</p>
  <h2 id=3D"sec--error-handling">Error Handling</h2>
  <blockquote>
  <p>The best-laid plans of mice and men<br>Often go awry</p>
  <p>=E2=80=9CTae a Moose=E2=80=9D, Robert Burns</p>
  </blockquote>
  <p>Sometimes, things just go wrong. It=E2=80=99s important to have a plan=
 for when the inevitable happens. Rust has rich support for handling errors=
 that may (let=E2=80=99s be honest: will) occur in your programs.</p>
  <p>There are two main kinds of errors that can occur in your programs: fa=
ilures, and panics. Let=E2=80=99s talk about the difference between the two=
, and then discuss how to handle each. Then, we=E2=80=99ll discuss upgradin=
g failures to panics.</p>
  <h3 id=3D"failure-vs.panic">Failure vs.&nbsp;Panic</h3>
  <p>Rust uses two terms to differentiate between two forms of error: failu=
re, and panic. A <em>failure</em> is an error that can be recovered from in=
 some way. A <em>panic</em> is an error that cannot be recovered from.</p>
  <p>What do we mean by =E2=80=9Crecover=E2=80=9D? Well, in most cases, the=
 possibility of an error is expected. For example, consider the <code>parse=
</code> function:</p>
  <pre><code>"5".parse();</code></pre>
  <p>This method converts a string into another type. But because it=E2=80=
=99s a string, you can=E2=80=99t be sure that the conversion actually works=
. For example, what should this convert to?</p>
  <pre><code>"hello5world".parse();</code></pre>
  <p>This won=E2=80=99t work. So we know that this function will only work =
properly for some inputs. It=E2=80=99s expected behavior. We call this kind=
 of error a <em>failure</em>.</p>
  <p>On the other hand, sometimes, there are errors that are unexpected, or=
 which we cannot recover from. A classic example is an <code>assert!</code>=
:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">assert!</span>(x =3D=3D <span class=3D"d=
v">5</span>);</code></pre></div>
  <p>We use <code>assert!</code> to declare that something is true. If it=
=E2=80=99s not true, something is very wrong. Wrong enough that we can=E2=
=80=99t continue with things in the current state. Another example is using=
 the <code>unreachable!()</code> macro:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> Event {
      NewRelease,
  }
 =20
  <span class=3D"kw">fn</span> probability(_: &amp;Event) -&gt; <span class=
=3D"kw">f64</span> {
      <span class=3D"co">// real implementation would be more complex, of c=
ourse</span>
      <span class=3D"dv">0.95</span>
  }
 =20
  <span class=3D"kw">fn</span> descriptive_probability(event: Event) -&gt; =
&amp;<span class=3D"ot">'static</span> <span class=3D"kw">str</span> {
      <span class=3D"kw">match</span> probability(&amp;event) {
          <span class=3D"dv">1.00</span> =3D&gt; <span class=3D"st">"certai=
n"</span>,
          <span class=3D"dv">0.00</span> =3D&gt; <span class=3D"st">"imposs=
ible"</span>,
          <span class=3D"dv">0.00</span> ... <span class=3D"dv">0.25</span>=
 =3D&gt; <span class=3D"st">"very unlikely"</span>,
          <span class=3D"dv">0.25</span> ... <span class=3D"dv">0.50</span>=
 =3D&gt; <span class=3D"st">"unlikely"</span>,
          <span class=3D"dv">0.50</span> ... <span class=3D"dv">0.75</span>=
 =3D&gt; <span class=3D"st">"likely"</span>,
          <span class=3D"dv">0.75</span> ... <span class=3D"dv">1.00</span>=
 =3D&gt; <span class=3D"st">"very likely"</span>,
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      std::io::println(descriptive_probability(NewRelease));
  }</code></pre></div>
  <p>This will give us an error:</p>
  <pre><code>error: non-exhaustive patterns: `_` not covered [E0004]</code>=
</pre>
  <p>While we know that we=E2=80=99ve covered all possible cases, Rust can=
=E2=80=99t tell. It doesn=E2=80=99t know that probability is between 0.0 an=
d 1.0. So we add another case:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> Event::NewRelease;
 =20
  <span class=3D"kw">enum</span> Event {
      NewRelease,
  }
 =20
  <span class=3D"kw">fn</span> probability(_: &amp;Event) -&gt; <span class=
=3D"kw">f64</span> {
      <span class=3D"co">// real implementation would be more complex, of c=
ourse</span>
      <span class=3D"dv">0.95</span>
  }
 =20
  <span class=3D"kw">fn</span> descriptive_probability(event: Event) -&gt; =
&amp;<span class=3D"ot">'static</span> <span class=3D"kw">str</span> {
      <span class=3D"kw">match</span> probability(&amp;event) {
          <span class=3D"dv">1.00</span> =3D&gt; <span class=3D"st">"certai=
n"</span>,
          <span class=3D"dv">0.00</span> =3D&gt; <span class=3D"st">"imposs=
ible"</span>,
          <span class=3D"dv">0.00</span> ... <span class=3D"dv">0.25</span>=
 =3D&gt; <span class=3D"st">"very unlikely"</span>,
          <span class=3D"dv">0.25</span> ... <span class=3D"dv">0.50</span>=
 =3D&gt; <span class=3D"st">"unlikely"</span>,
          <span class=3D"dv">0.50</span> ... <span class=3D"dv">0.75</span>=
 =3D&gt; <span class=3D"st">"likely"</span>,
          <span class=3D"dv">0.75</span> ... <span class=3D"dv">1.00</span>=
 =3D&gt; <span class=3D"st">"very likely"</span>,
          _ =3D&gt; <span class=3D"ot">unreachable!</span>()
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, de=
scriptive_probability(NewRelease));
  }</code></pre></div>
  <p>We shouldn=E2=80=99t ever hit the <code>_</code> case, so we use the <=
code>unreachable!()</code> macro to indicate this. <code>unreachable!()</co=
de> gives a different kind of error than <code>Result</code>. Rust calls th=
ese sorts of errors <em>panics</em>.</p>
  <h3 id=3D"handling-errors-with-option-and-result">Handling errors with <c=
ode>Option</code> and <code>Result</code></h3>
  <p>The simplest way to indicate that a function may fail is to use the <c=
ode>Option&lt;T&gt;</code> type. For example, the <code>find</code> method =
on strings attempts to find a pattern in a string, and returns an <code>Opt=
ion</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> s =3D <span class=3D"st">"foo=
"</span>;
 =20
  <span class=3D"ot">assert_eq!</span>(s.find(<span class=3D"ch">'f'</span>=
), <span class=3D"kw">Some</span>(<span class=3D"dv">0</span>));
  <span class=3D"ot">assert_eq!</span>(s.find(<span class=3D"ch">'z'</span>=
), <span class=3D"kw">None</span>);</code></pre></div>
  <p>This is appropriate for the simplest of cases, but doesn=E2=80=99t giv=
e us a lot of information in the failure case. What if we wanted to know <e=
m>why</em> the function failed? For this, we can use the <code>Result&lt;T,=
 E&gt;</code> type. It looks like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> <span class=3D"kw">Result</s=
pan>&lt;T, E&gt; {
     <span class=3D"kw">Ok</span>(T),
     <span class=3D"kw">Err</span>(E)
  }</code></pre></div>
  <p>This enum is provided by Rust itself, so you don=E2=80=99t need to def=
ine it to use it in your code. The <code>Ok(T)</code> variant represents a =
success, and the <code>Err(E)</code> variant represents a failure. Returnin=
g a <code>Result</code> instead of an <code>Option</code> is recommended fo=
r all but the most trivial of situations.</p>
  <p>Here=E2=80=99s an example of using <code>Result</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>derive<span class=3D"ot">(</spa=
n>Debug<span class=3D"ot">)]</span>
  <span class=3D"kw">enum</span> Version { Version1, Version2 }
 =20
  <span class=3D"ot">#[</span>derive<span class=3D"ot">(</span>Debug<span c=
lass=3D"ot">)]</span>
  <span class=3D"kw">enum</span> ParseError { InvalidHeaderLength, InvalidV=
ersion }
 =20
  <span class=3D"kw">fn</span> parse_version(header: &amp;[<span class=3D"k=
w">u8</span>]) -&gt; <span class=3D"kw">Result</span>&lt;Version, ParseErro=
r&gt; {
      <span class=3D"kw">if</span> header.len() &lt; <span class=3D"dv">1</=
span> {
          <span class=3D"kw">return</span> <span class=3D"kw">Err</span>(Pa=
rseError::InvalidHeaderLength);
      }
      <span class=3D"kw">match</span> header[<span class=3D"dv">0</span>] {
          <span class=3D"dv">1</span> =3D&gt; <span class=3D"kw">Ok</span>(=
Version::Version1),
          <span class=3D"dv">2</span> =3D&gt; <span class=3D"kw">Ok</span>(=
Version::Version2),
          _ =3D&gt; <span class=3D"kw">Err</span>(ParseError::InvalidVersio=
n)
      }
  }
 =20
  <span class=3D"kw">let</span> version =3D parse_version(&amp;[<span class=
=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</span>,=
 <span class=3D"dv">4</span>]);
  <span class=3D"kw">match</span> version {
      <span class=3D"kw">Ok</span>(v) =3D&gt; {
          <span class=3D"ot">println!</span>(<span class=3D"st">"working wi=
th version: {:?}"</span>, v);
      }
      <span class=3D"kw">Err</span>(e) =3D&gt; {
          <span class=3D"ot">println!</span>(<span class=3D"st">"error pars=
ing header: {:?}"</span>, e);
      }
  }</code></pre></div>
  <p>This function makes use of an enum, <code>ParseError</code>, to enumer=
ate the various errors that can occur.</p>
  <h3 id=3D"non-recoverable-errors-with-panic">Non-recoverable errors with =
<code>panic!</code></h3>
  <p>In the case of an error that is unexpected and not recoverable, the <c=
ode>panic!</code> macro will induce a panic. This will crash the current th=
read, and give an error:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">panic!</span>(<span class=3D"st">"boom"<=
/span>);</code></pre></div>
  <p>gives</p>
  <pre><code>thread '&lt;main&gt;' panicked at 'boom', hello.rs:2</code></p=
re>
  <p>when you run it.</p>
  <p>Because these kinds of situations are relatively rare, use panics spar=
ingly.</p>
  <h3 id=3D"upgrading-failures-to-panics">Upgrading failures to panics</h3>
  <p>In certain circumstances, even though a function may fail, we may want=
 to treat it as a panic instead. For example, <code>io::stdin().read_line(&=
amp;mut buffer)</code> returns a <code>Result&lt;usize&gt;</code>, when the=
re is an error reading the line. This allows us to handle and possibly reco=
ver from error.</p>
  <p>If we don=E2=80=99t want to handle this error, and would rather just a=
bort the program, we can use the <code>unwrap()</code> method:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">io::stdin().read_line(&amp;<span class=3D"kw">mut</span> bu=
ffer).unwrap();</code></pre></div>
  <p><code>unwrap()</code> will <code>panic!</code> if the <code>Result</co=
de> is <code>Err</code>. This basically says =E2=80=9CGive me the value, an=
d if something goes wrong, just crash.=E2=80=9D This is less reliable than =
matching the error and attempting to recover, but is also significantly sho=
rter. Sometimes, just crashing is appropriate.</p>
  <p>There=E2=80=99s another way of doing this that=E2=80=99s a bit nicer t=
han <code>unwrap()</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 buffer =3D String::new();
  <span class=3D"kw">let</span> input =3D io::stdin().read_line(&amp;<span =
class=3D"kw">mut</span> buffer)
                         .ok()
                         .expect(<span class=3D"st">"Failed to read line"</=
span>);</code></pre></div>
  <p><code>ok()</code> converts the <code>Result</code> into an <code>Optio=
n</code>, and <code>expect()</code> does the same thing as <code>unwrap()</=
code>, but takes a message. This message is passed along to the underlying =
<code>panic!</code>, providing a better error message if the code errors.</=
p>
  <h3 id=3D"using-try">Using <code>try!</code></h3>
  <p>When writing code that calls many functions that return the <code>Resu=
lt</code> type, the error handling can be tedious. The <code>try!</code> ma=
cro hides some of the boilerplate of propagating errors up the call stack.<=
/p>
  <p>It replaces this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::fs::File;
  <span class=3D"kw">use</span> std::io;
  <span class=3D"kw">use</span> std::io::prelude::*;
 =20
  <span class=3D"kw">struct</span> Info {
      name: String,
      age: <span class=3D"kw">i32</span>,
      rating: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> write_info(info: &amp;Info) -&gt; io::<span =
class=3D"kw">Result</span>&lt;()&gt; {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> file =3D =
File::create(<span class=3D"st">"my_best_friends.txt"</span>).unwrap();
 =20
      <span class=3D"kw">if</span> <span class=3D"kw">let</span> <span clas=
s=3D"kw">Err</span>(e) =3D <span class=3D"ot">writeln!</span>(&amp;<span cl=
ass=3D"kw">mut</span> file, <span class=3D"st">"name: {}"</span>, info.name=
) {
          <span class=3D"kw">return</span> <span class=3D"kw">Err</span>(e)
      }
      <span class=3D"kw">if</span> <span class=3D"kw">let</span> <span clas=
s=3D"kw">Err</span>(e) =3D <span class=3D"ot">writeln!</span>(&amp;<span cl=
ass=3D"kw">mut</span> file, <span class=3D"st">"age: {}"</span>, info.age) =
{
          <span class=3D"kw">return</span> <span class=3D"kw">Err</span>(e)
      }
      <span class=3D"kw">if</span> <span class=3D"kw">let</span> <span clas=
s=3D"kw">Err</span>(e) =3D <span class=3D"ot">writeln!</span>(&amp;<span cl=
ass=3D"kw">mut</span> file, <span class=3D"st">"rating: {}"</span>, info.ra=
ting) {
          <span class=3D"kw">return</span> <span class=3D"kw">Err</span>(e)
      }
 =20
      <span class=3D"kw">return</span> <span class=3D"kw">Ok</span>(());
  }</code></pre></div>
  <p>With this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::fs::File;
  <span class=3D"kw">use</span> std::io;
  <span class=3D"kw">use</span> std::io::prelude::*;
 =20
  <span class=3D"kw">struct</span> Info {
      name: String,
      age: <span class=3D"kw">i32</span>,
      rating: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> write_info(info: &amp;Info) -&gt; io::<span =
class=3D"kw">Result</span>&lt;()&gt; {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> file =3D =
<span class=3D"ot">try!</span>(File::create(<span class=3D"st">"my_best_fri=
ends.txt"</span>));
 =20
      <span class=3D"ot">try!</span>(<span class=3D"ot">writeln!</span>(&am=
p;<span class=3D"kw">mut</span> file, <span class=3D"st">"name: {}"</span>,=
 info.name));
      <span class=3D"ot">try!</span>(<span class=3D"ot">writeln!</span>(&am=
p;<span class=3D"kw">mut</span> file, <span class=3D"st">"age: {}"</span>, =
info.age));
      <span class=3D"ot">try!</span>(<span class=3D"ot">writeln!</span>(&am=
p;<span class=3D"kw">mut</span> file, <span class=3D"st">"rating: {}"</span=
>, info.rating));
 =20
      <span class=3D"kw">return</span> <span class=3D"kw">Ok</span>(());
  }</code></pre></div>
  <p>Wrapping an expression in <code>try!</code> will result in the unwrapp=
ed success (<code>Ok</code>) value, unless the result is <code>Err</code>, =
in which case <code>Err</code> is returned early from the enclosing functio=
n.</p>
  <p>It=E2=80=99s worth noting that you can only use <code>try!</code> from=
 a function that returns a <code>Result</code>, which means that you cannot=
 use <code>try!</code> inside of <code>main()</code>, because <code>main()<=
/code> doesn=E2=80=99t return anything.</p>
  <p><code>try!</code> makes use of <a href=3D"http://doc.rust-lang.org/std=
/convert/trait.From.html"><code>From&lt;Error&gt;</code></a> to determine w=
hat to return in the error case.</p>
  <h2 id=3D"sec--ffi">FFI</h2>
  <h3 id=3D"introduction-1">Introduction</h3>
  <p>This guide will use the <a href=3D"https://github.com/google/snappy">s=
nappy</a> compression/decompression library as an introduction to writing b=
indings for foreign code. Rust is currently unable to call directly into a =
C++ library, but snappy includes a C interface (documented in <a href=3D"ht=
tps://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</co=
de></a>).</p>
  <p>The following is a minimal example of calling a foreign function which=
 will compile if snappy is installed:</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
  use libc::size_t;
 =20
  #[link(name =3D "snappy")]
  extern {
      fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
  }
 =20
  fn main() {
      let x =3D unsafe { snappy_max_compressed_length(100) };
      println!("max compressed length of a 100 byte buffer: {}", x);
  }</code></pre>
  <p>The <code>extern</code> block is a list of function signatures in a fo=
reign library, in this case with the platform=E2=80=99s C ABI. The <code>#[=
link(...)]</code> attribute is used to instruct the linker to link against =
the snappy library so the symbols are resolved.</p>
  <p>Foreign functions are assumed to be unsafe so calls to them need to be=
 wrapped with <code>unsafe {}</code> as a promise to the compiler that ever=
ything contained within truly is safe. C libraries often expose interfaces =
that aren=E2=80=99t thread-safe, and almost any function that takes a point=
er argument isn=E2=80=99t valid for all possible inputs since the pointer c=
ould be dangling, and raw pointers fall outside of Rust=E2=80=99s safe memo=
ry model.</p>
  <p>When declaring the argument types to a foreign function, the Rust comp=
iler can not check if the declaration is correct, so specifying it correctl=
y is part of keeping the binding correct at runtime.</p>
  <p>The <code>extern</code> block can be extended to cover the entire snap=
py API:</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
  use libc::{c_int, size_t};
 =20
  #[link(name =3D "snappy")]
  extern {
      fn snappy_compress(input: *const u8,
                         input_length: size_t,
                         compressed: *mut u8,
                         compressed_length: *mut size_t) -&gt; c_int;
      fn snappy_uncompress(compressed: *const u8,
                           compressed_length: size_t,
                           uncompressed: *mut u8,
                           uncompressed_length: *mut size_t) -&gt; c_int;
      fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
      fn snappy_uncompressed_length(compressed: *const u8,
                                    compressed_length: size_t,
                                    result: *mut size_t) -&gt; c_int;
      fn snappy_validate_compressed_buffer(compressed: *const u8,
                                           compressed_length: size_t) -&gt;=
 c_int;
  }
  # fn main() {}</code></pre>
  <h3 id=3D"creating-a-safe-interface">Creating a safe interface</h3>
  <p>The raw C API needs to be wrapped to provide memory safety and make us=
e of higher-level concepts like vectors. A library can choose to expose onl=
y the safe, high-level interface and hide the unsafe internal details.</p>
  <p>Wrapping the functions which expect buffers involves using the <code>s=
lice::raw</code> module to manipulate Rust vectors as pointers to memory. R=
ust=E2=80=99s vectors are guaranteed to be a contiguous block of memory. Th=
e length is number of elements currently contained, and the capacity is the=
 total size in elements of the allocated memory. The length is less than or=
 equal to the capacity.</p>
  <pre><code># #![feature(libc)]
  # extern crate libc;
  # use libc::{c_int, size_t};
  # unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&=
gt; c_int { 0 }
  # fn main() {}
  pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
      unsafe {
          snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size=
_t) =3D=3D 0
      }
  }</code></pre>
  <p>The <code>validate_compressed_buffer</code> wrapper above makes use of=
 an <code>unsafe</code> block, but it makes the guarantee that calling it i=
s safe for all inputs by leaving off <code>unsafe</code> from the function =
signature.</p>
  <p>The <code>snappy_compress</code> and <code>snappy_uncompress</code> fu=
nctions are more complex, since a buffer has to be allocated to hold the ou=
tput too.</p>
  <p>The <code>snappy_max_compressed_length</code> function can be used to =
allocate a vector with the maximum required capacity to hold the compressed=
 output. The vector can then be passed to the <code>snappy_compress</code> =
function as an output parameter. An output parameter is also passed to retr=
ieve the true length after compression for setting the length.</p>
  <pre><code># #![feature(libc)]
  # extern crate libc;
  # use libc::{size_t, c_int};
  # unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,
  #                           d: *mut size_t) -&gt; c_int { 0 }
  # unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }
  # fn main() {}
  pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
      unsafe {
          let srclen =3D src.len() as size_t;
          let psrc =3D src.as_ptr();
 =20
          let mut dstlen =3D snappy_max_compressed_length(srclen);
          let mut dst =3D Vec::with_capacity(dstlen as usize);
          let pdst =3D dst.as_mut_ptr();
 =20
          snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);
          dst.set_len(dstlen as usize);
          dst
      }
  }</code></pre>
  <p>Decompression is similar, because snappy stores the uncompressed size =
as part of the compression format and <code>snappy_uncompressed_length</cod=
e> will retrieve the exact buffer size required.</p>
  <pre><code># #![feature(libc)]
  # extern crate libc;
  # use libc::{size_t, c_int};
  # unsafe fn snappy_uncompress(compressed: *const u8,
  #                             compressed_length: size_t,
  #                             uncompressed: *mut u8,
  #                             uncompressed_length: *mut size_t) -&gt; c_i=
nt { 0 }
  # unsafe fn snappy_uncompressed_length(compressed: *const u8,
  #                                      compressed_length: size_t,
  #                                      result: *mut size_t) -&gt; c_int {=
 0 }
  # fn main() {}
  pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
      unsafe {
          let srclen =3D src.len() as size_t;
          let psrc =3D src.as_ptr();
 =20
          let mut dstlen: size_t =3D 0;
          snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);
 =20
          let mut dst =3D Vec::with_capacity(dstlen as usize);
          let pdst =3D dst.as_mut_ptr();
 =20
          if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) =3D=3D =
0 {
              dst.set_len(dstlen as usize);
              Some(dst)
          } else {
              None // SNAPPY_INVALID_INPUT
          }
      }
  }</code></pre>
  <p>For reference, the examples used here are also available as a <a href=
=3D"https://github.com/thestinger/rust-snappy">library on GitHub</a>.</p>
  <h3 id=3D"destructors">Destructors</h3>
  <p>Foreign libraries often hand off ownership of resources to the calling=
 code. When this occurs, we must use Rust=E2=80=99s destructors to provide =
safety and guarantee the release of these resources (especially in the case=
 of panic).</p>
  <p>For more about destructors, see the <a href=3D"http://doc.rust-lang.or=
g/std/ops/trait.Drop.html">Drop trait</a>.</p>
  <h3 id=3D"callbacks-from-c-code-to-rust-functions">Callbacks from C code =
to Rust functions</h3>
  <p>Some external libraries require the usage of callbacks to report back =
their current state or intermediate data to the caller. It is possible to p=
ass functions defined in Rust to an external library. The requirement for t=
his is that the callback function is marked as <code>extern</code> with the=
 correct calling convention to make it callable from C code.</p>
  <p>The callback function can then be sent through a registration call to =
the C library and afterwards be invoked from there.</p>
  <p>A basic example is:</p>
  <p>Rust code:</p>
  <pre><code>extern fn callback(a: i32) {
      println!("I'm called from C with value {0}", a);
  }
 =20
  #[link(name =3D "extlib")]
  extern {
     fn register_callback(cb: extern fn(i32)) -&gt; i32;
     fn trigger_callback();
  }
 =20
  fn main() {
      unsafe {
          register_callback(callback);
          trigger_callback(); // Triggers the callback
      }
  }</code></pre>
  <p>C code:</p>
  <pre><code>typedef void (*rust_callback)(int32_t);
  rust_callback cb;
 =20
  int32_t register_callback(rust_callback callback) {
      cb =3D callback;
      return 1;
  }
 =20
  void trigger_callback() {
    cb(7); // Will call callback(7) in Rust
  }</code></pre>
  <p>In this example Rust=E2=80=99s <code>main()</code> will call <code>tri=
gger_callback()</code> in C, which would, in turn, call back to <code>callb=
ack()</code> in Rust.</p>
  <h4 id=3D"targeting-callbacks-to-rust-objects">Targeting callbacks to Rus=
t objects</h4>
  <p>The former example showed how a global function can be called from C c=
ode. However it is often desired that the callback is targeted to a special=
 Rust object. This could be the object that represents the wrapper for the =
respective C object.</p>
  <p>This can be achieved by passing an unsafe pointer to the object down t=
o the C library. The C library can then include the pointer to the Rust obj=
ect in the notification. This will allow the callback to unsafely access th=
e referenced Rust object.</p>
  <p>Rust code:</p>
  <pre><code>#[repr(C)]
  struct RustObject {
      a: i32,
      // other members
  }
 =20
  extern "C" fn callback(target: *mut RustObject, a: i32) {
      println!("I'm called from C with value {0}", a);
      unsafe {
          // Update the value in RustObject with the value received from th=
e callback
          (*target).a =3D a;
      }
  }
 =20
  #[link(name =3D "extlib")]
  extern {
     fn register_callback(target: *mut RustObject,
                          cb: extern fn(*mut RustObject, i32)) -&gt; i32;
     fn trigger_callback();
  }
 =20
  fn main() {
      // Create the object that will be referenced in the callback
      let mut rust_object =3D Box::new(RustObject { a: 5 });
 =20
      unsafe {
          register_callback(&amp;mut *rust_object, callback);
          trigger_callback();
      }
  }</code></pre>
  <p>C code:</p>
  <pre><code>typedef void (*rust_callback)(void*, int32_t);
  void* cb_target;
  rust_callback cb;
 =20
  int32_t register_callback(void* callback_target, rust_callback callback) =
{
      cb_target =3D callback_target;
      cb =3D callback;
      return 1;
  }
 =20
  void trigger_callback() {
    cb(cb_target, 7); // Will call callback(&amp;rustObject, 7) in Rust
  }</code></pre>
  <h4 id=3D"asynchronous-callbacks">Asynchronous callbacks</h4>
  <p>In the previously given examples the callbacks are invoked as a direct=
 reaction to a function call to the external C library. The control over th=
e current thread is switched from Rust to C to Rust for the execution of th=
e callback, but in the end the callback is executed on the same thread that=
 called the function which triggered the callback.</p>
  <p>Things get more complicated when the external library spawns its own t=
hreads and invokes callbacks from there. In these cases access to Rust data=
 structures inside the callbacks is especially unsafe and proper synchroniz=
ation mechanisms must be used. Besides classical synchronization mechanisms=
 like mutexes, one possibility in Rust is to use channels (in <code>std::co=
mm</code>) to forward data from the C thread that invoked the callback into=
 a Rust thread.</p>
  <p>If an asynchronous callback targets a special object in the Rust addre=
ss space it is also absolutely necessary that no more callbacks are perform=
ed by the C library after the respective Rust object gets destroyed. This c=
an be achieved by unregistering the callback in the object=E2=80=99s destru=
ctor and designing the library in a way that guarantees that no callback wi=
ll be performed after deregistration.</p>
  <h3 id=3D"linking">Linking</h3>
  <p>The <code>link</code> attribute on <code>extern</code> blocks provides=
 the basic building block for instructing rustc how it will link to native =
libraries. There are two accepted forms of the link attribute today:</p>
  <ul>
  <li><code>#[link(name =3D "foo")]</code></li>
  <li><code>#[link(name =3D "foo", kind =3D "bar")]</code></li>
  </ul>
  <p>In both of these cases, <code>foo</code> is the name of the native lib=
rary that we=E2=80=99re linking to, and in the second case <code>bar</code>=
 is the type of native library that the compiler is linking to. There are c=
urrently three known types of native libraries:</p>
  <ul>
  <li>Dynamic - <code>#[link(name =3D "readline")]</code></li>
  <li>Static - <code>#[link(name =3D "my_build_dependency", kind =3D "stati=
c")]</code></li>
  <li>Frameworks - <code>#[link(name =3D "CoreFoundation", kind =3D "framew=
ork")]</code></li>
  </ul>
  <p>Note that frameworks are only available on OSX targets.</p>
  <p>The different <code>kind</code> values are meant to differentiate how =
the native library participates in linkage. From a linkage perspective, the=
 rust compiler creates two flavors of artifacts: partial (rlib/staticlib) a=
nd final (dylib/binary). Native dynamic libraries and frameworks are propag=
ated to the final artifact boundary, while static libraries are not propaga=
ted at all.</p>
  <p>A few examples of how this model can be used are:</p>
  <ul>
  <li>A native build dependency. Sometimes some C/C++ glue is needed when w=
riting some rust code, but distribution of the C/C++ code in a library form=
at is just a burden. In this case, the code will be archived into <code>lib=
foo.a</code> and then the rust crate would declare a dependency via <code>#=
[link(name =3D "foo", kind =3D   "static")]</code>.</li>
  </ul>
  <p>Regardless of the flavor of output for the crate, the native static li=
brary will be included in the output, meaning that distribution of the nati=
ve static library is not necessary.</p>
  <ul>
  <li>A normal dynamic dependency. Common system libraries (like <code>read=
line</code>) are available on a large number of systems, and often a static=
 copy of these libraries cannot be found. When this dependency is included =
in a rust crate, partial targets (like rlibs) will not link to the library,=
 but when the rlib is included in a final target (like a binary), the nativ=
e library will be linked in.</li>
  </ul>
  <p>On OSX, frameworks behave with the same semantics as a dynamic library=
.</p>
  <h3 id=3D"unsafe-blocks">Unsafe blocks</h3>
  <p>Some operations, like dereferencing unsafe pointers or calling functio=
ns that have been marked unsafe are only allowed inside unsafe blocks. Unsa=
fe blocks isolate unsafety and are a promise to the compiler that the unsaf=
ety does not leak out of the block.</p>
  <p>Unsafe functions, on the other hand, advertise it to the world. An uns=
afe function is written like this:</p>
  <pre><code>unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }</code></p=
re>
  <p>This function can only be called from an <code>unsafe</code> block or =
another <code>unsafe</code> function.</p>
  <h3 id=3D"accessing-foreign-globals">Accessing foreign globals</h3>
  <p>Foreign APIs often export a global variable which could do something l=
ike track global state. In order to access these variables, you declare the=
m in <code>extern</code> blocks with the <code>static</code> keyword:</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
 =20
  #[link(name =3D "readline")]
  extern {
      static rl_readline_version: libc::c_int;
  }
 =20
  fn main() {
      println!("You have readline version {} installed.",
               rl_readline_version as i32);
  }</code></pre>
  <p>Alternatively, you may need to alter global state provided by a foreig=
n interface. To do this, statics can be declared with <code>mut</code> so w=
e can mutate them.</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
 =20
  use std::ffi::CString;
  use std::ptr;
 =20
  #[link(name =3D "readline")]
  extern {
      static mut rl_prompt: *const libc::c_char;
  }
 =20
  fn main() {
      let prompt =3D CString::new("[my-awesome-shell] $").unwrap();
      unsafe {
          rl_prompt =3D prompt.as_ptr();
 =20
          println!("{:?}", rl_prompt);
 =20
          rl_prompt =3D ptr::null();
      }
  }</code></pre>
  <p>Note that all interaction with a <code>static mut</code> is unsafe, bo=
th reading and writing. Dealing with global mutable state requires a great =
deal of care.</p>
  <h3 id=3D"foreign-calling-conventions">Foreign calling conventions</h3>
  <p>Most foreign code exposes a C ABI, and Rust uses the platform=E2=80=99=
s C calling convention by default when calling foreign functions. Some fore=
ign functions, most notably the Windows API, use other calling conventions.=
 Rust provides a way to tell the compiler which convention to use:</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
 =20
  #[cfg(all(target_os =3D "win32", target_arch =3D "x86"))]
  #[link(name =3D "kernel32")]
  #[allow(non_snake_case)]
  extern "stdcall" {
      fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_=
int;
  }
  # fn main() { }</code></pre>
  <p>This applies to the entire <code>extern</code> block. The list of supp=
orted ABI constraints are:</p>
  <ul>
  <li><code>stdcall</code></li>
  <li><code>aapcs</code></li>
  <li><code>cdecl</code></li>
  <li><code>fastcall</code></li>
  <li><code>Rust</code></li>
  <li><code>rust-intrinsic</code></li>
  <li><code>system</code></li>
  <li><code>C</code></li>
  <li><code>win64</code></li>
  </ul>
  <p>Most of the abis in this list are self-explanatory, but the <code>syst=
em</code> abi may seem a little odd. This constraint selects whatever the a=
ppropriate ABI is for interoperating with the target=E2=80=99s libraries. F=
or example, on win32 with a x86 architecture, this means that the abi used =
would be <code>stdcall</code>. On x86_64, however, windows uses the <code>C=
</code> calling convention, so <code>C</code> would be used. This means tha=
t in our previous example, we could have used <code>extern "system" { ... }=
</code> to define a block for all windows systems, not just x86 ones.</p>
  <h3 id=3D"interoperability-with-foreign-code">Interoperability with forei=
gn code</h3>
  <p>Rust guarantees that the layout of a <code>struct</code> is compatible=
 with the platform=E2=80=99s representation in C only if the <code>#[repr(C=
)]</code> attribute is applied to it. <code>#[repr(C, packed)]</code> can b=
e used to lay out struct members without padding. <code>#[repr(C)]</code> c=
an also be applied to an enum.</p>
  <p>Rust=E2=80=99s owned boxes (<code>Box&lt;T&gt;</code>) use non-nullabl=
e pointers as handles which point to the contained object. However, they sh=
ould not be manually created because they are managed by internal allocator=
s. References can safely be assumed to be non-nullable pointers directly to=
 the type. However, breaking the borrow checking or mutability rules is not=
 guaranteed to be safe, so prefer using raw pointers (<code>*</code>) if th=
at=E2=80=99s needed because the compiler can=E2=80=99t make as many assumpt=
ions about them.</p>
  <p>Vectors and strings share the same basic memory layout, and utilities =
are available in the <code>vec</code> and <code>str</code> modules for work=
ing with C APIs. However, strings are not terminated with <code>\0</code>. =
If you need a NUL-terminated string for interoperability with C, you should=
 use the <code>CString</code> type in the <code>std::ffi</code> module.</p>
  <p>The standard library includes type aliases and function definitions fo=
r the C standard library in the <code>libc</code> module, and Rust links ag=
ainst <code>libc</code> and <code>libm</code> by default.</p>
  <h3 id=3D"the-nullable-pointer-optimization">The =E2=80=9Cnullable pointe=
r optimization=E2=80=9D</h3>
  <p>Certain types are defined to not be <code>null</code>. This includes r=
eferences (<code>&amp;T</code>, <code>&amp;mut T</code>), boxes (<code>Box&=
lt;T&gt;</code>), and function pointers (<code>extern "abi" fn()</code>). W=
hen interfacing with C, pointers that might be null are often used. As a sp=
ecial case, a generic <code>enum</code> that contains exactly two variants,=
 one of which contains no data and the other containing a single field, is =
eligible for the =E2=80=9Cnullable pointer optimization=E2=80=9D. When such=
 an enum is instantiated with one of the non-nullable types, it is represen=
ted as a single pointer, and the non-data variant is represented as the nul=
l pointer. So <code>Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;</code> i=
s how one represents a nullable function pointer using the C ABI.</p>
  <h3 id=3D"calling-rust-code-from-c">Calling Rust code from C</h3>
  <p>You may wish to compile Rust code in a way so that it can be called fr=
om C. This is fairly easy, but requires a few things:</p>
  <pre><code>#[no_mangle]
  pub extern fn hello_rust() -&gt; *const u8 {
      "Hello, world!\0".as_ptr()
  }
  # fn main() {}</code></pre>
  <p>The <code>extern</code> makes this function adhere to the C calling co=
nvention, as discussed above in =E2=80=9C<a href=3D"https://killercup.githu=
b.io/trpl-ebook/ffi.html#foreign-calling-conventions">Foreign Calling Conve=
ntions</a>=E2=80=9D. The <code>no_mangle</code> attribute turns off Rust=E2=
=80=99s name mangling, so that it is easier to link to.</p>
  <h2 id=3D"sec--borrow-and-asref">Borrow and AsRef</h2>
  <p>The <a href=3D"http://doc.rust-lang.org/std/borrow/trait.Borrow.html">=
<code>Borrow</code></a> and <a href=3D"http://doc.rust-lang.org/std/convert=
/trait.AsRef.html"><code>AsRef</code></a> traits are very similar, but diff=
erent. Here=E2=80=99s a quick refresher on what these two traits mean.</p>
  <h3 id=3D"borrow">Borrow</h3>
  <p>The <code>Borrow</code> trait is used when you=E2=80=99re writing a da=
tastructure, and you want to use either an owned or borrowed type as synony=
mous for some purpose.</p>
  <p>For example, <a href=3D"http://doc.rust-lang.org/std/collections/struc=
t.HashMap.html"><code>HashMap</code></a> has a <a href=3D"http://doc.rust-l=
ang.org/std/collections/struct.HashMap.html#method.get"><code>get</code> me=
thod</a> which uses <code>Borrow</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> get&lt;Q: ?<span class=3D"kw">=
Sized</span>&gt;(&amp;<span class=3D"kw">self</span>, k: &amp;Q) -&gt; <spa=
n class=3D"kw">Option</span>&lt;&amp;V&gt;
      where K: Borrow&lt;Q&gt;,
            Q: Hash + <span class=3D"kw">Eq</span></code></pre></div>
  <p>This signature is pretty complicated. The <code>K</code> parameter is =
what we=E2=80=99re interested in here. It refers to a parameter of the <cod=
e>HashMap</code> itself:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> HashMap&lt;K, V, S =3D Ran=
domState&gt; {</code></pre></div>
  <p>The <code>K</code> parameter is the type of <em>key</em> the <code>Has=
hMap</code> uses. So, looking at the signature of <code>get()</code> again,=
 we can use <code>get()</code> when the key implements <code>Borrow&lt;Q&gt=
;</code>. That way, we can make a <code>HashMap</code> which uses <code>Str=
ing</code> keys, but use <code>&amp;str</code>s when we=E2=80=99re searchin=
g:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::collections::HashMap;
 =20
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> map =3D HashM=
ap::new();
  map.insert(<span class=3D"st">"Foo"</span>.to_string(), <span class=3D"dv=
">42</span>);
 =20
  <span class=3D"ot">assert_eq!</span>(map.get(<span class=3D"st">"Foo"</sp=
an>), <span class=3D"kw">Some</span>(&amp;<span class=3D"dv">42</span>));</=
code></pre></div>
  <p>This is because the standard library has <code>impl Borrow&lt;str&gt; =
for String</code>.</p>
  <p>For most types, when you want to take an owned or borrowed type, a <co=
de>&amp;T</code> is enough. But one area where <code>Borrow</code> is effec=
tive is when there=E2=80=99s more than one kind of borrowed value. Slices a=
re an area where this is especially true: you can have both an <code>&amp;[=
T]</code> or a <code>&amp;mut [T]</code>. If we wanted to accept both of th=
ese types, <code>Borrow</code> is up for it:</p>
  <pre><code>use std::borrow::Borrow;
  use std::fmt::Display;
 =20
  fn foo&lt;T: Borrow&lt;i32&gt; + Display&gt;(a: T) {
      println!("a is borrowed: {}", a);
  }
 =20
  let mut i =3D 5;
 =20
  foo(&amp;i);
  foo(&amp;mut i);</code></pre>
  <p>This will print out <code>a is borrowed: 5</code> twice.</p>
  <h3 id=3D"asref">AsRef</h3>
  <p>The <code>AsRef</code> trait is a conversion trait. It=E2=80=99s used =
for converting some value to a reference in generic code. Like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> s =3D <span class=3D"st">"Hel=
lo"</span>.to_string();
 =20
  <span class=3D"kw">fn</span> foo&lt;T: AsRef&lt;<span class=3D"kw">str</s=
pan>&gt;&gt;(s: T) {
      <span class=3D"kw">let</span> slice =3D s.as_ref();
  }</code></pre></div>
  <h3 id=3D"which-should-i-use">Which should I use?</h3>
  <p>We can see how they=E2=80=99re kind of the same: they both deal with o=
wned and borrowed versions of some type. However, they=E2=80=99re a bit dif=
ferent.</p>
  <p>Choose <code>Borrow</code> when you want to abstract over different ki=
nds of borrowing, or when you=E2=80=99re building a datastructure that trea=
ts owned and borrowed values in equivalent ways, such as hashing and compar=
ison.</p>
  <p>Choose <code>AsRef</code> when you want to convert something to a refe=
rence directly, and you=E2=80=99re writing generic code.</p>
  <h2 id=3D"sec--release-channels">Release Channels</h2>
  <p>The Rust project uses a concept called =E2=80=98release channels=E2=80=
=99 to manage releases. It=E2=80=99s important to understand this process t=
o choose which version of Rust your project should use.</p>
  <h3 id=3D"overview">Overview</h3>
  <p>There are three channels for Rust releases:</p>
  <ul>
  <li>Nightly</li>
  <li>Beta</li>
  <li>Stable</li>
  </ul>
  <p>New nightly releases are created once a day. Every six weeks, the late=
st nightly release is promoted to =E2=80=98Beta=E2=80=99. At that point, it=
 will only receive patches to fix serious errors. Six weeks later, the beta=
 is promoted to =E2=80=98Stable=E2=80=99, and becomes the next release of <=
code>1.x</code>.</p>
  <p>This process happens in parallel. So every six weeks, on the same day,=
 nightly goes to beta, beta goes to stable. When <code>1.x</code> is releas=
ed, at the same time, <code>1.(x + 1)-beta</code> is released, and the nigh=
tly becomes the first version of <code>1.(x + 2)-nightly</code>.</p>
  <h3 id=3D"choosing-a-version">Choosing a version</h3>
  <p>Generally speaking, unless you have a specific reason, you should be u=
sing the stable release channel. These releases are intended for a general =
audience.</p>
  <p>However, depending on your interest in Rust, you may choose to use nig=
htly instead. The basic tradeoff is this: in the nightly channel, you can u=
se unstable, new Rust features. However, unstable features are subject to c=
hange, and so any new nightly release may break your code. If you use the s=
table release, you cannot use experimental features, but the next release o=
f Rust will not cause significant issues through breaking changes.</p>
  <h3 id=3D"helping-the-ecosystem-through-ci">Helping the ecosystem through=
 CI</h3>
  <p>What about beta? We encourage all Rust users who use the stable releas=
e channel to also test against the beta channel in their continuous integra=
tion systems. This will help alert the team in case there=E2=80=99s an acci=
dental regression.</p>
  <p>Additionally, testing against nightly can catch regressions even soone=
r, and so if you don=E2=80=99t mind a third build, we=E2=80=99d appreciate =
testing against all channels.</p>
  <h1 id=3D"sec--syntax-and-semantics">Syntax and Semantics</h1>
  <p>This section breaks Rust down into small chunks, one for each concept.=
</p>
  <p>If you=E2=80=99d like to learn Rust from the bottom up, reading this i=
n order is a great way to do that.</p>
  <p>These sections also form a reference for each concept, so if you=E2=80=
=99re reading another tutorial and find something confusing, you can find i=
t explained somewhere in here.</p>
  <h2 id=3D"sec--variable-bindings">Variable Bindings</h2>
  <p>Virtually every non-=E2=80=98Hello World=E2=80=99 Rust program uses <e=
m>variable bindings</em>. They look like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">5</span>;
  }</code></pre></div>
  <p>Putting <code>fn main() {</code> in each example is a bit tedious, so =
we=E2=80=99ll leave that out in the future. If you=E2=80=99re following alo=
ng, make sure to edit your <code>main()</code> function, rather than leavin=
g it off. Otherwise, you=E2=80=99ll get an error.</p>
  <p>In many languages, this is called a <em>variable</em>, but Rust=E2=80=
=99s variable bindings have a few tricks up their sleeves. For example the =
left-hand side of a <code>let</code> expression is a =E2=80=98<a href=3D"ht=
tps://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--patterns">pa=
ttern</a>=E2=80=99, not just a variable name. This means we can do things l=
ike:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> (x, y) =3D (<span class=3D"dv=
">1</span>, <span class=3D"dv">2</span>);</code></pre></div>
  <p>After this expression is evaluated, <code>x</code> will be one, and <c=
ode>y</code> will be two. Patterns are really powerful, and have <a href=3D=
"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--patterns"=
>their own section</a> in the book. We don=E2=80=99t need those features fo=
r now, so we=E2=80=99ll just keep this in the back of our minds as we go fo=
rward.</p>
  <p>Rust is a statically typed language, which means that we specify our t=
ypes up front, and they=E2=80=99re checked at compile time. So why does our=
 first example compile? Well, Rust has this thing called =E2=80=98type infe=
rence=E2=80=99. If it can figure out what the type of something is, Rust do=
esn=E2=80=99t require you to actually type it out.</p>
  <p>We can add the type if we want to, though. Types come after a colon (<=
code>:</code>):</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: <span class=3D"kw">i32</sp=
an> =3D <span class=3D"dv">5</span>;</code></pre></div>
  <p>If I asked you to read this out loud to the rest of the class, you=E2=
=80=99d say =E2=80=9C<code>x</code> is a binding with the type <code>i32</c=
ode> and the value <code>five</code>.=E2=80=9D</p>
  <p>In this case we chose to represent <code>x</code> as a 32-bit signed i=
nteger. Rust has many different primitive integer types. They begin with <c=
ode>i</code> for signed integers and <code>u</code> for unsigned integers. =
The possible integer sizes are 8, 16, 32, and 64 bits.</p>
  <p>In future examples, we may annotate the type in a comment. The example=
s will look like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">5</span>; <spa=
n class=3D"co">// x: i32</span>
  }</code></pre></div>
  <p>Note the similarities between this annotation and the syntax you use w=
ith <code>let</code>. Including these kinds of comments is not idiomatic Ru=
st, but we=E2=80=99ll occasionally include them to help you understand what=
 the types that Rust infers are.</p>
  <p>By default, bindings are <em>immutable</em>. This code will not compil=
e:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
  x =3D <span class=3D"dv">10</span>;</code></pre></div>
  <p>It will give you this error:</p>
  <pre><code>error: re-assignment of immutable variable `x`
       x =3D 10;
       ^~~~~~~</code></pre>
  <p>If you want a binding to be mutable, you can use <code>mut</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>; <span class=3D"co">// mut x: i32</span>
  x =3D <span class=3D"dv">10</span>;</code></pre></div>
  <p>There is no single reason that bindings are immutable by default, but =
we can think about it through one of Rust=E2=80=99s primary focuses: safety=
. If you forget to say <code>mut</code>, the compiler will catch it, and le=
t you know that you have mutated something you may not have intended to mut=
ate. If bindings were mutable by default, the compiler would not be able to=
 tell you this. If you <em>did</em> intend mutation, then the solution is q=
uite easy: add <code>mut</code>.</p>
  <p>There are other good reasons to avoid mutable state when possible, but=
 they=E2=80=99re out of the scope of this guide. In general, you can often =
avoid explicit mutation, and so it is preferable in Rust. That said, someti=
mes, mutation is what you need, so it=E2=80=99s not verboten.</p>
  <p>Let=E2=80=99s get back to bindings. Rust variable bindings have one mo=
re aspect that differs from other languages: bindings are required to be in=
itialized with a value before you=E2=80=99re allowed to use them.</p>
  <p>Let=E2=80=99s try it out. Change your <code>src/main.rs</code> file to=
 look like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x: <span class=3D"kw">i32</span>;
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello world!"<=
/span>);
  }</code></pre></div>
  <p>You can use <code>cargo build</code> on the command line to build it. =
You=E2=80=99ll get a warning, but it will still print =E2=80=9CHello, world=
!=E2=80=9D:</p>
  <pre><code>   Compiling hello_world v0.0.1 (file:///home/you/projects/hel=
lo_world)
  src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variab=
le)]
     on by default
  src/main.rs:2     let x: i32;
                        ^</code></pre>
  <p>Rust warns us that we never use the variable binding, but since we nev=
er use it, no harm, no foul. Things change if we try to actually use this <=
code>x</code>, however. Let=E2=80=99s do that. Change your program to look =
like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x: <span class=3D"kw">i32</span>;
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The value of x=
 is: {}"</span>, x);
  }</code></pre></div>
  <p>And try to build it. You=E2=80=99ll get an error:</p>
  <pre><code>$ cargo build
     Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
  src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
  src/main.rs:4     println!("The value of x is: {}", x);
                                                      ^
  note: in expansion of format_args!
  &lt;std macros&gt;:2:23: 2:77 note: expansion site
  &lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
  src/main.rs:4:5: 4:42 note: expansion site
  error: aborting due to previous error
  Could not compile `hello_world`.</code></pre>
  <p>Rust will not let us use a value that has not been initialized. Next, =
let=E2=80=99s talk about this stuff we=E2=80=99ve added to <code>println!</=
code>.</p>
  <p>If you include two curly braces (<code>{}</code>, some call them moust=
aches=E2=80=A6) in your string to print, Rust will interpret this as a requ=
est to interpolate some sort of value. <em>String interpolation</em> is a c=
omputer science term that means =E2=80=9Cstick in the middle of a string.=
=E2=80=9D We add a comma, and then <code>x</code>, to indicate that we want=
 <code>x</code> to be the value we=E2=80=99re interpolating. The comma is u=
sed to separate arguments we pass to functions and macros, if you=E2=80=99r=
e passing more than one.</p>
  <p>When you just use the curly braces, Rust will attempt to display the v=
alue in a meaningful way by checking out its type. If you want to specify t=
he format in a more detailed manner, there are a <a href=3D"http://doc.rust=
-lang.org/std/fmt/index.html">wide number of options available</a>. For now=
, we=E2=80=99ll just stick to the default: integers aren=E2=80=99t very com=
plicated to print.</p>
  <h2 id=3D"sec--functions">Functions</h2>
  <p>Every Rust program has at least one function, the <code>main</code> fu=
nction:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
  }</code></pre></div>
  <p>This is the simplest possible function declaration. As we mentioned be=
fore, <code>fn</code> says =E2=80=98this is a function=E2=80=99, followed b=
y the name, some parentheses because this function takes no arguments, and =
then some curly braces to indicate the body. Here=E2=80=99s a function name=
d <code>foo</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo() {
  }</code></pre></div>
  <p>So, what about taking arguments? Here=E2=80=99s a function that prints=
 a number:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> print_number(x: <span class=3D=
"kw">i32</span>) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"x is: {}"</spa=
n>, x);
  }</code></pre></div>
  <p>Here=E2=80=99s a complete program that uses <code>print_number</code>:=
</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      print_number(<span class=3D"dv">5</span>);
  }
 =20
  <span class=3D"kw">fn</span> print_number(x: <span class=3D"kw">i32</span=
>) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"x is: {}"</spa=
n>, x);
  }</code></pre></div>
  <p>As you can see, function arguments work very similar to <code>let</cod=
e> declarations: you add a type to the argument name, after a colon.</p>
  <p>Here=E2=80=99s a complete program that adds two numbers together and p=
rints them:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      print_sum(<span class=3D"dv">5</span>, <span class=3D"dv">6</span>);
  }
 =20
  <span class=3D"kw">fn</span> print_sum(x: <span class=3D"kw">i32</span>, =
y: <span class=3D"kw">i32</span>) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"sum is: {}"</s=
pan>, x + y);
  }</code></pre></div>
  <p>You separate arguments with a comma, both when you call the function, =
as well as when you declare it.</p>
  <p>Unlike <code>let</code>, you <em>must</em> declare the types of functi=
on arguments. This does not work:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> print_sum(x, y) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"sum is: {}"</s=
pan>, x + y);
  }</code></pre></div>
  <p>You get this error:</p>
  <pre><code>expected one of `!`, `:`, or `@`, found `)`
  fn print_number(x, y) {</code></pre>
  <p>This is a deliberate design decision. While full-program inference is =
possible, languages which have it, like Haskell, often suggest that documen=
ting your types explicitly is a best-practice. We agree that forcing functi=
ons to declare types while allowing for inference inside of function bodies=
 is a wonderful sweet spot between full inference and no inference.</p>
  <p>What about returning a value? Here=E2=80=99s a function that adds one =
to an integer:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> add_one(x: <span class=3D"kw">=
i32</span>) -&gt; <span class=3D"kw">i32</span> {
      x + <span class=3D"dv">1</span>
  }</code></pre></div>
  <p>Rust functions return exactly one value, and you declare the type afte=
r an =E2=80=98arrow=E2=80=99, which is a dash (<code>-</code>) followed by =
a greater-than sign (<code>&gt;</code>). The last line of a function determ=
ines what it returns. You=E2=80=99ll note the lack of a semicolon here. If =
we added it in:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> add_one(x: <span class=3D"kw">=
i32</span>) -&gt; <span class=3D"kw">i32</span> {
      x + <span class=3D"dv">1</span>;
  }</code></pre></div>
  <p>We would get an error:</p>
  <pre><code>error: not all control paths return a value
  fn add_one(x: i32) -&gt; i32 {
       x + 1;
  }
 =20
  help: consider removing this semicolon:
       x + 1;
            ^</code></pre>
  <p>This reveals two interesting things about Rust: it is an expression-ba=
sed language, and semicolons are different from semicolons in other =E2=80=
=98curly brace and semicolon=E2=80=99-based languages. These two things are=
 related.</p>
  <h4 id=3D"expressions-vs.statements">Expressions vs.&nbsp;Statements</h4>
  <p>Rust is primarily an expression-based language. There are only two kin=
ds of statements, and everything else is an expression.</p>
  <p>So what=E2=80=99s the difference? Expressions return a value, and stat=
ements do not. That=E2=80=99s why we end up with =E2=80=98not all control p=
aths return a value=E2=80=99 here: the statement <code>x + 1;</code> doesn=
=E2=80=99t return a value. There are two kinds of statements in Rust: =E2=
=80=98declaration statements=E2=80=99 and =E2=80=98expression statements=E2=
=80=99. Everything else is an expression. Let=E2=80=99s talk about declarat=
ion statements first.</p>
  <p>In some languages, variable bindings can be written as expressions, no=
t just statements. Like Ruby:</p>
  <pre><code>x =3D y =3D 5</code></pre>
  <p>In Rust, however, using <code>let</code> to introduce a binding is <em=
>not</em> an expression. The following will produce a compile-time error:</=
p>
  <pre><code>let x =3D (let y =3D 5); // expected identifier, found keyword=
 `let`</code></pre>
  <p>The compiler is telling us here that it was expecting to see the begin=
ning of an expression, and a <code>let</code> can only begin a statement, n=
ot an expression.</p>
  <p>Note that assigning to an already-bound variable (e.g. <code>y =3D 5</=
code>) is still an expression, although its value is not particularly usefu=
l. Unlike other languages where an assignment evaluates to the assigned val=
ue (e.g. <code>5</code> in the previous example), in Rust the value of an a=
ssignment is an empty tuple <code>()</code>:</p>
  <pre><code>let mut y =3D 5;
 =20
  let x =3D (y =3D 6);  // x has the value `()`, not `6`</code></pre>
  <p>The second kind of statement in Rust is the <em>expression statement</=
em>. Its purpose is to turn any expression into a statement. In practical t=
erms, Rust=E2=80=99s grammar expects statements to follow other statements.=
 This means that you use semicolons to separate expressions from each other=
. This means that Rust looks a lot like most other languages that require y=
ou to use semicolons at the end of every line, and you will see semicolons =
at the end of almost every line of Rust code you see.</p>
  <p>What is this exception that makes us say =E2=80=9Calmost=E2=80=9D? You=
 saw it already, in this code:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> add_one(x: <span class=3D"kw">=
i32</span>) -&gt; <span class=3D"kw">i32</span> {
      x + <span class=3D"dv">1</span>
  }</code></pre></div>
  <p>Our function claims to return an <code>i32</code>, but with a semicolo=
n, it would return <code>()</code> instead. Rust realizes this probably isn=
=E2=80=99t what we want, and suggests removing the semicolon in the error w=
e saw before.</p>
  <h4 id=3D"early-returns">Early returns</h4>
  <p>But what about early returns? Rust does have a keyword for that, <code=
>return</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(x: <span class=3D"kw">i32<=
/span>) -&gt; <span class=3D"kw">i32</span> {
      <span class=3D"kw">return</span> x;
 =20
      <span class=3D"co">// we never run this code!</span>
      x + <span class=3D"dv">1</span>
  }</code></pre></div>
  <p>Using a <code>return</code> as the last line of a function works, but =
is considered poor style:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(x: <span class=3D"kw">i32<=
/span>) -&gt; <span class=3D"kw">i32</span> {
      <span class=3D"kw">return</span> x + <span class=3D"dv">1</span>;
  }</code></pre></div>
  <p>The previous definition without <code>return</code> may look a bit str=
ange if you haven=E2=80=99t worked in an expression-based language before, =
but it becomes intuitive over time.</p>
  <h4 id=3D"diverging-functions">Diverging functions</h4>
  <p>Rust has some special syntax for =E2=80=98diverging functions=E2=80=99=
, which are functions that do not return:</p>
  <pre><code>fn diverges() -&gt; ! {
      panic!("This function never returns!");
  }</code></pre>
  <p><code>panic!</code> is a macro, similar to <code>println!()</code> tha=
t we=E2=80=99ve already seen. Unlike <code>println!()</code>, <code>panic!(=
)</code> causes the current thread of execution to crash with the given mes=
sage.</p>
  <p>Because this function will cause a crash, it will never return, and so=
 it has the type =E2=80=98<code>!</code>=E2=80=99, which is read =E2=80=98d=
iverges=E2=80=99. A diverging function can be used as any type:</p>
  <pre><code># fn diverges() -&gt; ! {
  #    panic!("This function never returns!");
  # }
  let x: i32 =3D diverges();
  let x: String =3D diverges();</code></pre>
  <h2 id=3D"sec--primitive-types">Primitive Types</h2>
  <p>The Rust language has a number of types that are considered =E2=80=98p=
rimitive=E2=80=99. This means that they=E2=80=99re built-in to the language=
. Rust is structured in such a way that the standard library also provides =
a number of useful types built on top of these ones, as well, but these are=
 the most primitive.</p>
  <h3 id=3D"booleans">Booleans</h3>
  <p>Rust has a built in boolean type, named <code>bool</code>. It has two =
values, <code>true</code> and <code>false</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"kw">true=
</span>;
 =20
  <span class=3D"kw">let</span> y: <span class=3D"kw">bool</span> =3D <span=
 class=3D"kw">false</span>;</code></pre></div>
  <p>A common use of booleans is in <a href=3D"https://killercup.github.io/=
trpl-ebook/trpl-2015-05-13.html#sec--if"><code>if</code> conditionals</a>.<=
/p>
  <p>You can find more documentation for <code>bool</code>s <a href=3D"http=
://doc.rust-lang.org/std/primitive.bool.html">in the standard library docum=
entation</a>.</p>
  <h3 id=3D"char"><code>char</code></h3>
  <p>The <code>char</code> type represents a single Unicode scalar value. Y=
ou can create <code>char</code>s with a single tick: (<code>'</code>)</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"ch">'x'<=
/span>;
  <span class=3D"kw">let</span> two_hearts =3D <span class=3D"ch">'=F0=9F=
=92=95'</span>;</code></pre></div>
  <p>Unlike some other languages, this means that Rust=E2=80=99s <code>char=
</code> is not a single byte, but four.</p>
  <p>You can find more documentation for <code>char</code>s <a href=3D"http=
://doc.rust-lang.org/std/primitive.char.html">in the standard library docum=
entation</a>.</p>
  <h3 id=3D"numeric-types">Numeric types</h3>
  <p>Rust has a variety of numeric types in a few categories: signed and un=
signed, fixed and variable, floating-point and integer.</p>
  <p>These types consist of two parts: the category, and the size. For exam=
ple, <code>u16</code> is an unsigned type with sixteen bits of size. More b=
its lets you have bigger numbers.</p>
  <p>If a number literal has nothing to cause its type to be inferred, it d=
efaults:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">42</=
span>; <span class=3D"co">// x has type i32</span>
 =20
  <span class=3D"kw">let</span> y =3D <span class=3D"dv">1.0</span>; <span =
class=3D"co">// y has type f64</span></code></pre></div>
  <p>Here=E2=80=99s a list of the different numeric types, with links to th=
eir documentation in the standard library:</p>
  <ul>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.i8.html">i8</a></li=
>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.i16.html">i16</a></=
li>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.i32.html">i32</a></=
li>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.i64.html">i64</a></=
li>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.u8.html">u8</a></li=
>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.u16.html">u16</a></=
li>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.u32.html">u32</a></=
li>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.u64.html">u64</a></=
li>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.isize.html">isize</=
a></li>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.usize.html">usize</=
a></li>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.f32.html">f32</a></=
li>
  <li><a href=3D"http://doc.rust-lang.org/std/primitive.f64.html">f64</a></=
li>
  </ul>
  <p>Let=E2=80=99s go over them by category:</p>
  <h4 id=3D"signed-and-unsigned">Signed and Unsigned</h4>
  <p>Integer types come in two varieties: signed and unsigned. To understan=
d the difference, let=E2=80=99s consider a number with four bits of size. A=
 signed, four-bit number would let you store numbers from <code>-8</code> t=
o <code>+7</code>. Signed numbers use =E2=80=9Ctwo=E2=80=99s complement rep=
resentation=E2=80=9D. An unsigned four bit number, since it does not need t=
o store negatives, can store values from <code>0</code> to <code>+15</code>=
.</p>
  <p>Unsigned types use a <code>u</code> for their category, and signed typ=
es use <code>i</code>. The <code>i</code> is for =E2=80=98integer=E2=80=99.=
 So <code>u8</code> is an eight-bit unsigned number, and <code>i8</code> is=
 an eight-bit signed number.</p>
  <h4 id=3D"fixed-size-types">Fixed size types</h4>
  <p>Fixed size types have a specific number of bits in their representatio=
n. Valid bit sizes are <code>8</code>, <code>16</code>, <code>32</code>, an=
d <code>64</code>. So, <code>u32</code> is an unsigned, 32-bit integer, and=
 <code>i64</code> is a signed, 64-bit integer.</p>
  <h4 id=3D"variable-sized-types">Variable sized types</h4>
  <p>Rust also provides types whose size depends on the size of a pointer o=
f the underlying machine. These types have =E2=80=98size=E2=80=99 as the ca=
tegory, and come in signed and unsigned varieties. This makes for two types=
: <code>isize</code> and <code>usize</code>.</p>
  <h4 id=3D"floating-point-types">Floating-point types</h4>
  <p>Rust also has two floating point types: <code>f32</code> and <code>f64=
</code>. These correspond to IEEE-754 single and double precision numbers.<=
/p>
  <h3 id=3D"arrays">Arrays</h3>
  <p>Like many programming languages, Rust has list types to represent a se=
quence of things. The most basic is the <em>array</em>, a fixed-size list o=
f elements of the same type. By default, arrays are immutable.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> a =3D [<span class=3D"dv">1</=
span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</span>]; <span cla=
ss=3D"co">// a: [i32; 3]</span>
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> m =3D [<span =
class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</s=
pan>]; <span class=3D"co">// m: [i32; 3]</span></code></pre></div>
  <p>Arrays have type <code>[T; N]</code>. We=E2=80=99ll talk about this <c=
ode>T</code> notation <a href=3D"https://killercup.github.io/trpl-ebook/trp=
l-2015-05-13.html#sec--generics">in the generics section</a>. The <code>N</=
code> is a compile-time constant, for the length of the array.</p>
  <p>There=E2=80=99s a shorthand for initializing each element of an array =
to the same value. In this example, each element of <code>a</code> will be =
initialized to <code>0</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> a =3D [<span class=3D"dv">0</=
span>; <span class=3D"dv">20</span>]; <span class=3D"co">// a: [i32; 20]</s=
pan></code></pre></div>
  <p>You can get the number of elements in an array <code>a</code> with <co=
de>a.len()</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> a =3D [<span class=3D"dv">1</=
span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</span>];
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"a has {} elements"=
</span>, a.len());</code></pre></div>
  <p>You can access a particular element of an array with <em>subscript not=
ation</em>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> names =3D [<span class=3D"st"=
>"Graydon"</span>, <span class=3D"st">"Brian"</span>, <span class=3D"st">"N=
iko"</span>]; <span class=3D"co">// names: [&amp;str; 3]</span>
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"The second name is=
: {}"</span>, names[<span class=3D"dv">1</span>]);</code></pre></div>
  <p>Subscripts start at zero, like in most programming languages, so the f=
irst name is <code>names[0]</code> and the second name is <code>names[1]</c=
ode>. The above example prints <code>The second name is: Brian</code>. If y=
ou try to use a subscript that is not in the array, you will get an error: =
array access is bounds-checked at run-time. Such errant access is the sourc=
e of many bugs in other systems programming languages.</p>
  <p>You can find more documentation for <code>array</code>s <a href=3D"htt=
p://doc.rust-lang.org/std/primitive.array.html">in the standard library doc=
umentation</a>.</p>
  <h3 id=3D"slices">Slices</h3>
  <p>A =E2=80=98slice=E2=80=99 is a reference to (or =E2=80=9Cview=E2=80=9D=
 into) another data structure. They are useful for allowing safe, efficient=
 access to a portion of an array without copying. For example, you might wa=
nt to reference just one line of a file read into memory. By nature, a slic=
e is not created directly, but from an existing variable. Slices have a len=
gth, can be mutable or not, and in many ways behave like arrays:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> a =3D [<span class=3D"dv">0</=
span>, <span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span clas=
s=3D"dv">3</span>, <span class=3D"dv">4</span>];
  <span class=3D"kw">let</span> middle =3D &amp;a[<span class=3D"dv">1.</sp=
an>.<span class=3D"dv">4</span>]; <span class=3D"co">// A slice of a: just =
the elements 1, 2, and 3</span>
  <span class=3D"kw">let</span> complete =3D &amp;a[..]; <span class=3D"co"=
>// A slice containing all of the elements in a</span></code></pre></div>
  <p>Slices have type <code>&amp;[T]</code>. We=E2=80=99ll talk about that =
<code>T</code> when we cover <a href=3D"https://killercup.github.io/trpl-eb=
ook/trpl-2015-05-13.html#sec--generics">generics</a>.</p>
  <p>You can find more documentation for slices <a href=3D"http://doc.rust-=
lang.org/std/primitive.slice.html">in the standard library documentation</a=
>.</p>
  <h3 id=3D"str"><code>str</code></h3>
  <p>Rust=E2=80=99s <code>str</code> type is the most primitive string type=
. As an <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.h=
tml#sec--unsized-types">unsized type</a>, it=E2=80=99s not very useful by i=
tself, but becomes useful when placed behind a reference, like <a href=3D"h=
ttps://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--strings"><c=
ode>&amp;str</code></a>. As such, we=E2=80=99ll just leave it at that.</p>
  <p>You can find more documentation for <code>str</code> <a href=3D"http:/=
/doc.rust-lang.org/std/primitive.str.html">in the standard library document=
ation</a>.</p>
  <h3 id=3D"tuples">Tuples</h3>
  <p>A tuple is an ordered list of fixed size. Like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D (<span class=3D"dv">1</=
span>, <span class=3D"st">"hello"</span>);</code></pre></div>
  <p>The parentheses and commas form this two-length tuple. Here=E2=80=99s =
the same code, but with the type annotated:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: (<span class=3D"kw">i32</s=
pan>, &amp;<span class=3D"kw">str</span>) =3D (<span class=3D"dv">1</span>,=
 <span class=3D"st">"hello"</span>);</code></pre></div>
  <p>As you can see, the type of a tuple looks just like the tuple, but wit=
h each position having a type name rather than the value. Careful readers w=
ill also note that tuples are heterogeneous: we have an <code>i32</code> an=
d a <code>&amp;str</code> in this tuple. In systems programming languages, =
strings are a bit more complex than in other languages. For now, just read =
<code>&amp;str</code> as a <em>string slice</em>, and we=E2=80=99ll learn m=
ore soon.</p>
  <p>You can assign one tuple into another, if they have the same contained=
 types and <a href=3D"https://killercup.github.io/trpl-ebook/glossary.html#=
arity">arity</a>. Tuples have the same arity when they have the same length=
.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D (<span class=3D"dv">1</span>, <span class=3D"dv">2</span>); <span cl=
ass=3D"co">// x: (i32, i32)</span>
  <span class=3D"kw">let</span> y =3D (<span class=3D"dv">2</span>, <span c=
lass=3D"dv">3</span>); <span class=3D"co">// y: (i32, i32)</span>
 =20
  x =3D y;</code></pre></div>
  <p>You can access the fields in a tuple through a <em>destructuring let</=
em>. Here=E2=80=99s an example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> (x, y, z) =3D (<span class=3D=
"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</span>);
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"x is {}"</span>, x=
);</code></pre></div>
  <p>Remember <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-0=
5-13.html#sec--variable-bindings">before</a> when I said the left-hand side=
 of a <code>let</code> statement was more powerful than just assigning a bi=
nding? Here we are. We can put a pattern on the left-hand side of the <code=
>let</code>, and if it matches up to the right-hand side, we can assign mul=
tiple bindings at once. In this case, <code>let</code> =E2=80=9Cdestructure=
s=E2=80=9D or =E2=80=9Cbreaks up=E2=80=9D the tuple, and assigns the bits t=
o three bindings.</p>
  <p>This pattern is very powerful, and we=E2=80=99ll see it repeated more =
later.</p>
  <p>You can disambiguate a single-element tuple from a value in parenthese=
s with a comma:</p>
  <pre><code>(0,); // single-element tuple
  (0); // zero in parentheses</code></pre>
  <h4 id=3D"tuple-indexing">Tuple Indexing</h4>
  <p>You can also access fields of a tuple with indexing syntax:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> tuple =3D (<span class=3D"dv"=
>1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</span>);
 =20
  <span class=3D"kw">let</span> x =3D tuple.<span class=3D"dv">0</span>;
  <span class=3D"kw">let</span> y =3D tuple.<span class=3D"dv">1</span>;
  <span class=3D"kw">let</span> z =3D tuple.<span class=3D"dv">2</span>;
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"x is {}"</span>, x=
);</code></pre></div>
  <p>Like array indexing, it starts at zero, but unlike array indexing, it =
uses a <code>.</code>, rather than <code>[]</code>s.</p>
  <p>You can find more documentation for tuples <a href=3D"http://doc.rust-=
lang.org/std/primitive.tuple.html">in the standard library documentation</a=
>.</p>
  <h3 id=3D"functions">Functions</h3>
  <p>Functions also have a type! They look like this:</p>
  <pre><code>fn foo(x: i32) -&gt; i32 { x }
 =20
  let x: fn(i32) -&gt; i32 =3D foo;</code></pre>
  <p>In this case, <code>x</code> is a =E2=80=98function pointer=E2=80=99 t=
o a function that takes an <code>i32</code> and returns an <code>i32</code>=
.</p>
  <h2 id=3D"sec--comments">Comments</h2>
  <p>Now that we have some functions, it=E2=80=99s a good idea to learn abo=
ut comments. Comments are notes that you leave to other programmers to help=
 explain things about your code. The compiler mostly ignores them.</p>
  <p>Rust has two kinds of comments that you should care about: <em>line co=
mments</em> and <em>doc comments</em>.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"co">// Line comments are anything after =E2=
=80=98//=E2=80=99 and extend to the end of the line.</span>
 =20
  <span class=3D"kw">let</span> x =3D <span class=3D"dv">5</span>; <span cl=
ass=3D"co">// this is also a line comment.</span>
 =20
  <span class=3D"co">// If you have a long explanation for something, you c=
an put line comments next</span>
  <span class=3D"co">// to each other. Put a space between the // and your =
comment so that it=E2=80=99s</span>
  <span class=3D"co">// more readable.</span></code></pre></div>
  <p>The other kind of comment is a doc comment. Doc comments use <code>///=
</code> instead of <code>//</code>, and support Markdown notation inside:</=
p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"co">/// Adds one to the number given.</span>
  <span class=3D"co">///</span>
  <span class=3D"co">/// # Examples</span>
  <span class=3D"co">///</span>
  <span class=3D"co">/// ```</span>
  <span class=3D"co">/// let five =3D 5;</span>
  <span class=3D"co">///</span>
  <span class=3D"co">/// assert_eq!(6, add_one(5));</span>
  <span class=3D"co">/// ```</span>
  <span class=3D"kw">fn</span> add_one(x: <span class=3D"kw">i32</span>) -&=
gt; <span class=3D"kw">i32</span> {
      x + <span class=3D"dv">1</span>
  }</code></pre></div>
  <p>When writing doc comments, providing some examples of usage is very, v=
ery helpful. You=E2=80=99ll notice we=E2=80=99ve used a new macro here: <co=
de>assert_eq!</code>. This compares two values, and <code>panic!</code>s if=
 they=E2=80=99re not equal to each other. It=E2=80=99s very helpful in docu=
mentation. There=E2=80=99s another macro, <code>assert!</code>, which <code=
>panic!</code>s if the value passed to it is <code>false</code>.</p>
  <p>You can use the <a href=3D"https://killercup.github.io/trpl-ebook/trpl=
-2015-05-13.html#sec--documentation"><code>rustdoc</code></a> tool to gener=
ate HTML documentation from these doc comments, and also to run the code ex=
amples as tests!</p>
  <h2 id=3D"sec--if">if</h2>
  <p>Rust=E2=80=99s take on <code>if</code> is not particularly complex, bu=
t it=E2=80=99s much more like the <code>if</code> you=E2=80=99ll find in a =
dynamically typed language than in a more traditional systems language. So =
let=E2=80=99s talk about it, to make sure you grasp the nuances.</p>
  <p><code>if</code> is a specific form of a more general concept, the =E2=
=80=98branch=E2=80=99. The name comes from a branch in a tree: a decision p=
oint, where depending on a choice, multiple paths can be taken.</p>
  <p>In the case of <code>if</code>, there is one choice that leads down tw=
o paths:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
 =20
  <span class=3D"kw">if</span> x =3D=3D <span class=3D"dv">5</span> {
      <span class=3D"ot">println!</span>(<span class=3D"st">"x is five!"</s=
pan>);
  }</code></pre></div>
  <p>If we changed the value of <code>x</code> to something else, this line=
 would not print. More specifically, if the expression after the <code>if</=
code> evaluates to <code>true</code>, then the block is executed. If it=E2=
=80=99s <code>false</code>, then it is not.</p>
  <p>If you want something to happen in the <code>false</code> case, use an=
 <code>else</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
 =20
  <span class=3D"kw">if</span> x =3D=3D <span class=3D"dv">5</span> {
      <span class=3D"ot">println!</span>(<span class=3D"st">"x is five!"</s=
pan>);
  } <span class=3D"kw">else</span> {
      <span class=3D"ot">println!</span>(<span class=3D"st">"x is not five =
:("</span>);
  }</code></pre></div>
  <p>If there is more than one case, use an <code>else if</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
 =20
  <span class=3D"kw">if</span> x =3D=3D <span class=3D"dv">5</span> {
      <span class=3D"ot">println!</span>(<span class=3D"st">"x is five!"</s=
pan>);
  } <span class=3D"kw">else</span> <span class=3D"kw">if</span> x =3D=3D <s=
pan class=3D"dv">6</span> {
      <span class=3D"ot">println!</span>(<span class=3D"st">"x is six!"</sp=
an>);
  } <span class=3D"kw">else</span> {
      <span class=3D"ot">println!</span>(<span class=3D"st">"x is not five =
or six :("</span>);
  }</code></pre></div>
  <p>This is all pretty standard. However, you can also do this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
 =20
  <span class=3D"kw">let</span> y =3D <span class=3D"kw">if</span> x =3D=3D=
 <span class=3D"dv">5</span> {
      <span class=3D"dv">10</span>
  } <span class=3D"kw">else</span> {
      <span class=3D"dv">15</span>
  }; <span class=3D"co">// y: i32</span></code></pre></div>
  <p>Which we can (and probably should) write like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
 =20
  <span class=3D"kw">let</span> y =3D <span class=3D"kw">if</span> x =3D=3D=
 <span class=3D"dv">5</span> { <span class=3D"dv">10</span> } <span class=
=3D"kw">else</span> { <span class=3D"dv">15</span> }; <span class=3D"co">//=
 y: i32</span></code></pre></div>
  <p>This works because <code>if</code> is an expression. The value of the =
expression is the value of the last expression in whichever branch was chos=
en. An <code>if</code> without an <code>else</code> always results in <code=
>()</code> as the value.</p>
  <h2 id=3D"sec--for-loops">for loops</h2>
  <p>The <code>for</code> loop is used to loop a particular number of times=
. Rust=E2=80=99s <code>for</code> loops work a bit differently than in othe=
r systems languages, however. Rust=E2=80=99s <code>for</code> loop doesn=E2=
=80=99t look like this =E2=80=9CC-style=E2=80=9D <code>for</code> loop:</p>
  <pre><code>for (x =3D 0; x &lt; 10; x++) {
      printf( "%d\n", x );
  }</code></pre>
  <p>Instead, it looks like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">for</span> x in <span class=3D"dv">0.</s=
pan>.<span class=3D"dv">10</span> {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
; <span class=3D"co">// x: i32</span>
  }</code></pre></div>
  <p>In slightly more abstract terms,</p>
  <pre><code>for var in expression {
      code
  }</code></pre>
  <p>The expression is an <a href=3D"https://killercup.github.io/trpl-ebook=
/trpl-2015-05-13.html#sec--iterators">iterator</a>. The iterator gives back=
 a series of elements. Each element is one iteration of the loop. That valu=
e is then bound to the name <code>var</code>, which is valid for the loop b=
ody. Once the body is over, the next value is fetched from the iterator, an=
d we loop another time. When there are no more values, the <code>for</code>=
 loop is over.</p>
  <p>In our example, <code>0..10</code> is an expression that takes a start=
 and an end position, and gives an iterator over those values. The upper bo=
und is exclusive, though, so our loop will print <code>0</code> through <co=
de>9</code>, not <code>10</code>.</p>
  <p>Rust does not have the =E2=80=9CC-style=E2=80=9D <code>for</code> loop=
 on purpose. Manually controlling each element of the loop is complicated a=
nd error prone, even for experienced C developers.</p>
  <h2 id=3D"sec--while-loops">while loops</h2>
  <p>Rust also has a <code>while</code> loop. It looks like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>; <span class=3D"co">// mut x: u32</span>
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> done =3D <spa=
n class=3D"kw">false</span>; <span class=3D"co">// mut done: bool</span>
 =20
  <span class=3D"kw">while</span> !done {
      x +=3D x - <span class=3D"dv">3</span>;
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
;
 =20
      <span class=3D"kw">if</span> x % <span class=3D"dv">5</span> =3D=3D <=
span class=3D"dv">0</span> {
          done =3D <span class=3D"kw">true</span>;
      }
  }</code></pre></div>
  <p><code>while</code> loops are the correct choice when you=E2=80=99re no=
t sure how many times you need to loop.</p>
  <p>If you need an infinite loop, you may be tempted to write this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">while</span> <span class=3D"kw">true</sp=
an> {</code></pre></div>
  <p>However, Rust has a dedicated keyword, <code>loop</code>, to handle th=
is case:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">loop</span> {</code></pre></div>
  <p>Rust=E2=80=99s control-flow analysis treats this construct differently=
 than a <code>while true</code>, since we know that it will always loop. In=
 general, the more information we can give to the compiler, the better it c=
an do with safety and code generation, so you should always prefer <code>lo=
op</code> when you plan to loop infinitely.</p>
  <h4 id=3D"ending-iteration-early">Ending iteration early</h4>
  <p>Let=E2=80=99s take a look at that <code>while</code> loop we had earli=
er:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> done =3D <spa=
n class=3D"kw">false</span>;
 =20
  <span class=3D"kw">while</span> !done {
      x +=3D x - <span class=3D"dv">3</span>;
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
;
 =20
      <span class=3D"kw">if</span> x % <span class=3D"dv">5</span> =3D=3D <=
span class=3D"dv">0</span> {
          done =3D <span class=3D"kw">true</span>;
      }
  }</code></pre></div>
  <p>We had to keep a dedicated <code>mut</code> boolean variable binding, =
<code>done</code>, to know when we should exit out of the loop. Rust has tw=
o keywords to help us with modifying iteration: <code>break</code> and <cod=
e>continue</code>.</p>
  <p>In this case, we can write the loop in a better way with <code>break</=
code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
 =20
  <span class=3D"kw">loop</span> {
      x +=3D x - <span class=3D"dv">3</span>;
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
;
 =20
      <span class=3D"kw">if</span> x % <span class=3D"dv">5</span> =3D=3D <=
span class=3D"dv">0</span> { <span class=3D"kw">break</span>; }
  }</code></pre></div>
  <p>We now loop forever with <code>loop</code> and use <code>break</code> =
to break out early.</p>
  <p><code>continue</code> is similar, but instead of ending the loop, goes=
 to the next iteration. This will only print the odd numbers:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">for</span> x in <span class=3D"dv">0.</s=
pan>.<span class=3D"dv">10</span> {
      <span class=3D"kw">if</span> x % <span class=3D"dv">2</span> =3D=3D <=
span class=3D"dv">0</span> { <span class=3D"kw">continue</span>; }
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
;
  }</code></pre></div>
  <p>Both <code>continue</code> and <code>break</code> are valid in both <c=
ode>while</code> loops and <a href=3D"https://killercup.github.io/trpl-eboo=
k/trpl-2015-05-13.html#sec--for-loops"><code>for</code> loops</a>.</p>
  <h2 id=3D"sec--ownership">Ownership</h2>
  <p>This guide is one of three presenting Rust=E2=80=99s ownership system.=
 This is one of Rust=E2=80=99s most unique and compelling features, with wh=
ich Rust developers should become quite acquainted. Ownership is how Rust a=
chieves its largest goal, memory safety. There are a few distinct concepts,=
 each with its own chapter:</p>
  <ul>
  <li>ownership, which you=E2=80=99re reading now</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--references-and-borrowing">borrowing</a>, and their associated featur=
e =E2=80=98references=E2=80=99</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--lifetimes">lifetimes</a>, an advanced concept of borrowing</li>
  </ul>
  <p>These three chapters are related, and in order. You=E2=80=99ll need al=
l three to fully understand the ownership system.</p>
  <h3 id=3D"meta">Meta</h3>
  <p>Before we get to the details, two important notes about the ownership =
system.</p>
  <p>Rust has a focus on safety and speed. It accomplishes these goals thro=
ugh many =E2=80=98zero-cost abstractions=E2=80=99, which means that in Rust=
, abstractions cost as little as possible in order to make them work. The o=
wnership system is a prime example of a zero-cost abstraction. All of the a=
nalysis we=E2=80=99ll talk about in this guide is <em>done at compile time<=
/em>. You do not pay any run-time cost for any of these features.</p>
  <p>However, this system does have a certain cost: learning curve. Many ne=
w users to Rust experience something we like to call =E2=80=98fighting with=
 the borrow checker=E2=80=99, where the Rust compiler refuses to compile a =
program that the author thinks is valid. This often happens because the pro=
grammer=E2=80=99s mental model of how ownership should work doesn=E2=80=99t=
 match the actual rules that Rust implements. You probably will experience =
similar things at first. There is good news, however: more experienced Rust=
 developers report that once they work with the rules of the ownership syst=
em for a period of time, they fight the borrow checker less and less.</p>
  <p>With that in mind, let=E2=80=99s learn about ownership.</p>
  <h3 id=3D"ownership">Ownership</h3>
  <p><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html=
#sec--variable-bindings">Variable bindings</a> have a property in Rust: the=
y =E2=80=98have ownership=E2=80=99 of what they=E2=80=99re bound to. This m=
eans that when a binding goes out of scope, the resource that they=E2=80=99=
re bound to are freed. For example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo() {
      <span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!</span>[<s=
pan class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">=
3</span>];
  }</code></pre></div>
  <p>When <code>v</code> comes into scope, a new <a href=3D"http://doc.rust=
-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> is created=
. In this case, the vector also allocates space on <a href=3D"https://kille=
rcup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--the-stack-and-the-heap"=
>the heap</a>, for the three elements. When <code>v</code> goes out of scop=
e at the end of <code>foo()</code>, Rust will clean up everything related t=
o the vector, even the heap-allocated memory. This happens deterministicall=
y, at the end of the scope.</p>
  <h3 id=3D"move-semantics">Move semantics</h3>
  <p>There=E2=80=99s some more subtlety here, though: Rust ensures that the=
re is <em>exactly one</em> binding to any given resource. For example, if w=
e have a vector, we can assign it to another binding:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!=
</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span cla=
ss=3D"dv">3</span>];
 =20
  <span class=3D"kw">let</span> v2 =3D v;</code></pre></div>
  <p>But, if we try to use <code>v</code> afterwards, we get an error:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!=
</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span cla=
ss=3D"dv">3</span>];
 =20
  <span class=3D"kw">let</span> v2 =3D v;
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"v[0] is: {}"</span=
>, v[<span class=3D"dv">0</span>]);</code></pre></div>
  <p>It looks like this:</p>
  <pre><code>error: use of moved value: `v`
  println!("v[0] is: {}", v[0]);
                          ^</code></pre>
  <p>A similar thing happens if we define a function which takes ownership,=
 and try to use something after we=E2=80=99ve passed it as an argument:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> take(v: Vec&lt;<span class=3D"=
kw">i32</span>&gt;) {
      <span class=3D"co">// what happens here isn=E2=80=99t important.</spa=
n>
  }
 =20
  <span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!</span>[<span =
class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</s=
pan>];
 =20
  take(v);
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"v[0] is: {}"</span=
>, v[<span class=3D"dv">0</span>]);</code></pre></div>
  <p>Same error: =E2=80=98use of moved value=E2=80=99. When we transfer own=
ership to something else, we say that we=E2=80=99ve =E2=80=98moved=E2=80=99=
 the thing we refer to. You don=E2=80=99t need some sort of special annotat=
ion here, it=E2=80=99s the default thing that Rust does.</p>
  <h4 id=3D"the-details">The details</h4>
  <p>The reason that we cannot use a binding after we=E2=80=99ve moved it i=
s subtle, but important. When we write code like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!=
</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span cla=
ss=3D"dv">3</span>];
 =20
  <span class=3D"kw">let</span> v2 =3D v;</code></pre></div>
  <p>The first line allocates memory for the vector object, <code>v</code>,=
 and for the data it contains. The vector object is stored on the <a href=
=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--the-st=
ack-and-the-heap">stack</a> and contains a pointer to the content (<code>[1=
, 2, 3]</code>) stored on the <a href=3D"https://killercup.github.io/trpl-e=
book/trpl-2015-05-13.html#sec--the-stack-and-the-heap">heap</a>. When we mo=
ve <code>v</code> to <code>v2</code>, it creates a copy of that pointer, fo=
r <code>v2</code>. Which means that there would be two pointers to the cont=
ent of the vector on the heap. It would violate Rust=E2=80=99s safety guara=
ntees by introducing a data race. Therefore, Rust forbids using <code>v</co=
de> after we=E2=80=99ve done the move.</p>
  <p>It=E2=80=99s also important to note that optimizations may remove the =
actual copy of the bytes on the stack, depending on circumstances. So it ma=
y not be as inefficient as it initially seems.</p>
  <h4 id=3D"copy-types"><code>Copy</code> types</h4>
  <p>We=E2=80=99ve established that when ownership is transferred to anothe=
r binding, you cannot use the original binding. However, there=E2=80=99s a =
<a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec-=
-traits">trait</a> that changes this behavior, and it=E2=80=99s called <cod=
e>Copy</code>. We haven=E2=80=99t discussed traits yet, but for now, you ca=
n think of them as an annotation to a particular type that adds extra behav=
ior. For example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> v =3D <span class=3D"dv">1</s=
pan>;
 =20
  <span class=3D"kw">let</span> v2 =3D v;
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"v is: {}"</span>, =
v);</code></pre></div>
  <p>In this case, <code>v</code> is an <code>i32</code>, which implements =
the <code>Copy</code> trait. This means that, just like a move, when we ass=
ign <code>v</code> to <code>v2</code>, a copy of the data is made. But, unl=
ike a move, we can still use <code>v</code> afterward. This is because an <=
code>i32</code> has no pointers to data somewhere else, copying it is a ful=
l copy.</p>
  <p>We will discuss how to make your own types <code>Copy</code> in the <a=
 href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--t=
raits">traits</a> section.</p>
  <h3 id=3D"more-than-ownership">More than ownership</h3>
  <p>Of course, if we had to hand ownership back with every function we wro=
te:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(v: Vec&lt;<span class=3D"k=
w">i32</span>&gt;) -&gt; Vec&lt;<span class=3D"kw">i32</span>&gt; {
      <span class=3D"co">// do stuff with v</span>
 =20
      <span class=3D"co">// hand back ownership</span>
      v
  }</code></pre></div>
  <p>This would get very tedious. It gets worse the more things we want to =
take ownership of:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(v1: Vec&lt;<span class=3D"=
kw">i32</span>&gt;, v2: Vec&lt;<span class=3D"kw">i32</span>&gt;) -&gt; (Ve=
c&lt;<span class=3D"kw">i32</span>&gt;, Vec&lt;<span class=3D"kw">i32</span=
>&gt;, <span class=3D"kw">i32</span>) {
      <span class=3D"co">// do stuff with v1 and v2</span>
 =20
      <span class=3D"co">// hand back ownership, and the result of our func=
tion</span>
      (v1, v2, <span class=3D"dv">42</span>)
  }
 =20
  <span class=3D"kw">let</span> v1 =3D <span class=3D"ot">vec!</span>[<span=
 class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</=
span>];
  <span class=3D"kw">let</span> v2 =3D <span class=3D"ot">vec!</span>[<span=
 class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</=
span>];
 =20
  <span class=3D"kw">let</span> (v1, v2, answer) =3D foo(v1, v2);</code></p=
re></div>
  <p>Ugh! The return type, return line, and calling the function gets way m=
ore complicated.</p>
  <p>Luckily, Rust offers a feature, borrowing, which helps us solve this p=
roblem. It=E2=80=99s the topic of the next section!</p>
  <h2 id=3D"sec--references-and-borrowing">References and Borrowing</h2>
  <p>This guide is one of three presenting Rust=E2=80=99s ownership system.=
 This is one of Rust=E2=80=99s most unique and compelling features, with wh=
ich Rust developers should become quite acquainted. Ownership is how Rust a=
chieves its largest goal, memory safety. There are a few distinct concepts,=
 each with its own chapter:</p>
  <ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--ownership">ownership</a>, the key concept</li>
  <li>borrowing, which you=E2=80=99re reading now</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--lifetimes">lifetimes</a>, an advanced concept of borrowing</li>
  </ul>
  <p>These three chapters are related, and in order. You=E2=80=99ll need al=
l three to fully understand the ownership system.</p>
  <h3 id=3D"meta-1">Meta</h3>
  <p>Before we get to the details, two important notes about the ownership =
system.</p>
  <p>Rust has a focus on safety and speed. It accomplishes these goals thro=
ugh many =E2=80=98zero-cost abstractions=E2=80=99, which means that in Rust=
, abstractions cost as little as possible in order to make them work. The o=
wnership system is a prime example of a zero cost abstraction. All of the a=
nalysis we=E2=80=99ll talk about in this guide is <em>done at compile time<=
/em>. You do not pay any run-time cost for any of these features.</p>
  <p>However, this system does have a certain cost: learning curve. Many ne=
w users to Rust experience something we like to call =E2=80=98fighting with=
 the borrow checker=E2=80=99, where the Rust compiler refuses to compile a =
program that the author thinks is valid. This often happens because the pro=
grammer=E2=80=99s mental model of how ownership should work doesn=E2=80=99t=
 match the actual rules that Rust implements. You probably will experience =
similar things at first. There is good news, however: more experienced Rust=
 developers report that once they work with the rules of the ownership syst=
em for a period of time, they fight the borrow checker less and less.</p>
  <p>With that in mind, let=E2=80=99s learn about borrowing.</p>
  <h3 id=3D"borrowing">Borrowing</h3>
  <p>At the end of the <a href=3D"https://killercup.github.io/trpl-ebook/tr=
pl-2015-05-13.html#sec--ownership">ownership</a> section, we had a nasty fu=
nction that looked like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(v1: Vec&lt;<span class=3D"=
kw">i32</span>&gt;, v2: Vec&lt;<span class=3D"kw">i32</span>&gt;) -&gt; (Ve=
c&lt;<span class=3D"kw">i32</span>&gt;, Vec&lt;<span class=3D"kw">i32</span=
>&gt;, <span class=3D"kw">i32</span>) {
      <span class=3D"co">// do stuff with v1 and v2</span>
 =20
      <span class=3D"co">// hand back ownership, and the result of our func=
tion</span>
      (v1, v2, <span class=3D"dv">42</span>)
  }
 =20
  <span class=3D"kw">let</span> v1 =3D <span class=3D"ot">vec!</span>[<span=
 class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</=
span>];
  <span class=3D"kw">let</span> v2 =3D <span class=3D"ot">vec!</span>[<span=
 class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</=
span>];
 =20
  <span class=3D"kw">let</span> (v1, v2, answer) =3D foo(v1, v2);</code></p=
re></div>
  <p>This is not idiomatic Rust, however, as it doesn=E2=80=99t take advant=
age of borrowing. Here=E2=80=99s the first step:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(v1: &amp;Vec&lt;<span clas=
s=3D"kw">i32</span>&gt;, v2: &amp;Vec&lt;<span class=3D"kw">i32</span>&gt;)=
 -&gt; <span class=3D"kw">i32</span> {
      <span class=3D"co">// do stuff with v1 and v2</span>
 =20
      <span class=3D"co">// return the answer</span>
      <span class=3D"dv">42</span>
  }
 =20
  <span class=3D"kw">let</span> v1 =3D <span class=3D"ot">vec!</span>[<span=
 class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</=
span>];
  <span class=3D"kw">let</span> v2 =3D <span class=3D"ot">vec!</span>[<span=
 class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</=
span>];
 =20
  <span class=3D"kw">let</span> answer =3D foo(&amp;v1, &amp;v2);
 =20
  <span class=3D"co">// we can use v1 and v2 here!</span></code></pre></div=
>
  <p>Instead of taking <code>Vec&lt;i32&gt;</code>s as our arguments, we ta=
ke a reference: <code>&amp;Vec&lt;i32&gt;</code>. And instead of passing <c=
ode>v1</code> and <code>v2</code> directly, we pass <code>&amp;v1</code> an=
d <code>&amp;v2</code>. We call the <code>&amp;T</code> type a =E2=80=98ref=
erence=E2=80=99, and rather than owning the resource, it borrows ownership.=
 A binding that borrows something does not deallocate the resource when it =
goes out of scope. This means that after the call to <code>foo()</code>, we=
 can use our original bindings again.</p>
  <p>References are immutable, just like bindings. This means that inside o=
f <code>foo()</code>, the vectors can=E2=80=99t be changed at all:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(v: &amp;Vec&lt;<span class=
=3D"kw">i32</span>&gt;) {
       v.push(<span class=3D"dv">5</span>);
  }
 =20
  <span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!</span>[];
 =20
  foo(&amp;v);</code></pre></div>
  <p>errors with:</p>
  <pre><code>error: cannot borrow immutable borrowed content `*v` as mutabl=
e
  v.push(5);
  ^</code></pre>
  <p>Pushing a value mutates the vector, and so we aren=E2=80=99t allowed t=
o do it.</p>
  <h3 id=3D"mut-references">&amp;mut references</h3>
  <p>There=E2=80=99s a second kind of reference: <code>&amp;mut T</code>. A=
 =E2=80=98mutable reference=E2=80=99 allows you to mutate the resource you=
=E2=80=99re borrowing. For example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
  {
      <span class=3D"kw">let</span> y =3D &amp;<span class=3D"kw">mut</span=
> x;
      *y +=3D <span class=3D"dv">1</span>;
  }
  <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x);</c=
ode></pre></div>
  <p>This will print <code>6</code>. We make <code>y</code> a mutable refer=
ence to <code>x</code>, then add one to the thing <code>y</code> points at.=
 You=E2=80=99ll notice that <code>x</code> had to be marked <code>mut</code=
> as well, if it wasn=E2=80=99t, we couldn=E2=80=99t take a mutable borrow =
to an immutable value.</p>
  <p>Otherwise, <code>&amp;mut</code> references are just like references. =
There <em>is</em> a large difference between the two, and how they interact=
, though. You can tell something is fishy in the above example, because we =
need that extra scope, with the <code>{</code> and <code>}</code>. If we re=
move them, we get an error:</p>
  <pre><code>error: cannot borrow `x` as immutable because it is also borro=
wed as mutable
      println!("{}", x);
                     ^
  note: previous borrow of `x` occurs here; the mutable borrow prevents
  subsequent moves, borrows, or modification of `x` until the borrow ends
          let y =3D &amp;mut x;
                       ^
  note: previous borrow ends here
  fn main() {
 =20
  }
  ^</code></pre>
  <p>As it turns out, there are rules.</p>
  <h3 id=3D"the-rules">The Rules</h3>
  <p>Here=E2=80=99s the rules about borrowing in Rust:</p>
  <p>First, any borrow must last for a smaller scope than the owner. Second=
, you may have one or the other of these two kinds of borrows, but not both=
 at the same time:</p>
  <ul>
  <li>0 to N references (<code>&amp;T</code>) to a resource.</li>
  <li>exactly one mutable reference (<code>&amp;mut T</code>)</li>
  </ul>
  <p>You may notice that this is very similar, though not exactly the same =
as, to the definition of a data race:</p>
  <blockquote>
  <p>There is a =E2=80=98data race=E2=80=99 when two or more pointers acces=
s the same memory location at the same time, where at least one of them is =
writing, and the operations are not synchronized.</p>
  </blockquote>
  <p>With references, you may have as many as you=E2=80=99d like, since non=
e of them are writing. If you are writing, you need two or more pointers to=
 the same memory, and you can only have one <code>&amp;mut</code> at a time=
. This is how Rust prevents data races at compile time: we=E2=80=99ll get e=
rrors if we break the rules.</p>
  <p>With this in mind, let=E2=80=99s consider our example again.</p>
  <h4 id=3D"thinking-in-scopes">Thinking in scopes</h4>
  <p>Here=E2=80=99s the code:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
  <span class=3D"kw">let</span> y =3D &amp;<span class=3D"kw">mut</span> x;
 =20
  *y +=3D <span class=3D"dv">1</span>;
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x);</c=
ode></pre></div>
  <p>This code gives us this error:</p>
  <pre><code>error: cannot borrow `x` as immutable because it is also borro=
wed as mutable
      println!("{}", x);
                     ^</code></pre>
  <p>This is because we=E2=80=99ve violated the rules: we have a <code>&amp=
;mut T</code> pointing to <code>x</code>, and so we aren=E2=80=99t allowed =
to create any <code>&amp;T</code>s. One or the other. The note hints at how=
 to think about this problem:</p>
  <pre><code>note: previous borrow ends here
  fn main() {
 =20
  }
  ^</code></pre>
  <p>In other words, the mutable borow is held through the rest of our exam=
ple. What we want is for the mutable borrow to end <em>before</em> we try t=
o call <code>println!</code> and make an immutable borrow. In Rust, borrowi=
ng is tied to the scope that the borrow is valid for. And our scopes look l=
ike this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
 =20
  <span class=3D"kw">let</span> y =3D &amp;<span class=3D"kw">mut</span> x;=
    <span class=3D"co">// -+ &amp;mut borrow of x starts here</span>
                     <span class=3D"co">//  |</span>
  *y +=3D <span class=3D"dv">1</span>;           <span class=3D"co">//  |</=
span>
                     <span class=3D"co">//  |</span>
  <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x); <s=
pan class=3D"co">// -+ - try to borrow x here</span>
                     <span class=3D"co">// -+ &amp;mut borrow of x ends her=
e</span></code></pre></div>
  <p>The scopes conflict: we can=E2=80=99t make an <code>&amp;x</code> whil=
e <code>y</code> is in scope.</p>
  <p>So when we add the curly braces:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
 =20
  {                  =20
      <span class=3D"kw">let</span> y =3D &amp;<span class=3D"kw">mut</span=
> x; <span class=3D"co">// -+ &amp;mut borrow starts here</span>
      *y +=3D <span class=3D"dv">1</span>;        <span class=3D"co">//  |<=
/span>
  }                   <span class=3D"co">// -+ ... and ends here</span>
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x);  <=
span class=3D"co">// &lt;- try to borrow x here</span></code></pre></div>
  <p>There=E2=80=99s no problem. Our mutable borrow goes out of scope befor=
e we create an immutable one. But scope is the key to seeing how long a bor=
row lasts for.</p>
  <h4 id=3D"issues-borrowing-prevents">Issues borrowing prevents</h4>
  <p>Why have these restrictive rules? Well, as we noted, these rules preve=
nt data races. What kinds of issues do data races cause? Here=E2=80=99s a f=
ew.</p>
  <h5 id=3D"iterator-invalidation">Iterator invalidation</h5>
  <p>One example is =E2=80=98iterator invalidation=E2=80=99, which happens =
when you try to mutate a collection that you=E2=80=99re iterating over. Rus=
t=E2=80=99s borrow checker prevents this from happening:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 v =3D <span class=3D"ot">vec!</span>[<span class=3D"dv">1</span>, <span cl=
ass=3D"dv">2</span>, <span class=3D"dv">3</span>];
 =20
  <span class=3D"kw">for</span> i in &amp;v {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, i)=
;
  }</code></pre></div>
  <p>This prints out one through three. As we iterate through the vectors, =
we=E2=80=99re only given references to the elements. And <code>v</code> is =
itself borrowed as immutable, which means we can=E2=80=99t change it while =
we=E2=80=99re iterating:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 v =3D <span class=3D"ot">vec!</span>[<span class=3D"dv">1</span>, <span cl=
ass=3D"dv">2</span>, <span class=3D"dv">3</span>];
 =20
  <span class=3D"kw">for</span> i in &amp;v {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, i)=
;
      v.push(<span class=3D"dv">34</span>);
  }</code></pre></div>
  <p>Here=E2=80=99s the error:</p>
  <pre><code>error: cannot borrow `v` as mutable because it is also borrowe=
d as immutable
      v.push(34);
      ^
  note: previous borrow of `v` occurs here; the immutable borrow prevents
  subsequent moves or mutable borrows of `v` until the borrow ends
  for i in &amp;v {
            ^
  note: previous borrow ends here
  for i in &amp;v {
      println!(=E2=80=9C{}=E2=80=9D, i);
      v.push(34);
  }
  ^</code></pre>
  <p>We can=E2=80=99t modify <code>v</code> because it=E2=80=99s borrowed b=
y the loop.</p>
  <h5 id=3D"use-after-free">use after free</h5>
  <p>References must live as long as the resource they refer to. Rust will =
check the scopes of your references to ensure that this is true.</p>
  <p>If Rust didn=E2=80=99t check that this property, we could accidentally=
 use a reference which was invalid. For example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> y: &amp;<span class=3D"kw">i3=
2</span>;
  {=20
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">5</span>;
      y =3D &amp;x;
  }
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, y);</c=
ode></pre></div>
  <p>We get this error:</p>
  <pre><code>error: `x` does not live long enough
      y =3D &amp;x;
           ^
  note: reference must be valid for the block suffix following statement 0 =
at
  2:16...
  let y: &amp;i32;
  {=20
      let x =3D 5;
      y =3D &amp;x;
  }
 =20
  note: ...but borrowed value is only valid for the block suffix following
  statement 0 at 4:18
      let x =3D 5;
      y =3D &amp;x;
  }</code></pre>
  <p>In other words, <code>y</code> is only valid for the scope where <code=
>x</code> exists. As soon as <code>x</code> goes away, it becomes invalid t=
o refer to it. As such, the error says that the borrow =E2=80=98doesn=E2=80=
=99t live long enough=E2=80=99 because it=E2=80=99s not valid for the right=
 amount of time.</p>
  <p>The same problem occurs when the reference is declared <em>before</em>=
 the variable it refers to:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> y: &amp;<span class=3D"kw">i3=
2</span>;
  <span class=3D"kw">let</span> x =3D <span class=3D"dv">5</span>;
  y =3D &amp;x;
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, y);</c=
ode></pre></div>
  <p>We get this error:</p>
  <pre><code>error: `x` does not live long enough
  y =3D &amp;x;
       ^
  note: reference must be valid for the block suffix following statement 0 =
at
  2:16...
      let y: &amp;i32;
      let x =3D 5;
      y =3D &amp;x;
     =20
      println!("{}", y);
  }
 =20
  note: ...but borrowed value is only valid for the block suffix following
  statement 1 at 3:14
      let x =3D 5;
      y =3D &amp;x;
     =20
      println!("{}", y);
  }</code></pre>
  <h2 id=3D"sec--lifetimes">Lifetimes</h2>
  <p>This guide is one of three presenting Rust=E2=80=99s ownership system.=
 This is one of Rust=E2=80=99s most unique and compelling features, with wh=
ich Rust developers should become quite acquainted. Ownership is how Rust a=
chieves its largest goal, memory safety. There are a few distinct concepts,=
 each with its own chapter:</p>
  <ul>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--ownership">ownership</a>, the key concept</li>
  <li><a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--references-and-borrowing">borrowing</a>, and their associated featur=
e =E2=80=98references=E2=80=99</li>
  <li>lifetimes, which you=E2=80=99re reading now</li>
  </ul>
  <p>These three chapters are related, and in order. You=E2=80=99ll need al=
l three to fully understand the ownership system.</p>
  <h3 id=3D"meta-2">Meta</h3>
  <p>Before we get to the details, two important notes about the ownership =
system.</p>
  <p>Rust has a focus on safety and speed. It accomplishes these goals thro=
ugh many =E2=80=98zero-cost abstractions=E2=80=99, which means that in Rust=
, abstractions cost as little as possible in order to make them work. The o=
wnership system is a prime example of a zero-cost abstraction. All of the a=
nalysis we=E2=80=99ll talk about in this guide is <em>done at compile time<=
/em>. You do not pay any run-time cost for any of these features.</p>
  <p>However, this system does have a certain cost: learning curve. Many ne=
w users to Rust experience something we like to call =E2=80=98fighting with=
 the borrow checker=E2=80=99, where the Rust compiler refuses to compile a =
program that the author thinks is valid. This often happens because the pro=
grammer=E2=80=99s mental model of how ownership should work doesn=E2=80=99t=
 match the actual rules that Rust implements. You probably will experience =
similar things at first. There is good news, however: more experienced Rust=
 developers report that once they work with the rules of the ownership syst=
em for a period of time, they fight the borrow checker less and less.</p>
  <p>With that in mind, let=E2=80=99s learn about lifetimes.</p>
  <h3 id=3D"lifetimes">Lifetimes</h3>
  <p>Lending out a reference to a resource that someone else owns can be co=
mplicated. For example, imagine this set of operations:</p>
  <ul>
  <li>I acquire a handle to some kind of resource.</li>
  <li>I lend you a reference to the resource.</li>
  <li>I decide I=E2=80=99m done with the resource, and deallocate it, while=
 you still have your reference.</li>
  <li>You decide to use the resource.</li>
  </ul>
  <p>Uh oh! Your reference is pointing to an invalid resource. This is call=
ed a dangling pointer or =E2=80=98use after free=E2=80=99, when the resourc=
e is memory.</p>
  <p>To fix this, we have to make sure that step four never happens after s=
tep three. The ownership system in Rust does this through a concept called =
lifetimes, which describe the scope that a reference is valid for.</p>
  <p>When we have a function that takes a reference by argument, we can be =
implicit or explicit about the lifetime of the reference:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"co">// implicit</span>
  <span class=3D"kw">fn</span> foo(x: &amp;<span class=3D"kw">i32</span>) {
  }
 =20
  <span class=3D"co">// explicit</span>
  <span class=3D"kw">fn</span> bar&lt;<span class=3D"ot">'a</span>&gt;(x: &=
amp;<span class=3D"ot">'a</span> <span class=3D"kw">i32</span>) {
  }</code></pre></div>
  <p>The <code>'a</code> reads =E2=80=98the lifetime a=E2=80=99. Technicall=
y, every reference has some lifetime associated with it, but the compiler l=
ets you elide them in common cases. Before we get to that, though, let=E2=
=80=99s break the explicit example down:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> bar&lt;<span class=3D"ot">'a</=
span>&gt;(...)</code></pre></div>
  <p>This part declares our lifetimes. This says that <code>bar</code> has =
one lifetime, <code>'a</code>. If we had two reference parameters, it would=
 look like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> bar&lt;<span class=3D"ot">'a</=
span>, <span class=3D"ot">'b</span>&gt;(...)</code></pre></div>
  <p>Then in our parameter list, we use the lifetimes we=E2=80=99ve named:<=
/p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">...(x: &amp;<span class=3D"ot">'a</span> <span class=3D"kw"=
>i32</span>)</code></pre></div>
  <p>If we wanted an <code>&amp;mut</code> reference, we=E2=80=99d do this:=
</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">...(x: &amp;<span class=3D"ot">'a</span> <span class=3D"kw"=
>mut</span> <span class=3D"kw">i32</span>)</code></pre></div>
  <p>If you compare <code>&amp;mut i32</code> to <code>&amp;'a mut i32</cod=
e>, they=E2=80=99re the same, it=E2=80=99s just that the lifetime <code>'a<=
/code> has snuck in between the <code>&amp;</code> and the <code>mut i32</c=
ode>. We read <code>&amp;mut i32</code> as =E2=80=98a mutable reference to =
an i32=E2=80=99 and <code>&amp;'a mut i32</code> as =E2=80=98a mutable refe=
rence to an <code>i32</code> with the lifetime <code>'a</code>=E2=80=99.</p=
>
  <p>You=E2=80=99ll also need explicit lifetimes when working with <a href=
=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--struct=
s"><code>struct</code></a>s:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Foo&lt;<span class=3D"ot">=
'a</span>&gt; {
      x: &amp;<span class=3D"ot">'a</span> <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> y =3D &amp;<span class=3D"dv">5</span>;=
 <span class=3D"co">// this is the same as `let _y =3D 5; let y =3D &amp;_y=
;`</span>
      <span class=3D"kw">let</span> f =3D Foo { x: y };
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, f.=
x);
  }</code></pre></div>
  <p>As you can see, <code>struct</code>s can also have lifetimes. In a sim=
ilar way to functions,</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Foo&lt;<span class=3D"ot">=
'a</span>&gt; {</code></pre></div>
  <p>declares a lifetime, and</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">x: &amp;<span class=3D"ot">'a</span> <span class=3D"kw">i32=
</span>,</code></pre></div>
  <p>uses it. So why do we need a lifetime here? We need to ensure that any=
 reference to a <code>Foo</code> cannot outlive the reference to an <code>i=
32</code> it contains.</p>
  <h4 id=3D"thinking-in-scopes-1">Thinking in scopes</h4>
  <p>A way to think about lifetimes is to visualize the scope that a refere=
nce is valid for. For example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> y =3D &amp;<span class=3D"dv">5</span>;=
     <span class=3D"co">// -+ y goes into scope</span>
                      <span class=3D"co">//  |</span>
      <span class=3D"co">// stuff        //  |</span>
                      <span class=3D"co">//  |</span>
  }                   <span class=3D"co">// -+ y goes out of scope</span></=
code></pre></div>
  <p>Adding in our <code>Foo</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Foo&lt;<span class=3D"ot">=
'a</span>&gt; {
      x: &amp;<span class=3D"ot">'a</span> <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> y =3D &amp;<span class=3D"dv">5</span>;=
           <span class=3D"co">// -+ y goes into scope</span>
      <span class=3D"kw">let</span> f =3D Foo { x: y }; <span class=3D"co">=
// -+ f goes into scope</span>
      <span class=3D"co">// stuff              //  |</span>
                            <span class=3D"co">//  |</span>
  }                         <span class=3D"co">// -+ f and y go out of scop=
e</span></code></pre></div>
  <p>Our <code>f</code> lives within the scope of <code>y</code>, so everyt=
hing works. What if it didn=E2=80=99t? This code won=E2=80=99t work:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Foo&lt;<span class=3D"ot">=
'a</span>&gt; {
      x: &amp;<span class=3D"ot">'a</span> <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x;                    <span class=3D"co=
">// -+ x goes into scope</span>
                                <span class=3D"co">//  |</span>
      {                         <span class=3D"co">//  |</span>
          <span class=3D"kw">let</span> y =3D &amp;<span class=3D"dv">5</sp=
an>;           <span class=3D"co">// ---+ y goes into scope</span>
          <span class=3D"kw">let</span> f =3D Foo { x: y }; <span class=3D"=
co">// ---+ f goes into scope</span>
          x =3D &amp;f.x;             <span class=3D"co">//  | | error here=
</span>
      }                         <span class=3D"co">// ---+ f and y go out o=
f scope</span>
                                <span class=3D"co">//  |</span>
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
;        <span class=3D"co">//  |</span>
  }                             <span class=3D"co">// -+ x goes out of scop=
e</span></code></pre></div>
  <p>Whew! As you can see here, the scopes of <code>f</code> and <code>y</c=
ode> are smaller than the scope of <code>x</code>. But when we do <code>x =
=3D &amp;f.x</code>, we make <code>x</code> a reference to something that=
=E2=80=99s about to go out of scope.</p>
  <p>Named lifetimes are a way of giving these scopes a name. Giving someth=
ing a name is the first step towards being able to talk about it.</p>
  <h4 id=3D"static">=E2=80=99static</h4>
  <p>The lifetime named =E2=80=98static=E2=80=99 is a special lifetime. It =
signals that something has the lifetime of the entire program. Most Rust pr=
ogrammers first come across <code>'static</code> when dealing with strings:=
</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: &amp;<span class=3D"ot">'s=
tatic</span> <span class=3D"kw">str</span> =3D <span class=3D"st">"Hello, w=
orld."</span>;</code></pre></div>
  <p>String literals have the type <code>&amp;'static str</code> because th=
e reference is always alive: they are baked into the data segment of the fi=
nal binary. Another example are globals:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">static</span> FOO: <span class=3D"kw">i3=
2</span> =3D <span class=3D"dv">5</span>;
  <span class=3D"kw">let</span> x: &amp;<span class=3D"ot">'static</span> <=
span class=3D"kw">i32</span> =3D &amp;FOO;</code></pre></div>
  <p>This adds an <code>i32</code> to the data segment of the binary, and <=
code>x</code> is a reference to it.</p>
  <h4 id=3D"lifetime-elision">Lifetime Elision</h4>
  <p>Rust supports powerful local type inference in function bodies, but it=
=E2=80=99s forbidden in item signatures to allow reasoning about the types =
just based in the item signature alone. However, for ergonomic reasons a ve=
ry restricted secondary inference algorithm called =E2=80=9Clifetime elisio=
n=E2=80=9D applies in function signatures. It infers only based on the sign=
ature components themselves and not based on the body of the function, only=
 infers lifetime parameters, and does this with only three easily memorizab=
le and unambiguous rules. This makes lifetime elision a shorthand for writi=
ng an item signature, while not hiding away the actual types involved as fu=
ll local inference would if applied to it.</p>
  <p>When talking about lifetime elision, we use the term <em>input lifetim=
e</em> and <em>output lifetime</em>. An <em>input lifetime</em> is a lifeti=
me associated with a parameter of a function, and an <em>output lifetime</e=
m> is a lifetime associated with the return value of a function. For exampl=
e, this function has an input lifetime:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo&lt;<span class=3D"ot">'a</=
span>&gt;(bar: &amp;<span class=3D"ot">'a</span> <span class=3D"kw">str</sp=
an>)</code></pre></div>
  <p>This one has an output lifetime:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo&lt;<span class=3D"ot">'a</=
span>&gt;() -&gt; &amp;<span class=3D"ot">'a</span> <span class=3D"kw">str<=
/span></code></pre></div>
  <p>This one has a lifetime in both positions:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo&lt;<span class=3D"ot">'a</=
span>&gt;(bar: &amp;<span class=3D"ot">'a</span> <span class=3D"kw">str</sp=
an>) -&gt; &amp;<span class=3D"ot">'a</span> <span class=3D"kw">str</span><=
/code></pre></div>
  <p>Here are the three rules:</p>
  <ul>
  <li><p>Each elided lifetime in a function=E2=80=99s arguments becomes a d=
istinct lifetime parameter.</p></li>
  <li><p>If there is exactly one input lifetime, elided or not, that lifeti=
me is assigned to all elided lifetimes in the return values of that functio=
n.</p></li>
  <li><p>If there are multiple input lifetimes, but one of them is <code>&a=
mp;self</code> or <code>&amp;mut   self</code>, the lifetime of <code>self<=
/code> is assigned to all elided output lifetimes.</p></li>
  </ul>
  <p>Otherwise, it is an error to elide an output lifetime.</p>
  <h5 id=3D"examples">Examples</h5>
  <p>Here are some examples of functions with elided lifetimes. We=E2=80=99=
ve paired each example of an elided lifetime with its expanded form.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> print(s: &amp;<span class=3D"k=
w">str</span>); <span class=3D"co">// elided</span>
  <span class=3D"kw">fn</span> print&lt;<span class=3D"ot">'a</span>&gt;(s:=
 &amp;<span class=3D"ot">'a</span> <span class=3D"kw">str</span>); <span cl=
ass=3D"co">// expanded</span>
 =20
  <span class=3D"kw">fn</span> debug(lvl: <span class=3D"kw">u32</span>, s:=
 &amp;<span class=3D"kw">str</span>); <span class=3D"co">// elided</span>
  <span class=3D"kw">fn</span> debug&lt;<span class=3D"ot">'a</span>&gt;(lv=
l: <span class=3D"kw">u32</span>, s: &amp;<span class=3D"ot">'a</span> <spa=
n class=3D"kw">str</span>); <span class=3D"co">// expanded</span>
 =20
  <span class=3D"co">// In the preceding example, `lvl` doesn=E2=80=99t nee=
d a lifetime because it=E2=80=99s not a</span>
  <span class=3D"co">// reference (`&amp;`). Only things relating to refere=
nces (such as a `struct`</span>
  <span class=3D"co">// which contains a reference) need lifetimes.</span>
 =20
  <span class=3D"kw">fn</span> substr(s: &amp;<span class=3D"kw">str</span>=
, until: <span class=3D"kw">u32</span>) -&gt; &amp;<span class=3D"kw">str</=
span>; <span class=3D"co">// elided</span>
  <span class=3D"kw">fn</span> substr&lt;<span class=3D"ot">'a</span>&gt;(s=
: &amp;<span class=3D"ot">'a</span> <span class=3D"kw">str</span>, until: <=
span class=3D"kw">u32</span>) -&gt; &amp;<span class=3D"ot">'a</span> <span=
 class=3D"kw">str</span>; <span class=3D"co">// expanded</span>
 =20
  <span class=3D"kw">fn</span> get_str() -&gt; &amp;<span class=3D"kw">str<=
/span>; <span class=3D"co">// ILLEGAL, no inputs</span>
 =20
  <span class=3D"kw">fn</span> frob(s: &amp;<span class=3D"kw">str</span>, =
t: &amp;<span class=3D"kw">str</span>) -&gt; &amp;<span class=3D"kw">str</s=
pan>; <span class=3D"co">// ILLEGAL, two inputs</span>
  <span class=3D"kw">fn</span> frob&lt;<span class=3D"ot">'a</span>, <span =
class=3D"ot">'b</span>&gt;(s: &amp;<span class=3D"ot">'a</span> <span class=
=3D"kw">str</span>, t: &amp;<span class=3D"ot">'b</span> <span class=3D"kw"=
>str</span>) -&gt; &amp;<span class=3D"kw">str</span>; <span class=3D"co">/=
/ Expanded: Output lifetime is unclear</span>
 =20
  <span class=3D"kw">fn</span> get_mut(&amp;<span class=3D"kw">mut</span> <=
span class=3D"kw">self</span>) -&gt; &amp;<span class=3D"kw">mut</span> T; =
<span class=3D"co">// elided</span>
  <span class=3D"kw">fn</span> get_mut&lt;<span class=3D"ot">'a</span>&gt;(=
&amp;<span class=3D"ot">'a</span> <span class=3D"kw">mut</span> <span class=
=3D"kw">self</span>) -&gt; &amp;<span class=3D"ot">'a</span> <span class=3D=
"kw">mut</span> T; <span class=3D"co">// expanded</span>
 =20
  <span class=3D"kw">fn</span> args&lt;T:ToCStr&gt;(&amp;<span class=3D"kw"=
>mut</span> <span class=3D"kw">self</span>, args: &amp;[T]) -&gt; &amp;<spa=
n class=3D"kw">mut</span> Command <span class=3D"co">// elided</span>
  <span class=3D"kw">fn</span> args&lt;<span class=3D"ot">'a</span>, <span =
class=3D"ot">'b</span>, T:ToCStr&gt;(&amp;<span class=3D"ot">'a</span> <spa=
n class=3D"kw">mut</span> <span class=3D"kw">self</span>, args: &amp;<span =
class=3D"ot">'b</span> [T]) -&gt; &amp;<span class=3D"ot">'a</span> <span c=
lass=3D"kw">mut</span> Command <span class=3D"co">// expanded</span>
 =20
  <span class=3D"kw">fn</span> new(buf: &amp;<span class=3D"kw">mut</span> =
[<span class=3D"kw">u8</span>]) -&gt; BufWriter; <span class=3D"co">// elid=
ed</span>
  <span class=3D"kw">fn</span> new&lt;<span class=3D"ot">'a</span>&gt;(buf:=
 &amp;<span class=3D"ot">'a</span> <span class=3D"kw">mut</span> [<span cla=
ss=3D"kw">u8</span>]) -&gt; BufWriter&lt;<span class=3D"ot">'a</span>&gt; <=
span class=3D"co">// expanded</span></code></pre></div>
  <h2 id=3D"sec--mutability">Mutability</h2>
  <p>Mutability, the ability to change something, works a bit differently i=
n Rust than in other languages. The first aspect of mutability is its non-d=
efault status:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
  x =3D <span class=3D"dv">6</span>; <span class=3D"co">// error!</span></c=
ode></pre></div>
  <p>We can introduce mutability with the <code>mut</code> keyword:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
 =20
  x =3D <span class=3D"dv">6</span>; <span class=3D"co">// no problem!</spa=
n></code></pre></div>
  <p>This is a mutable <a href=3D"https://killercup.github.io/trpl-ebook/tr=
pl-2015-05-13.html#sec--variable-bindings">variable binding</a>. When a bin=
ding is mutable, it means you=E2=80=99re allowed to change what the binding=
 points to. So in the above example, it=E2=80=99s not so much that the valu=
e at <code>x</code> is changing, but that the binding changed from one <cod=
e>i32</code> to another.</p>
  <p>If you want to change what the binding points to, you=E2=80=99ll need =
a <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#se=
c--references-and-borrowing">mutable reference</a>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
  <span class=3D"kw">let</span> y =3D &amp;<span class=3D"kw">mut</span> x;=
</code></pre></div>
  <p><code>y</code> is an immutable binding to a mutable reference, which m=
eans that you can=E2=80=99t bind <code>y</code> to something else (<code>y =
=3D &amp;mut z</code>), but you can mutate the thing that=E2=80=99s bound t=
o <code>y</code>. (<code>*y =3D 5</code>) A subtle distinction.</p>
  <p>Of course, if you need both:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> y =3D &amp;<s=
pan class=3D"kw">mut</span> x;</code></pre></div>
  <p>Now <code>y</code> can be bound to another value, and the value it=E2=
=80=99s referencing can be changed.</p>
  <p>It=E2=80=99s important to note that <code>mut</code> is part of a <a h=
ref=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--pat=
terns">pattern</a>, so you can do things like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> (<span class=3D"kw">mut</span=
> x, y) =3D (<span class=3D"dv">5</span>, <span class=3D"dv">6</span>);
 =20
  <span class=3D"kw">fn</span> foo(<span class=3D"kw">mut</span> x: <span c=
lass=3D"kw">i32</span>) {</code></pre></div>
  <h3 id=3D"interior-vs.exterior-mutability">Interior vs.&nbsp;Exterior Mut=
ability</h3>
  <p>However, when we say something is =E2=80=98immutable=E2=80=99 in Rust,=
 that doesn=E2=80=99t mean that it=E2=80=99s not able to be changed: We mea=
n something has =E2=80=98exterior mutability=E2=80=99. Consider, for exampl=
e, <a href=3D"http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&=
lt;T&gt;</code></a>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::sync::Arc;
 =20
  <span class=3D"kw">let</span> x =3D Arc::new(<span class=3D"dv">5</span>)=
;
  <span class=3D"kw">let</span> y =3D x.clone();</code></pre></div>
  <p>When we call <code>clone()</code>, the <code>Arc&lt;T&gt;</code> needs=
 to update the reference count. Yet we=E2=80=99ve not used any <code>mut</c=
ode>s here, <code>x</code> is an immutable binding, and we didn=E2=80=99t t=
ake <code>&amp;mut 5</code> or anything. So what gives?</p>
  <p>To understand this, we have to go back to the core of Rust=E2=80=99s g=
uiding philosophy, memory safety, and the mechanism by which Rust guarantee=
s it, the <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13=
.html#sec--ownership">ownership</a> system, and more specifically, <a href=
=3D"https://killercup.github.io/trpl-ebook/borrowing.html#The-Rules">borrow=
ing</a>:</p>
  <blockquote>
  <p>You may have one or the other of these two kinds of borrows, but not b=
oth at the same time:</p>
  <ul>
  <li>one or more references (<code>&amp;T</code>) to a resource.</li>
  <li>exactly one mutable reference (<code>&amp;mut T</code>)</li>
  </ul>
  </blockquote>
  <p>So, that=E2=80=99s the real definition of =E2=80=98immutability=E2=80=
=99: is this safe to have two pointers to? In <code>Arc&lt;T&gt;</code>=E2=
=80=99s case, yes: the mutation is entirely contained inside the structure =
itself. It=E2=80=99s not user facing. For this reason, it hands out <code>&=
amp;T</code> with <code>clone()</code>. If it handed out <code>&amp;mut T</=
code>s, though, that would be a problem.</p>
  <p>Other types, like the ones in the <a href=3D"http://doc.rust-lang.org/=
std/cell/index.html"><code>std::cell</code></a> module, have the opposite: =
interior mutability. For example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::cell::RefCell;
 =20
  <span class=3D"kw">let</span> x =3D RefCell::new(<span class=3D"dv">42</s=
pan>);
 =20
  <span class=3D"kw">let</span> y =3D x.borrow_mut();</code></pre></div>
  <p>RefCell hands out <code>&amp;mut</code> references to what=E2=80=99s i=
nside of it with the <code>borrow_mut()</code> method. Isn=E2=80=99t that d=
angerous? What if we do:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::cell::RefCell;
 =20
  <span class=3D"kw">let</span> x =3D RefCell::new(<span class=3D"dv">42</s=
pan>);
 =20
  <span class=3D"kw">let</span> y =3D x.borrow_mut();
  <span class=3D"kw">let</span> z =3D x.borrow_mut();</code></pre></div>
  <p>This will in fact panic, at runtime. This is what <code>RefCell</code>=
 does: it enforces Rust=E2=80=99s borrowing rules at runtime, and <code>pan=
ic!</code>s if they=E2=80=99re violated. This allows us to get around anoth=
er aspect of Rust=E2=80=99s mutability rules. Let=E2=80=99s talk about it f=
irst.</p>
  <h4 id=3D"field-level-mutability">Field-level mutability</h4>
  <p>Mutability is a property of either a borrow (<code>&amp;mut</code>) or=
 a binding (<code>let mut</code>). This means that, for example, you cannot=
 have a <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.h=
tml#sec--structs"><code>struct</code></a> with some fields mutable and some=
 immutable:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      <span class=3D"kw">mut</span> y: <span class=3D"kw">i32</span>, <span=
 class=3D"co">// nope</span>
  }</code></pre></div>
  <p>The mutability of a struct is in its binding:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> a =3D Point {=
 x: <span class=3D"dv">5</span>, y: <span class=3D"dv">6</span> };
 =20
  a.x =3D <span class=3D"dv">10</span>;
 =20
  <span class=3D"kw">let</span> b =3D Point { x: <span class=3D"dv">5</span=
>, y: <span class=3D"dv">6</span>};
 =20
  b.x =3D <span class=3D"dv">10</span>; <span class=3D"co">// error: cannot=
 assign to immutable field `b.x`</span></code></pre></div>
  <p>However, by using <code>Cell&lt;T&gt;</code>, you can emulate field-le=
vel mutability:</p>
  <pre><code>use std::cell::Cell;
 =20
  struct Point {
      x: i32,
      y: Cell&lt;i32&gt;,
  }
 =20
  let point =3D Point { x: 5, y: Cell::new(6) };
 =20
  point.y.set(7);
 =20
  println!("y: {:?}", point.y);</code></pre>
  <p>This will print <code>y: Cell { value: 7 }</code>. We=E2=80=99ve succe=
ssfully updated <code>y</code>.</p>
  <h2 id=3D"sec--structs">Structs</h2>
  <p>Structs are a way of creating more complex data types. For example, if=
 we were doing calculations involving coordinates in 2D space, we would nee=
d both an <code>x</code> and a <code>y</code> value:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> origin_x =3D <span class=3D"d=
v">0</span>;
  <span class=3D"kw">let</span> origin_y =3D <span class=3D"dv">0</span>;</=
code></pre></div>
  <p>A struct lets us combine these two into a single, unified datatype:</p=
>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> origin =3D Point { x: <span class=3D"dv=
">0</span>, y: <span class=3D"dv">0</span> }; <span class=3D"co">// origin:=
 Point</span>
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The origin is =
at ({}, {})"</span>, origin.x, origin.y);
  }</code></pre></div>
  <p>There=E2=80=99s a lot going on here, so let=E2=80=99s break it down. W=
e declare a <code>struct</code> with the <code>struct</code> keyword, and t=
hen with a name. By convention, <code>struct</code>s begin with a capital l=
etter and are camel cased: <code>PointInSpace</code>, not <code>Point_In_Sp=
ace</code>.</p>
  <p>We can create an instance of our struct via <code>let</code>, as usual=
, but we use a <code>key: value</code> style syntax to set each field. The =
order doesn=E2=80=99t need to be the same as in the original declaration.</=
p>
  <p>Finally, because fields have names, we can access the field through do=
t notation: <code>origin.x</code>.</p>
  <p>The values in structs are immutable by default, like other bindings in=
 Rust. Use <code>mut</code> to make them mutable:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> point =3D=
 Point { x: <span class=3D"dv">0</span>, y: <span class=3D"dv">0</span> };
 =20
      point.x =3D <span class=3D"dv">5</span>;
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"The point is a=
t ({}, {})"</span>, point.x, point.y);
  }</code></pre></div>
  <p>This will print <code>The point is at (5, 0)</code>.</p>
  <p>Rust does not support field mutability at the language level, so you c=
annot write something like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point {
      <span class=3D"kw">mut</span> x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
  }</code></pre></div>
  <p>Mutability is a property of the binding, not of the structure itself. =
If you=E2=80=99re used to field-level mutability, this may seem strange at =
first, but it significantly simplifies things. It even lets you make things=
 mutable for a short time only:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> point =3D=
 Point { x: <span class=3D"dv">0</span>, y: <span class=3D"dv">0</span> };
 =20
      point.x =3D <span class=3D"dv">5</span>;
 =20
      <span class=3D"kw">let</span> point =3D point; <span class=3D"co">// =
this new binding can=E2=80=99t change now</span>
 =20
      point.y =3D <span class=3D"dv">6</span>; <span class=3D"co">// this c=
auses an error</span>
  }</code></pre></div>
  <h3 id=3D"update-syntax">Update syntax</h3>
  <p>A <code>struct</code> can include <code>..</code> to indicate that you=
 want to use a copy of some other struct for some of the values. For exampl=
e:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point3d {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
      z: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> point =3D Poi=
nt3d { x: <span class=3D"dv">0</span>, y: <span class=3D"dv">0</span>, z: <=
span class=3D"dv">0</span> };
  point =3D Point3d { y: <span class=3D"dv">1</span>, .. point };</code></p=
re></div>
  <p>This gives <code>point</code> a new <code>y</code>, but keeps the old =
<code>x</code> and <code>z</code> values. It doesn=E2=80=99t have to be the=
 same <code>struct</code> either, you can use this syntax when making new o=
nes, and it will copy the values you don=E2=80=99t specify:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> origin =3D Point3d { x: <span=
 class=3D"dv">0</span>, y: <span class=3D"dv">0</span>, z: <span class=3D"d=
v">0</span> };
  <span class=3D"kw">let</span> point =3D Point3d { z: <span class=3D"dv">1=
</span>, x: <span class=3D"dv">2</span>, .. origin };</code></pre></div>
  <h3 id=3D"tuple-structs">Tuple structs</h3>
  <p>Rust has another data type that=E2=80=99s like a hybrid between a <a h=
ref=3D"https://killercup.github.io/trpl-ebook/primitive-types.html#tuples">=
tuple</a> and a struct, called a =E2=80=98tuple struct=E2=80=99. Tuple stru=
cts have a name, but their fields don=E2=80=99t:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Color(<span class=3D"kw">i=
32</span>, <span class=3D"kw">i32</span>, <span class=3D"kw">i32</span>);
  <span class=3D"kw">struct</span> Point(<span class=3D"kw">i32</span>, <sp=
an class=3D"kw">i32</span>, <span class=3D"kw">i32</span>);</code></pre></d=
iv>
  <p>These two will not be equal, even if they have the same values:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> black =3D Color(<span class=
=3D"dv">0</span>, <span class=3D"dv">0</span>, <span class=3D"dv">0</span>)=
;
  <span class=3D"kw">let</span> origin =3D Point(<span class=3D"dv">0</span=
>, <span class=3D"dv">0</span>, <span class=3D"dv">0</span>);</code></pre><=
/div>
  <p>It is almost always better to use a struct than a tuple struct. We wou=
ld write <code>Color</code> and <code>Point</code> like this instead:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Color {
      red: <span class=3D"kw">i32</span>,
      blue: <span class=3D"kw">i32</span>,
      green: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
      z: <span class=3D"kw">i32</span>,
  }</code></pre></div>
  <p>Now, we have actual names, rather than positions. Good names are impor=
tant, and with a struct, we have actual names.</p>
  <p>There <em>is</em> one case when a tuple struct is very useful, though,=
 and that=E2=80=99s a tuple struct with only one element. We call this the =
=E2=80=98newtype=E2=80=99 pattern, because it allows you to create a new ty=
pe, distinct from that of its contained value and expressing its own semant=
ic meaning:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Inches(<span class=3D"kw">=
i32</span>);
 =20
  <span class=3D"kw">let</span> length =3D Inches(<span class=3D"dv">10</sp=
an>);
 =20
  <span class=3D"kw">let</span> Inches(integer_length) =3D length;
  <span class=3D"ot">println!</span>(<span class=3D"st">"length is {} inche=
s"</span>, integer_length);</code></pre></div>
  <p>As you can see here, you can extract the inner integer type through a =
destructuring <code>let</code>, just as with regular tuples. In this case, =
the <code>let Inches(integer_length)</code> assigns <code>10</code> to <cod=
e>integer_length</code>.</p>
  <h3 id=3D"unit-like-structs">Unit-like structs</h3>
  <p>You can define a struct with no members at all:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Electron;</code></pre></di=
v>
  <p>Such a struct is called =E2=80=98unit-like=E2=80=99 because it resembl=
es the empty tuple, <code>()</code>, sometimes called =E2=80=98unit=E2=80=
=99. Like a tuple struct, it defines a new type.</p>
  <p>This is rarely useful on its own (although sometimes it can serve as a=
 marker type), but in combination with other features, it can become useful=
. For instance, a library may ask you to create a structure that implements=
 a certain [trait][trait] to handle events. If you don=E2=80=99t have any d=
ata you need to store in the structure, you can just create a unit-like str=
uct.</p>
  <h2 id=3D"sec--enums">Enums</h2>
  <p>An <code>enum</code> in Rust is a type that represents data that could=
 be one of several possible variants:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> Message {
      Quit,
      ChangeColor(<span class=3D"kw">i32</span>, <span class=3D"kw">i32</sp=
an>, <span class=3D"kw">i32</span>),
      Move { x: <span class=3D"kw">i32</span>, y: <span class=3D"kw">i32</s=
pan> },
      Write(String),
  }</code></pre></div>
  <p>Each variant can optionally have data associated with it. The syntax f=
or defining variants resembles the syntaxes used to define structs: you can=
 have variants with no data (like unit-like structs), variants with named d=
ata, and variants with unnamed data (like tuple structs). Unlike separate s=
truct definitions, however, an <code>enum</code> is a single type. A value =
of the enum can match any of the variants. For this reason, an enum is some=
times called a =E2=80=98sum type=E2=80=99: the set of possible values of th=
e enum is the sum of the sets of possible values for each variant.</p>
  <p>We use the <code>::</code> syntax to use the name of each variant: the=
y=E2=80=99re scoped by the name of the <code>enum</code> itself. This allow=
s both of these to work:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: Message =3D Message::Move =
{ x: <span class=3D"dv">3</span>, y: <span class=3D"dv">4</span> };
 =20
  <span class=3D"kw">enum</span> BoardGameTurn {
      Move { squares: <span class=3D"kw">i32</span> },
      Pass,
  }
 =20
  <span class=3D"kw">let</span> y: BoardGameTurn =3D BoardGameTurn::Move { =
squares: <span class=3D"dv">1</span> };</code></pre></div>
  <p>Both variants are named <code>Move</code>, but since they=E2=80=99re s=
coped to the name of the enum, they can both be used without conflict.</p>
  <p>A value of an enum type contains information about which variant it is=
, in addition to any data associated with that variant. This is sometimes r=
eferred to as a =E2=80=98tagged union=E2=80=99, since the data includes a =
=E2=80=98tag=E2=80=99 indicating what type it is. The compiler uses this in=
formation to enforce that you=E2=80=99re accessing the data in the enum saf=
ely. For instance, you can=E2=80=99t simply try to destructure a value as i=
f it were one of the possible variants:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> process_color_change(msg: Mess=
age) {
      <span class=3D"kw">let</span> Message::ChangeColor(r, g, b) =3D msg; =
<span class=3D"co">// compile-time error</span>
  }</code></pre></div>
  <p>Both variants are named <code>Digit</code>, but since they=E2=80=99re =
scoped to the <code>enum</code> name there=E2=80=99s no ambiguity.</p>
  <p>Not supporting these operations may seem rather limiting, but it=E2=80=
=99s a limitation which we can overcome. There are two ways: by implementin=
g equality ourselves, or by pattern matching variants with <a href=3D"https=
://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--match"><code>ma=
tch</code></a> expressions, which you=E2=80=99ll learn in the next section.=
 We don=E2=80=99t know enough about Rust to implement equality yet, but we=
=E2=80=99ll find out in the [<code>traits</code>][traits] section.</p>
  <h2 id=3D"sec--match">Match</h2>
  <p>Often, a simple <a href=3D"https://killercup.github.io/trpl-ebook/trpl=
-2015-05-13.html#sec--if"><code>if</code></a>/<code>else</code> isn=E2=80=
=99t enough, because you have more than two possible options. Also, conditi=
ons can get quite complex. Rust has a keyword, <code>match</code>, that all=
ows you to replace complicated <code>if</code>/<code>else</code> groupings =
with something more powerful. Check it out:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
 =20
  <span class=3D"kw">match</span> x {
      <span class=3D"dv">1</span> =3D&gt; <span class=3D"ot">println!</span=
>(<span class=3D"st">"one"</span>),
      <span class=3D"dv">2</span> =3D&gt; <span class=3D"ot">println!</span=
>(<span class=3D"st">"two"</span>),
      <span class=3D"dv">3</span> =3D&gt; <span class=3D"ot">println!</span=
>(<span class=3D"st">"three"</span>),
      <span class=3D"dv">4</span> =3D&gt; <span class=3D"ot">println!</span=
>(<span class=3D"st">"four"</span>),
      <span class=3D"dv">5</span> =3D&gt; <span class=3D"ot">println!</span=
>(<span class=3D"st">"five"</span>),
      _ =3D&gt; <span class=3D"ot">println!</span>(<span class=3D"st">"some=
thing else"</span>),
  }</code></pre></div>
  <p><code>match</code> takes an expression and then branches based on its =
value. Each =E2=80=98arm=E2=80=99 of the branch is of the form <code>val =
=3D&gt; expression</code>. When the value matches, that arm=E2=80=99s expre=
ssion will be evaluated. It=E2=80=99s called <code>match</code> because of =
the term =E2=80=98pattern matching=E2=80=99, which <code>match</code> is an=
 implementation of. There=E2=80=99s an <a href=3D"https://killercup.github.=
io/trpl-ebook/trpl-2015-05-13.html#sec--patterns">entire section on pattern=
s</a> that covers all the patterns that are possible here.</p>
  <p>So what=E2=80=99s the big advantage? Well, there are a few. First of a=
ll, <code>match</code> enforces =E2=80=98exhaustiveness checking=E2=80=99. =
Do you see that last arm, the one with the underscore (<code>_</code>)? If =
we remove that arm, Rust will give us an error:</p>
  <pre><code>error: non-exhaustive patterns: `_` not covered</code></pre>
  <p>In other words, Rust is trying to tell us we forgot a value. Because <=
code>x</code> is an integer, Rust knows that it can have a number of differ=
ent values =E2=80=93 for example, <code>6</code>. Without the <code>_</code=
>, however, there is no arm that could match, and so Rust refuses to compil=
e the code. <code>_</code> acts like a =E2=80=98catch-all arm=E2=80=99. If =
none of the other arms match, the arm with <code>_</code> will, and since w=
e have this catch-all arm, we now have an arm for every possible value of <=
code>x</code>, and so our program will compile successfully.</p>
  <p><code>match</code> is also an expression, which means we can use it on=
 the right-hand side of a <code>let</code> binding or directly where an exp=
ression is used:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
 =20
  <span class=3D"kw">let</span> number =3D <span class=3D"kw">match</span> =
x {
      <span class=3D"dv">1</span> =3D&gt; <span class=3D"st">"one"</span>,
      <span class=3D"dv">2</span> =3D&gt; <span class=3D"st">"two"</span>,
      <span class=3D"dv">3</span> =3D&gt; <span class=3D"st">"three"</span>=
,
      <span class=3D"dv">4</span> =3D&gt; <span class=3D"st">"four"</span>,
      <span class=3D"dv">5</span> =3D&gt; <span class=3D"st">"five"</span>,
      _ =3D&gt; <span class=3D"st">"something else"</span>,
  };</code></pre></div>
  <p>Sometimes it=E2=80=99s a nice way of converting something from one typ=
e to another.</p>
  <h3 id=3D"matching-on-enums">Matching on enums</h3>
  <p>Another important use of the <code>match</code> keyword is to process =
the possible variants of an enum:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> Message {
      Quit,
      ChangeColor(<span class=3D"kw">i32</span>, <span class=3D"kw">i32</sp=
an>, <span class=3D"kw">i32</span>),
      Move { x: <span class=3D"kw">i32</span>, y: <span class=3D"kw">i32</s=
pan> },
      Write(String),
  }
 =20
  <span class=3D"kw">fn</span> quit() { <span class=3D"co">/* ... */</span>=
 }
  <span class=3D"kw">fn</span> change_color(r: <span class=3D"kw">i32</span=
>, g: <span class=3D"kw">i32</span>, b: <span class=3D"kw">i32</span>) { <s=
pan class=3D"co">/* ... */</span> }
  <span class=3D"kw">fn</span> move_cursor(x: <span class=3D"kw">i32</span>=
, y: <span class=3D"kw">i32</span>) { <span class=3D"co">/* ... */</span> }
 =20
  <span class=3D"kw">fn</span> process_message(msg: Message) {
      <span class=3D"kw">match</span> msg {
          Message::Quit =3D&gt; quit(),
          Message::ChangeColor(r, g, b) =3D&gt; change_color(r, g, b),
          Message::Move { x: x, y: y } =3D&gt; move_cursor(x, y),
          Message::Write(s) =3D&gt; <span class=3D"ot">println!</span>(<spa=
n class=3D"st">"{}"</span>, s),
      };
  }</code></pre></div>
  <p>Again, the Rust compiler checks exhaustiveness, so it demands that you=
 have a match arm for every variant of the enum. If you leave one off, it w=
ill give you a compile-time error unless you use <code>_</code>.</p>
  <p>Unlike the previous uses of <code>match</code>, you can=E2=80=99t use =
the normal <code>if</code> statement to do this. You can use the [<code>if =
let</code>][if-let] statement, which can be seen as an abbreviated form of =
<code>match</code>.</p>
  <p>[if-let][if-let.html]</p>
  <h2 id=3D"sec--patterns">Patterns</h2>
  <p>Patterns are quite common in Rust. We use them in <a href=3D"https://k=
illercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--variable-bindings">=
variable bindings</a>, <a href=3D"https://killercup.github.io/trpl-ebook/tr=
pl-2015-05-13.html#sec--match">match statements</a>, and other places, too.=
 Let=E2=80=99s go on a whirlwind tour of all of the things patterns can do!=
</p>
  <p>A quick refresher: you can match against literals directly, and <code>=
_</code> acts as an =E2=80=98any=E2=80=99 case:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">1</s=
pan>;
 =20
  <span class=3D"kw">match</span> x {
      <span class=3D"dv">1</span> =3D&gt; <span class=3D"ot">println!</span=
>(<span class=3D"st">"one"</span>),
      <span class=3D"dv">2</span> =3D&gt; <span class=3D"ot">println!</span=
>(<span class=3D"st">"two"</span>),
      <span class=3D"dv">3</span> =3D&gt; <span class=3D"ot">println!</span=
>(<span class=3D"st">"three"</span>),
      _ =3D&gt; <span class=3D"ot">println!</span>(<span class=3D"st">"anyt=
hing"</span>),
  }</code></pre></div>
  <p>This prints <code>one</code>.</p>
  <h3 id=3D"multiple-patterns">Multiple patterns</h3>
  <p>You can match multiple patterns with <code>|</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">1</s=
pan>;
 =20
  <span class=3D"kw">match</span> x {
      <span class=3D"dv">1</span> | <span class=3D"dv">2</span> =3D&gt; <sp=
an class=3D"ot">println!</span>(<span class=3D"st">"one or two"</span>),
      <span class=3D"dv">3</span> =3D&gt; <span class=3D"ot">println!</span=
>(<span class=3D"st">"three"</span>),
      _ =3D&gt; <span class=3D"ot">println!</span>(<span class=3D"st">"anyt=
hing"</span>),
  }</code></pre></div>
  <p>This prints <code>one or two</code>.</p>
  <h3 id=3D"ranges">Ranges</h3>
  <p>You can match a range of values with <code>...</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">1</s=
pan>;
 =20
  <span class=3D"kw">match</span> x {
      <span class=3D"dv">1</span> ... <span class=3D"dv">5</span> =3D&gt; <=
span class=3D"ot">println!</span>(<span class=3D"st">"one through five"</sp=
an>),
      _ =3D&gt; <span class=3D"ot">println!</span>(<span class=3D"st">"anyt=
hing"</span>),
  }</code></pre></div>
  <p>This prints <code>one through five</code>.</p>
  <p>Ranges are mostly used with integers and <code>char</code>s:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"ch">'=F0=
=9F=92=85'</span>;
 =20
  <span class=3D"kw">match</span> x {
      <span class=3D"ch">'a'</span> ... <span class=3D"ch">'j'</span> =3D&g=
t; <span class=3D"ot">println!</span>(<span class=3D"st">"early letter"</sp=
an>),
      <span class=3D"ch">'k'</span> ... <span class=3D"ch">'z'</span> =3D&g=
t; <span class=3D"ot">println!</span>(<span class=3D"st">"late letter"</spa=
n>),
      _ =3D&gt; <span class=3D"ot">println!</span>(<span class=3D"st">"some=
thing else"</span>),
  }</code></pre></div>
  <p>This prints <code>something else</code></p>
  <h3 id=3D"bindings">Bindings</h3>
  <p>You can bind values to names with <code>@</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">1</s=
pan>;
 =20
  <span class=3D"kw">match</span> x {
      e @ <span class=3D"dv">1</span> ... <span class=3D"dv">5</span> =3D&g=
t; <span class=3D"ot">println!</span>(<span class=3D"st">"got a range eleme=
nt {}"</span>, e),
      _ =3D&gt; <span class=3D"ot">println!</span>(<span class=3D"st">"anyt=
hing"</span>),
  }</code></pre></div>
  <p>This prints <code>got a range element 1</code>. This is useful when yo=
u want to do a complicated match of part of a data structure:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>derive<span class=3D"ot">(</spa=
n>Debug<span class=3D"ot">)]</span>
  <span class=3D"kw">struct</span> Person {
      name: <span class=3D"kw">Option</span>&lt;String&gt;,
  }
 =20
  <span class=3D"kw">let</span> name =3D <span class=3D"st">"Steve"</span>.=
to_string();
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> x: <span clas=
s=3D"kw">Option</span>&lt;Person&gt; =3D <span class=3D"kw">Some</span>(Per=
son { name: <span class=3D"kw">Some</span>(name) });
  <span class=3D"kw">match</span> x {
      <span class=3D"kw">Some</span>(Person { name: <span class=3D"kw">ref<=
/span> a @ <span class=3D"kw">Some</span>(_), .. }) =3D&gt; <span class=3D"=
ot">println!</span>(<span class=3D"st">"{:?}"</span>, a),
      _ =3D&gt; {}
  }</code></pre></div>
  <p>This prints <code>Some("Steve")</code>: We=E2=80=99ve bound the inner =
<code>name</code> to <code>a</code>.</p>
  <p>If you use <code>@</code> with <code>|</code>, you need to make sure t=
he name is bound in each part of the pattern:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
 =20
  <span class=3D"kw">match</span> x {
      e @ <span class=3D"dv">1</span> ... <span class=3D"dv">5</span> | e @=
 <span class=3D"dv">8</span> ... <span class=3D"dv">10</span> =3D&gt; <span=
 class=3D"ot">println!</span>(<span class=3D"st">"got a range element {}"</=
span>, e),
      _ =3D&gt; <span class=3D"ot">println!</span>(<span class=3D"st">"anyt=
hing"</span>),
  }</code></pre></div>
  <h3 id=3D"ignoring-variants">Ignoring variants</h3>
  <p>If you=E2=80=99re matching on an enum which has variants, you can use =
<code>..</code> to ignore the value and type in the variant:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> OptionalInt {
      Value(<span class=3D"kw">i32</span>),
      Missing,
  }
 =20
  <span class=3D"kw">let</span> x =3D OptionalInt::Value(<span class=3D"dv"=
>5</span>);
 =20
  <span class=3D"kw">match</span> x {
      OptionalInt::Value(..) =3D&gt; <span class=3D"ot">println!</span>(<sp=
an class=3D"st">"Got an int!"</span>),
      OptionalInt::Missing =3D&gt; <span class=3D"ot">println!</span>(<span=
 class=3D"st">"No such luck."</span>),
  }</code></pre></div>
  <p>This prints <code>Got an int!</code>.</p>
  <h3 id=3D"guards">Guards</h3>
  <p>You can introduce =E2=80=98match guards=E2=80=99 with <code>if</code>:=
</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> OptionalInt {
      Value(<span class=3D"kw">i32</span>),
      Missing,
  }
 =20
  <span class=3D"kw">let</span> x =3D OptionalInt::Value(<span class=3D"dv"=
>5</span>);
 =20
  <span class=3D"kw">match</span> x {
      OptionalInt::Value(i) <span class=3D"kw">if</span> i &gt; <span class=
=3D"dv">5</span> =3D&gt; <span class=3D"ot">println!</span>(<span class=3D"=
st">"Got an int bigger than five!"</span>),
      OptionalInt::Value(..) =3D&gt; <span class=3D"ot">println!</span>(<sp=
an class=3D"st">"Got an int!"</span>),
      OptionalInt::Missing =3D&gt; <span class=3D"ot">println!</span>(<span=
 class=3D"st">"No such luck."</span>),
  }</code></pre></div>
  <p>This prints <code>Got an int!</code></p>
  <h3 id=3D"ref-and-ref-mut">ref and ref mut</h3>
  <p>If you want to get a <a href=3D"https://killercup.github.io/trpl-ebook=
/trpl-2015-05-13.html#sec--references-and-borrowing">reference</a>, use the=
 <code>ref</code> keyword:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
 =20
  <span class=3D"kw">match</span> x {
      <span class=3D"kw">ref</span> r =3D&gt; <span class=3D"ot">println!</=
span>(<span class=3D"st">"Got a reference to {}"</span>, r),
  }</code></pre></div>
  <p>This prints <code>Got a reference to 5</code>.</p>
  <p>Here, the <code>r</code> inside the <code>match</code> has the type <c=
ode>&amp;i32</code>. In other words, the <code>ref</code> keyword <em>creat=
es</em> a reference, for use in the pattern. If you need a mutable referenc=
e, <code>ref mut</code> will work in the same way:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 x =3D <span class=3D"dv">5</span>;
 =20
  <span class=3D"kw">match</span> x {
      <span class=3D"kw">ref</span> <span class=3D"kw">mut</span> mr =3D&gt=
; <span class=3D"ot">println!</span>(<span class=3D"st">"Got a mutable refe=
rence to {}"</span>, mr),
  }</code></pre></div>
  <h3 id=3D"destructuring">Destructuring</h3>
  <p>If you have a compound data type, like a <a href=3D"https://killercup.=
github.io/trpl-ebook/trpl-2015-05-13.html#sec--structs"><code>struct</code>=
</a>, you can destructure it inside of a pattern:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">let</span> origin =3D Point { x: <span class=3D"dv">0<=
/span>, y: <span class=3D"dv">0</span> };
 =20
  <span class=3D"kw">match</span> origin {
      Point { x: x, y: y } =3D&gt; <span class=3D"ot">println!</span>(<span=
 class=3D"st">"({},{})"</span>, x, y),
  }</code></pre></div>
  <p>If we only care about some of the values, we don=E2=80=99t have to giv=
e them all names:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">let</span> origin =3D Point { x: <span class=3D"dv">0<=
/span>, y: <span class=3D"dv">0</span> };
 =20
  <span class=3D"kw">match</span> origin {
      Point { x: x, .. } =3D&gt; <span class=3D"ot">println!</span>(<span c=
lass=3D"st">"x is {}"</span>, x),
  }</code></pre></div>
  <p>This prints <code>x is 0</code>.</p>
  <p>You can do this kind of match on any member, not just the first:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">let</span> origin =3D Point { x: <span class=3D"dv">0<=
/span>, y: <span class=3D"dv">0</span> };
 =20
  <span class=3D"kw">match</span> origin {
      Point { y: y, .. } =3D&gt; <span class=3D"ot">println!</span>(<span c=
lass=3D"st">"y is {}"</span>, y),
  }</code></pre></div>
  <p>This prints <code>y is 0</code>.</p>
  <p>This =E2=80=98destructuring=E2=80=99 behavior works on any compound da=
ta type, like <a href=3D"https://killercup.github.io/trpl-ebook/primitive-t=
ypes.html#tuples">tuples</a> or <a href=3D"https://killercup.github.io/trpl=
-ebook/trpl-2015-05-13.html#sec--enums">enums</a>.</p>
  <h3 id=3D"mix-and-match">Mix and Match</h3>
  <p>Whew! That=E2=80=99s a lot of different ways to match things, and they=
 can all be mixed and matched, depending on what you=E2=80=99re doing:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">match</span> x {
      Foo { x: <span class=3D"kw">Some</span>(<span class=3D"kw">ref</span>=
 name), y: <span class=3D"kw">None</span> } =3D&gt; ...
  }</code></pre></div>
  <p>Patterns are very powerful. Make good use of them.</p>
  <h2 id=3D"sec--method-syntax">Method Syntax</h2>
  <p>Functions are great, but if you want to call a bunch of them on some d=
ata, it can be awkward. Consider this code:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">baz(bar(foo)));</code></pre></div>
  <p>We would read this left-to right, and so we see =E2=80=98baz bar foo=
=E2=80=99. But this isn=E2=80=99t the order that the functions would get ca=
lled in, that=E2=80=99s inside-out: =E2=80=98foo bar baz=E2=80=99. Wouldn=
=E2=80=99t it be nice if we could do this instead?</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">foo.bar().baz();</code></pre></div>
  <p>Luckily, as you may have guessed with the leading question, you can! R=
ust provides the ability to use this =E2=80=98method call syntax=E2=80=99 v=
ia the <code>impl</code> keyword.</p>
  <h3 id=3D"method-calls">Method calls</h3>
  <p>Here=E2=80=99s how it works:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Circle {
      x: <span class=3D"kw">f64</span>,
      y: <span class=3D"kw">f64</span>,
      radius: <span class=3D"kw">f64</span>,
  }
 =20
  <span class=3D"kw">impl</span> Circle {
      <span class=3D"kw">fn</span> area(&amp;<span class=3D"kw">self</span>=
) -&gt; <span class=3D"kw">f64</span> {
          std::<span class=3D"kw">f64</span>::consts::PI * (<span class=3D"=
kw">self</span>.radius * <span class=3D"kw">self</span>.radius)
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> c =3D Circle { x: <span class=3D"dv">0.=
0</span>, y: <span class=3D"dv">0.0</span>, radius: <span class=3D"dv">2.0<=
/span> };
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, c.=
area());
  }</code></pre></div>
  <p>This will print <code>12.566371</code>.</p>
  <p>We=E2=80=99ve made a struct that represents a circle. We then write an=
 <code>impl</code> block, and inside it, define a method, <code>area</code>=
.</p>
  <p>Methods take a special first parameter, of which there are three varia=
nts: <code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</co=
de>. You can think of this first parameter as being the <code>foo</code> in=
 <code>foo.bar()</code>. The three variants correspond to the three kinds o=
f things <code>foo</code> could be: <code>self</code> if it=E2=80=99s just =
a value on the stack, <code>&amp;self</code> if it=E2=80=99s a reference, a=
nd <code>&amp;mut self</code> if it=E2=80=99s a mutable reference. Because =
we took the <code>&amp;self</code> parameter to <code>area</code>, we can u=
se it just like any other parameter. Because we know it=E2=80=99s a <code>C=
ircle</code>, we can access the <code>radius</code> just like we would with=
 any other struct.</p>
  <p>We should default to using <code>&amp;self</code>, as you should prefe=
r borrowing over taking ownership, as well as taking immutable references o=
ver mutable ones. Here=E2=80=99s an example of all three variants:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Circle {
      x: <span class=3D"kw">f64</span>,
      y: <span class=3D"kw">f64</span>,
      radius: <span class=3D"kw">f64</span>,
  }
 =20
  <span class=3D"kw">impl</span> Circle {
      <span class=3D"kw">fn</span> reference(&amp;<span class=3D"kw">self</=
span>) {
         <span class=3D"ot">println!</span>(<span class=3D"st">"taking self=
 by reference!"</span>);
      }
 =20
      <span class=3D"kw">fn</span> mutable_reference(&amp;<span class=3D"kw=
">mut</span> <span class=3D"kw">self</span>) {
         <span class=3D"ot">println!</span>(<span class=3D"st">"taking self=
 by mutable reference!"</span>);
      }
 =20
      <span class=3D"kw">fn</span> takes_ownership(<span class=3D"kw">self<=
/span>) {
         <span class=3D"ot">println!</span>(<span class=3D"st">"taking owne=
rship of self!"</span>);
      }
  }</code></pre></div>
  <h3 id=3D"chaining-method-calls">Chaining method calls</h3>
  <p>So, now we know how to call a method, such as <code>foo.bar()</code>. =
But what about our original example, <code>foo.bar().baz()</code>? This is =
called =E2=80=98method chaining=E2=80=99, and we can do it by returning <co=
de>self</code>.</p>
  <pre><code>struct Circle {
      x: f64,
      y: f64,
      radius: f64,
  }
 =20
  impl Circle {
      fn area(&amp;self) -&gt; f64 {
          std::f64::consts::PI * (self.radius * self.radius)
      }
 =20
      fn grow(&amp;self, increment: f64) -&gt; Circle {
          Circle { x: self.x, y: self.y, radius: self.radius + increment }
      }
  }
 =20
  fn main() {
      let c =3D Circle { x: 0.0, y: 0.0, radius: 2.0 };
      println!("{}", c.area());
 =20
      let d =3D c.grow(2.0).area();
      println!("{}", d);
  }</code></pre>
  <p>Check the return type:</p>
  <pre><code># struct Circle;
  # impl Circle {
  fn grow(&amp;self) -&gt; Circle {
  # Circle } }</code></pre>
  <p>We just say we=E2=80=99re returning a <code>Circle</code>. With this m=
ethod, we can grow a new circle to any arbitrary size.</p>
  <h3 id=3D"associated-functions">Associated functions</h3>
  <p>You can also define associated functions that do not take a <code>self=
</code> parameter. Here=E2=80=99s a pattern that=E2=80=99s very common in R=
ust code:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Circle {
      x: <span class=3D"kw">f64</span>,
      y: <span class=3D"kw">f64</span>,
      radius: <span class=3D"kw">f64</span>,
  }
 =20
  <span class=3D"kw">impl</span> Circle {
      <span class=3D"kw">fn</span> new(x: <span class=3D"kw">f64</span>, y:=
 <span class=3D"kw">f64</span>, radius: <span class=3D"kw">f64</span>) -&gt=
; Circle {
          Circle {
              x: x,
              y: y,
              radius: radius,
          }
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> c =3D Circle::new(<span class=3D"dv">0.=
0</span>, <span class=3D"dv">0.0</span>, <span class=3D"dv">2.0</span>);
  }</code></pre></div>
  <p>This =E2=80=98associated function=E2=80=99 builds a new <code>Circle</=
code> for us. Note that associated functions are called with the <code>Stru=
ct::function()</code> syntax, rather than the <code>ref.method()</code> syn=
tax. Some other langauges call associated functions =E2=80=98static methods=
=E2=80=99.</p>
  <h3 id=3D"builder-pattern">Builder Pattern</h3>
  <p>Let=E2=80=99s say that we want our users to be able to create Circles,=
 but we will allow them to only set the properties they care about. Otherwi=
se, the <code>x</code> and <code>y</code> attributes will be <code>0.0</cod=
e>, and the <code>radius</code> will be <code>1.0</code>. Rust doesn=E2=80=
=99t have method overloading, named arguments, or variable arguments. We em=
ploy the builder pattern instead. It looks like this:</p>
  <pre><code>struct Circle {
      x: f64,
      y: f64,
      radius: f64,
  }
 =20
  impl Circle {
      fn area(&amp;self) -&gt; f64 {
          std::f64::consts::PI * (self.radius * self.radius)
      }
  }
 =20
  struct CircleBuilder {
      x: f64,
      y: f64,
      radius: f64,
  }
 =20
  impl CircleBuilder {
      fn new() -&gt; CircleBuilder {
          CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }
      }
 =20
      fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
          self.x =3D coordinate;
          self
      }
 =20
      fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
          self.y =3D coordinate;
          self
      }
 =20
      fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {
          self.radius =3D radius;
          self
      }
 =20
      fn finalize(&amp;self) -&gt; Circle {
          Circle { x: self.x, y: self.y, radius: self.radius }
      }
  }
 =20
  fn main() {
      let c =3D CircleBuilder::new()
                  .x(1.0)
                  .y(2.0)
                  .radius(2.0)
                  .finalize();
 =20
      println!("area: {}", c.area());
      println!("x: {}", c.x);
      println!("y: {}", c.y);
  }</code></pre>
  <p>What we=E2=80=99ve done here is make another struct, <code>CircleBuild=
er</code>. We=E2=80=99ve defined our builder methods on it. We=E2=80=99ve a=
lso defined our <code>area()</code> method on <code>Circle</code>. We also =
made one more method on <code>CircleBuilder</code>: <code>finalize()</code>=
. This method creates our final <code>Circle</code> from the builder. Now, =
we=E2=80=99ve used the type system to enforce our concerns: we can use the =
methods on <code>CircleBuilder</code> to constrain making <code>Circle</cod=
e>s in any way we choose.</p>
  <h2 id=3D"sec--vectors">Vectors</h2>
  <p>A =E2=80=98vector=E2=80=99 is a dynamic or =E2=80=98growable=E2=80=99 =
array, implemented as the standard library type <a href=3D"http://doc.rust-=
lang.org/std/vec/index.html"><code>Vec&lt;T&gt;</code></a>. The <code>T</co=
de> means that we can have vectors of any type (see the chapter on <a href=
=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--generi=
cs">generics</a> for more). Vectors always allocate their data on the heap.=
 You can create them with the <code>vec!</code> macro:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!=
</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span cla=
ss=3D"dv">3</span>, <span class=3D"dv">4</span>, <span class=3D"dv">5</span=
>]; <span class=3D"co">// v: Vec&lt;i32&gt;</span></code></pre></div>
  <p>(Notice that unlike the <code>println!</code> macro we=E2=80=99ve used=
 in the past, we use square brackets <code>[]</code> with <code>vec!</code>=
 macro. Rust allows you to use either in either situation, this is just con=
vention.)</p>
  <p>There=E2=80=99s an alternate form of <code>vec!</code> for repeating a=
n initial value:</p>
  <pre><code>let v =3D vec![0; 10]; // ten zeroes</code></pre>
  <h4 id=3D"accessing-elements">Accessing elements</h4>
  <p>To get the value at a particular index in the vector, we use <code>[]<=
/code>s:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!=
</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span cla=
ss=3D"dv">3</span>, <span class=3D"dv">4</span>, <span class=3D"dv">5</span=
>];
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"The third element =
of v is {}"</span>, v[<span class=3D"dv">2</span>]);</code></pre></div>
  <p>The indices count from <code>0</code>, so the third element is <code>v=
[2]</code>.</p>
  <h4 id=3D"iterating">Iterating</h4>
  <p>Once you have a vector, you can iterate through its elements with <cod=
e>for</code>. There are three versions:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 v =3D <span class=3D"ot">vec!</span>[<span class=3D"dv">1</span>, <span cl=
ass=3D"dv">2</span>, <span class=3D"dv">3</span>, <span class=3D"dv">4</spa=
n>, <span class=3D"dv">5</span>];
 =20
  <span class=3D"kw">for</span> i in &amp;v {
      <span class=3D"ot">println!</span>(<span class=3D"st">"A reference to=
 {}"</span>, i);
  }
 =20
  <span class=3D"kw">for</span> i in &amp;<span class=3D"kw">mut</span> v {
      <span class=3D"ot">println!</span>(<span class=3D"st">"A mutable refe=
rence to {}"</span>, i);
  }
 =20
  <span class=3D"kw">for</span> i in v {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Take ownership=
 of the vector and its element {}"</span>, i);
  }</code></pre></div>
  <p>Vectors have many more useful methods, which you can read about in <a =
href=3D"http://doc.rust-lang.org/std/vec/index.html">their API documentatio=
n</a>.</p>
  <h2 id=3D"sec--strings">Strings</h2>
  <p>Strings are an important concept for any programmer to master. Rust=E2=
=80=99s string handling system is a bit different from other languages, due=
 to its systems focus. Any time you have a data structure of variable size,=
 things can get tricky, and strings are a re-sizable data structure. That b=
eing said, Rust=E2=80=99s strings also work differently than in some other =
systems languages, such as C.</p>
  <p>Let=E2=80=99s dig into the details. A =E2=80=98string=E2=80=99 is a se=
quence of Unicode scalar values encoded as a stream of UTF-8 bytes. All str=
ings are guaranteed to be a valid encoding of UTF-8 sequences. Additionally=
, unlike some systems languages, strings are not null-terminated and can co=
ntain null bytes.</p>
  <p>Rust has two main types of strings: <code>&amp;str</code> and <code>St=
ring</code>. Let=E2=80=99s talk about <code>&amp;str</code> first. These ar=
e called =E2=80=98string slices=E2=80=99. String literals are of the type <=
code>&amp;'static str</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> string =3D <span class=3D"st"=
>"Hello there."</span>; <span class=3D"co">// string: &amp;'static str</spa=
n></code></pre></div>
  <p>This string is statically allocated, meaning that it=E2=80=99s saved i=
nside our compiled program, and exists for the entire duration it runs. The=
 <code>string</code> binding is a reference to this statically allocated st=
ring. String slices have a fixed size, and cannot be mutated.</p>
  <p>A <code>String</code>, on the other hand, is a heap-allocated string. =
This string is growable, and is also guaranteed to be UTF-8. <code>String</=
code>s are commonly created by converting from a string slice using the <co=
de>to_string</code> method.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 s =3D <span class=3D"st">"Hello"</span>.to_string(); <span class=3D"co">//=
 mut s: String</span>
  <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, s);
 =20
  s.push_str(<span class=3D"st">", world."</span>);
  <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, s);</c=
ode></pre></div>
  <p><code>String</code>s will coerce into <code>&amp;str</code> with an <c=
ode>&amp;</code>:</p>
  <pre><code>fn takes_slice(slice: &amp;str) {
      println!("Got: {}", slice);
  }
 =20
  fn main() {
      let s =3D "Hello".to_string();
      takes_slice(&amp;s);
  }</code></pre>
  <p>Viewing a <code>String</code> as a <code>&amp;str</code> is cheap, but=
 converting the <code>&amp;str</code> to a <code>String</code> involves all=
ocating memory. No reason to do that unless you have to!</p>
  <h4 id=3D"indexing">Indexing</h4>
  <p>Because strings are valid UTF-8, strings do not support indexing:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> s =3D <span class=3D"st">"hel=
lo"</span>;
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"The first letter o=
f s is {}"</span>, s[<span class=3D"dv">0</span>]); <span class=3D"co">// E=
RROR!!!</span></code></pre></div>
  <p>Usually, access to a vector with <code>[]</code> is very fast. But, be=
cause each character in a UTF-8 encoded string can be multiple bytes, you h=
ave to walk over the string to find the n=E1=B5=97=CA=B0 letter of a string=
. This is a significantly more expensive operation, and we don=E2=80=99t wa=
nt to be misleading. Furthermore, =E2=80=98letter=E2=80=99 isn=E2=80=99t so=
mething defined in Unicode, exactly. We can choose to look at a string as i=
ndividual bytes, or as codepoints:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> hachiko =3D <span class=3D"st=
">"=E5=BF=A0=E7=8A=AC=E3=83=8F=E3=83=81=E5=85=AC"</span>;
 =20
  <span class=3D"kw">for</span> b in hachiko.as_bytes() {
      <span class=3D"ot">print!</span>(<span class=3D"st">"{}, "</span>, b)=
;
  }
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">""</span>);
 =20
  <span class=3D"kw">for</span> c in hachiko.chars() {
      <span class=3D"ot">print!</span>(<span class=3D"st">"{}, "</span>, c)=
;
  }
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">""</span>);</code><=
/pre></div>
  <p>This prints:</p>
  <pre><code>229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 22=
9, 133, 172,=20
  =E5=BF=A0, =E7=8A=AC, =E3=83=8F, =E3=83=81, =E5=85=AC, </code></pre>
  <p>As you can see, there are more bytes than <code>char</code>s.</p>
  <p>You can get something similar to an index like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> dog =3D hachiko.chars().nth(<=
span class=3D"dv">1</span>); <span class=3D"co">// kinda like hachiko[1]</s=
pan></code></pre></div>
  <p>This emphasizes that we have to go through the whole list of <code>cha=
rs</code>.</p>
  <h4 id=3D"concatenation">Concatenation</h4>
  <p>If you have a <code>String</code>, you can concatenate a <code>&amp;st=
r</code> to the end of it:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> hello =3D <span class=3D"st">=
"Hello "</span>.to_string();
  <span class=3D"kw">let</span> world =3D <span class=3D"st">"world!"</span=
>;
 =20
  <span class=3D"kw">let</span> hello_world =3D hello + world;</code></pre>=
</div>
  <p>But if you have two <code>String</code>s, you need an <code>&amp;</cod=
e>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> hello =3D <span class=3D"st">=
"Hello "</span>.to_string();
  <span class=3D"kw">let</span> world =3D <span class=3D"st">"world!"</span=
>.to_string();
 =20
  <span class=3D"kw">let</span> hello_world =3D hello + &amp;world;</code><=
/pre></div>
  <p>This is because <code>&amp;String</code> can automatically coerece to =
a <code>&amp;str</code>. This is a feature called =E2=80=98<a href=3D"https=
://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--deref-coercions=
"><code>Deref</code> coercions</a>=E2=80=99.</p>
  <h2 id=3D"sec--generics">Generics</h2>
  <p>Sometimes, when writing a function or data type, we may want it to wor=
k for multiple types of arguments. Luckily, Rust has a feature that gives u=
s a better way: generics. Generics are called =E2=80=98parametric polymorph=
ism=E2=80=99 in type theory, which means that they are types or functions t=
hat have multiple forms (=E2=80=98poly=E2=80=99 is multiple, =E2=80=98morph=
=E2=80=99 is form) over a given parameter (=E2=80=98parametric=E2=80=99).</=
p>
  <p>Anyway, enough with type theory, let=E2=80=99s check out some generic =
code. Rust=E2=80=99s standard library provides a type, <code>Option&lt;T&gt=
;</code>, that=E2=80=99s generic:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> <span class=3D"kw">Option</s=
pan>&lt;T&gt; {
      <span class=3D"kw">Some</span>(T),
      <span class=3D"kw">None</span>,
  }</code></pre></div>
  <p>The <code>&lt;T&gt;</code> part, which you=E2=80=99ve seen a few times=
 before, indicates that this is a generic data type. Inside the declaration=
 of our enum, wherever we see a <code>T</code>, we substitute that type for=
 the same type used in the generic. Here=E2=80=99s an example of using <cod=
e>Option&lt;T&gt;</code>, with some extra type annotations:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: <span class=3D"kw">Option<=
/span>&lt;<span class=3D"kw">i32</span>&gt; =3D <span class=3D"kw">Some</sp=
an>(<span class=3D"dv">5</span>);</code></pre></div>
  <p>In the type declaration, we say <code>Option&lt;i32&gt;</code>. Note h=
ow similar this looks to <code>Option&lt;T&gt;</code>. So, in this particul=
ar <code>Option</code>, <code>T</code> has the value of <code>i32</code>. O=
n the right-hand side of the binding, we do make a <code>Some(T)</code>, wh=
ere <code>T</code> is <code>5</code>. Since that=E2=80=99s an <code>i32</co=
de>, the two sides match, and Rust is happy. If they didn=E2=80=99t match, =
we=E2=80=99d get an error:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: <span class=3D"kw">Option<=
/span>&lt;<span class=3D"kw">f64</span>&gt; =3D <span class=3D"kw">Some</sp=
an>(<span class=3D"dv">5</span>);
  <span class=3D"co">// error: mismatched types: expected `core::option::Op=
tion&lt;f64&gt;`,</span>
  <span class=3D"co">// found `core::option::Option&lt;_&gt;` (expected f64=
 but found integral variable)</span></code></pre></div>
  <p>That doesn=E2=80=99t mean we can=E2=80=99t make <code>Option&lt;T&gt;<=
/code>s that hold an <code>f64</code>! They just have to match up:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: <span class=3D"kw">Option<=
/span>&lt;<span class=3D"kw">i32</span>&gt; =3D <span class=3D"kw">Some</sp=
an>(<span class=3D"dv">5</span>);
  <span class=3D"kw">let</span> y: <span class=3D"kw">Option</span>&lt;<spa=
n class=3D"kw">f64</span>&gt; =3D <span class=3D"kw">Some</span>(<span clas=
s=3D"dv">5.0f64</span>);</code></pre></div>
  <p>This is just fine. One definition, multiple uses.</p>
  <p>Generics don=E2=80=99t have to only be generic over one type. Consider=
 another type from Rust=E2=80=99s standard library that=E2=80=99s similar, =
<code>Result&lt;T, E&gt;</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> <span class=3D"kw">Result</s=
pan>&lt;T, E&gt; {
      <span class=3D"kw">Ok</span>(T),
      <span class=3D"kw">Err</span>(E),
  }</code></pre></div>
  <p>This type is generic over <em>two</em> types: <code>T</code> and <code=
>E</code>. By the way, the capital letters can be any letter you=E2=80=99d =
like. We could define <code>Result&lt;T, E&gt;</code> as:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">enum</span> <span class=3D"kw">Result</s=
pan>&lt;A, Z&gt; {
      <span class=3D"kw">Ok</span>(A),
      <span class=3D"kw">Err</span>(Z),
  }</code></pre></div>
  <p>if we wanted to. Convention says that the first generic parameter shou=
ld be <code>T</code>, for =E2=80=98type=E2=80=99, and that we use <code>E</=
code> for =E2=80=98error=E2=80=99. Rust doesn=E2=80=99t care, however.</p>
  <p>The <code>Result&lt;T, E&gt;</code> type is intended to be used to ret=
urn the result of a computation, and to have the ability to return an error=
 if it didn=E2=80=99t work out.</p>
  <h4 id=3D"generic-functions">Generic functions</h4>
  <p>We can write functions that take generic types with a similar syntax:<=
/p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> takes_anything&lt;T&gt;(x: T) =
{
      <span class=3D"co">// do something with x</span>
  }</code></pre></div>
  <p>The syntax has two parts: the <code>&lt;T&gt;</code> says =E2=80=9Cthi=
s function is generic over one type, <code>T</code>=E2=80=9D, and the <code=
>x: T</code> says =E2=80=9Cx has the type <code>T</code>.=E2=80=9D</p>
  <p>Multiple arguments can have the same generic type:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> takes_two_of_the_same_things&l=
t;T&gt;(x: T, y: T) {
      <span class=3D"co">// ...</span>
  }</code></pre></div>
  <p>We could write a version that takes multiple types:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> takes_two_things&lt;T, U&gt;(x=
: T, y: U) {
      <span class=3D"co">// ...</span>
  }</code></pre></div>
  <p>Generic functions are most useful with =E2=80=98trait bounds=E2=80=99,=
 which we=E2=80=99ll cover in the <a href=3D"https://killercup.github.io/tr=
pl-ebook/trpl-2015-05-13.html#sec--traits">section on traits</a>.</p>
  <h4 id=3D"generic-structs">Generic structs</h4>
  <p>You can store a generic type in a <code>struct</code> as well:</p>
  <pre><code>struct Point&lt;T&gt; {
      x: T,
      y: T,
  }
 =20
  let int_origin =3D Point { x: 0, y: 0 };
  let float_origin =3D Point { x: 0.0, y: 0.0 };</code></pre>
  <p>Similarly to functions, the <code>&lt;T&gt;</code> is where we declare=
 the generic parameters, and we then use <code>x: T</code> in the type decl=
aration, too.</p>
  <h2 id=3D"sec--traits">Traits</h2>
  <p>Do you remember the <code>impl</code> keyword, used to call a function=
 with <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.htm=
l#sec--method-syntax">method syntax</a>?</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Circle {
      x: <span class=3D"kw">f64</span>,
      y: <span class=3D"kw">f64</span>,
      radius: <span class=3D"kw">f64</span>,
  }
 =20
  <span class=3D"kw">impl</span> Circle {
      <span class=3D"kw">fn</span> area(&amp;<span class=3D"kw">self</span>=
) -&gt; <span class=3D"kw">f64</span> {
          std::<span class=3D"kw">f64</span>::consts::PI * (<span class=3D"=
kw">self</span>.radius * <span class=3D"kw">self</span>.radius)
      }
  }</code></pre></div>
  <p>Traits are similar, except that we define a trait with just the method=
 signature, then implement the trait for that struct. Like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Circle {
      x: <span class=3D"kw">f64</span>,
      y: <span class=3D"kw">f64</span>,
      radius: <span class=3D"kw">f64</span>,
  }
 =20
  <span class=3D"kw">trait</span> HasArea {
      <span class=3D"kw">fn</span> area(&amp;<span class=3D"kw">self</span>=
) -&gt; <span class=3D"kw">f64</span>;
  }
 =20
  <span class=3D"kw">impl</span> HasArea <span class=3D"kw">for</span> Circ=
le {
      <span class=3D"kw">fn</span> area(&amp;<span class=3D"kw">self</span>=
) -&gt; <span class=3D"kw">f64</span> {
          std::<span class=3D"kw">f64</span>::consts::PI * (<span class=3D"=
kw">self</span>.radius * <span class=3D"kw">self</span>.radius)
      }
  }</code></pre></div>
  <p>As you can see, the <code>trait</code> block looks very similar to the=
 <code>impl</code> block, but we don=E2=80=99t define a body, just a type s=
ignature. When we <code>impl</code> a trait, we use <code>impl Trait for It=
em</code>, rather than just <code>impl Item</code>.</p>
  <p>We can use traits to constrain our generics. Consider this function, w=
hich does not compile, and gives us a similar error:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> print_area&lt;T&gt;(shape: T) =
{
      <span class=3D"ot">println!</span>(<span class=3D"st">"This shape has=
 an area of {}"</span>, shape.area());
  }</code></pre></div>
  <p>Rust complains:</p>
  <pre><code>error: type `T` does not implement any method in scope named `=
area`</code></pre>
  <p>Because <code>T</code> can be any type, we can=E2=80=99t be sure that =
it implements the <code>area</code> method. But we can add a =E2=80=98trait=
 constraint=E2=80=99 to our generic <code>T</code>, ensuring that it does:<=
/p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> print_area&lt;T: HasArea&gt;(s=
hape: T) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"This shape has=
 an area of {}"</span>, shape.area());
  }</code></pre></div>
  <p>The syntax <code>&lt;T: HasArea&gt;</code> means <code>any type that i=
mplements the HasArea trait</code>. Because traits define function type sig=
natures, we can be sure that any type which implements <code>HasArea</code>=
 will have an <code>.area()</code> method.</p>
  <p>Here=E2=80=99s an extended example of how this works:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> HasArea {
      <span class=3D"kw">fn</span> area(&amp;<span class=3D"kw">self</span>=
) -&gt; <span class=3D"kw">f64</span>;
  }
 =20
  <span class=3D"kw">struct</span> Circle {
      x: <span class=3D"kw">f64</span>,
      y: <span class=3D"kw">f64</span>,
      radius: <span class=3D"kw">f64</span>,
  }
 =20
  <span class=3D"kw">impl</span> HasArea <span class=3D"kw">for</span> Circ=
le {
      <span class=3D"kw">fn</span> area(&amp;<span class=3D"kw">self</span>=
) -&gt; <span class=3D"kw">f64</span> {
          std::<span class=3D"kw">f64</span>::consts::PI * (<span class=3D"=
kw">self</span>.radius * <span class=3D"kw">self</span>.radius)
      }
  }
 =20
  <span class=3D"kw">struct</span> Square {
      x: <span class=3D"kw">f64</span>,
      y: <span class=3D"kw">f64</span>,
      side: <span class=3D"kw">f64</span>,
  }
 =20
  <span class=3D"kw">impl</span> HasArea <span class=3D"kw">for</span> Squa=
re {
      <span class=3D"kw">fn</span> area(&amp;<span class=3D"kw">self</span>=
) -&gt; <span class=3D"kw">f64</span> {
          <span class=3D"kw">self</span>.side * <span class=3D"kw">self</sp=
an>.side
      }
  }
 =20
  <span class=3D"kw">fn</span> print_area&lt;T: HasArea&gt;(shape: T) {
      <span class=3D"ot">println!</span>(<span class=3D"st">"This shape has=
 an area of {}"</span>, shape.area());
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> c =3D Circle {
          x: <span class=3D"dv">0.0f64</span>,
          y: <span class=3D"dv">0.0f64</span>,
          radius: <span class=3D"dv">1.0f64</span>,
      };
 =20
      <span class=3D"kw">let</span> s =3D Square {
          x: <span class=3D"dv">0.0f64</span>,
          y: <span class=3D"dv">0.0f64</span>,
          side: <span class=3D"dv">1.0f64</span>,
      };
 =20
      print_area(c);
      print_area(s);
  }</code></pre></div>
  <p>This program outputs:</p>
  <pre><code>This shape has an area of 3.141593
  This shape has an area of 1</code></pre>
  <p>As you can see, <code>print_area</code> is now generic, but also ensur=
es that we have passed in the correct types. If we pass in an incorrect typ=
e:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">print_area(<span class=3D"dv">5</span>);</code></pre></div>
  <p>We get a compile-time error:</p>
  <pre><code>error: failed to find an implementation of trait main::HasArea=
 for int</code></pre>
  <p>So far, we=E2=80=99ve only added trait implementations to structs, but=
 you can implement a trait for any type. So technically, we <em>could</em> =
implement <code>HasArea</code> for <code>i32</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> HasArea {
      <span class=3D"kw">fn</span> area(&amp;<span class=3D"kw">self</span>=
) -&gt; <span class=3D"kw">f64</span>;
  }
 =20
  <span class=3D"kw">impl</span> HasArea <span class=3D"kw">for</span> <spa=
n class=3D"kw">i32</span> {
      <span class=3D"kw">fn</span> area(&amp;<span class=3D"kw">self</span>=
) -&gt; <span class=3D"kw">f64</span> {
          <span class=3D"ot">println!</span>(<span class=3D"st">"this is si=
lly"</span>);
 =20
          *<span class=3D"kw">self</span> <span class=3D"kw">as</span> <spa=
n class=3D"kw">f64</span>
      }
  }
 =20
  <span class=3D"dv">5.</span>area();</code></pre></div>
  <p>It is considered poor style to implement methods on such primitive typ=
es, even though it is possible.</p>
  <p>This may seem like the Wild West, but there are two other restrictions=
 around implementing traits that prevent this from getting out of hand. The=
 first is that if the trait isn=E2=80=99t defined in your scope, it doesn=
=E2=80=99t apply. Here=E2=80=99s an example: the standard library provides =
a <a href=3D"http://doc.rust-lang.org/std/io/trait.Write.html"><code>Write<=
/code></a> trait which adds extra functionality to <code>File</code>s, for =
doing file I/O. By default, a <code>File</code> won=E2=80=99t have its meth=
ods:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 f =3D std::fs::File::open(<span class=3D"st">"foo.txt"</span>).ok().expect=
(<span class=3D"st">"Couldn=E2=80=99t open foo.txt"</span>);
  <span class=3D"kw">let</span> result =3D f.write(<span class=3D"st">"what=
ever"</span>.as_bytes());</code></pre></div>
  <p>Here=E2=80=99s the error:</p>
  <pre><code>error: type `std::fs::File` does not implement any method in s=
cope named `write`
 =20
  let result =3D f.write(b"whatever");
                 ^~~~~~~~~~~~~~~~~~</code></pre>
  <p>We need to <code>use</code> the <code>Write</code> trait first:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::io::Write;
 =20
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> f =3D std::fs=
::File::open(<span class=3D"st">"foo.txt"</span>).ok().expect(<span class=
=3D"st">"Couldn=E2=80=99t open foo.txt"</span>);
  <span class=3D"kw">let</span> result =3D f.write(<span class=3D"st">"what=
ever"</span>.as_bytes());</code></pre></div>
  <p>This will compile without error.</p>
  <p>This means that even if someone does something bad like add methods to=
 <code>int</code>, it won=E2=80=99t affect you, unless you <code>use</code>=
 that trait.</p>
  <p>There=E2=80=99s one more restriction on implementing traits. Either th=
e trait or the type you=E2=80=99re writing the <code>impl</code> for must b=
e defined by you. So, we could implement the <code>HasArea</code> type for =
<code>i32</code>, because <code>HasArea</code> is in our code. But if we tr=
ied to implement <code>Float</code>, a trait provided by Rust, for <code>i3=
2</code>, we could not, because neither the trait nor the type are in our c=
ode.</p>
  <p>One last thing about traits: generic functions with a trait bound use =
=E2=80=98monomorphization=E2=80=99 (mono: one, morph: form), so they are st=
atically dispatched. What=E2=80=99s that mean? Check out the chapter on <a =
href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--tr=
ait-objects">trait objects</a> for more details.</p>
  <h3 id=3D"multiple-trait-bounds">Multiple trait bounds</h3>
  <p>You=E2=80=99ve seen that you can bound a generic type parameter with a=
 trait:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo&lt;T: Clone&gt;(x: T) {
      x.clone();
  }</code></pre></div>
  <p>If you need more than one bound, you can use <code>+</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::fmt::Debug;
 =20
  <span class=3D"kw">fn</span> foo&lt;T: Clone + Debug&gt;(x: T) {
      x.clone();
      <span class=3D"ot">println!</span>(<span class=3D"st">"{:?}"</span>, =
x);
  }</code></pre></div>
  <p><code>T</code> now needs to be both <code>Clone</code> as well as <cod=
e>Debug</code>.</p>
  <h3 id=3D"where-clause">Where clause</h3>
  <p>Writing functions with only a few generic types and a small number of =
trait bounds isn=E2=80=99t too bad, but as the number increases, the syntax=
 gets increasingly awkward:</p>
  <pre><code>use std::fmt::Debug;
 =20
  fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
      x.clone();
      y.clone();
      println!("{:?}", y);
  }</code></pre>
  <p>The name of the function is on the far left, and the parameter list is=
 on the far right. The bounds are getting in the way.</p>
  <p>Rust has a solution, and it=E2=80=99s called a =E2=80=98<code>where</c=
ode> clause=E2=80=99:</p>
  <pre><code>use std::fmt::Debug;
 =20
  fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
      x.clone();
      y.clone();
      println!("{:?}", y);
  }
 =20
  fn bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
      x.clone();
      y.clone();
      println!("{:?}", y);
  }
 =20
  fn main() {
      foo("Hello", "world");
      bar("Hello", "workd");
  }</code></pre>
  <p><code>foo()</code> uses the syntax we showed earlier, and <code>bar()<=
/code> uses a <code>where</code> clause. All you need to do is leave off th=
e bounds when defining your type parameters, and then add <code>where</code=
> after the parameter list. For longer lists, whitespace can be added:</p>
  <pre><code>use std::fmt::Debug;
 =20
  fn bar&lt;T, K&gt;(x: T, y: K)
      where T: Clone,
            K: Clone + Debug {
 =20
      x.clone();
      y.clone();
      println!("{:?}", y);
  }</code></pre>
  <p>This flexibility can add clarity in complex situations.</p>
  <p><code>where</code> is also more powerful than the simpler syntax. For =
example:</p>
  <pre><code>trait ConvertTo&lt;Output&gt; {
      fn convert(&amp;self) -&gt; Output;
  }
 =20
  impl ConvertTo&lt;i64&gt; for i32 {
      fn convert(&amp;self) -&gt; i64 { *self as i64 }
  }
 =20
  // can be called with T =3D=3D i32
  fn normal&lt;T: ConvertTo&lt;i64&gt;&gt;(x: &amp;T) -&gt; i64 {
      x.convert()
  }
 =20
  // can be called with T =3D=3D i64
  fn inverse&lt;T&gt;() -&gt; T
          // this is using ConvertTo as if it were "ConvertFrom&lt;i32&gt;"
          where i32: ConvertTo&lt;T&gt; {
      1i32.convert()
  }</code></pre>
  <p>This shows off the additional feature of <code>where</code> clauses: t=
hey allow bounds where the left-hand side is an arbitrary type (<code>i32</=
code> in this case), not just a plain type parameter (like <code>T</code>).=
</p>
  <h4 id=3D"default-methods">Default methods</h4>
  <p>There=E2=80=99s one last feature of traits we should cover: default me=
thods. It=E2=80=99s easiest just to show an example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> Foo {
      <span class=3D"kw">fn</span> bar(&amp;<span class=3D"kw">self</span>)=
;
 =20
      <span class=3D"kw">fn</span> baz(&amp;<span class=3D"kw">self</span>)=
 { <span class=3D"ot">println!</span>(<span class=3D"st">"We called baz."</=
span>); }
  }</code></pre></div>
  <p>Implementors of the <code>Foo</code> trait need to implement <code>bar=
()</code>, but they don=E2=80=99t need to implement <code>baz()</code>. The=
y=E2=80=99ll get this default behavior. They can override the default if th=
ey so choose:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> UseDefault;
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> UseDefau=
lt {
      <span class=3D"kw">fn</span> bar(&amp;<span class=3D"kw">self</span>)=
 { <span class=3D"ot">println!</span>(<span class=3D"st">"We called bar."</=
span>); }
  }
 =20
  <span class=3D"kw">struct</span> OverrideDefault;
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> Override=
Default {
      <span class=3D"kw">fn</span> bar(&amp;<span class=3D"kw">self</span>)=
 { <span class=3D"ot">println!</span>(<span class=3D"st">"We called bar."</=
span>); }
 =20
      <span class=3D"kw">fn</span> baz(&amp;<span class=3D"kw">self</span>)=
 { <span class=3D"ot">println!</span>(<span class=3D"st">"Override baz!"</s=
pan>); }
  }
 =20
  <span class=3D"kw">let</span> default =3D UseDefault;
  default.baz(); <span class=3D"co">// prints "We called baz."</span>
 =20
  <span class=3D"kw">let</span> over =3D OverrideDefault;
  over.baz(); <span class=3D"co">// prints "Override baz!"</span></code></p=
re></div>
  <h3 id=3D"inheritance">Inheritance</h3>
  <p>Sometimes, implementing a trait requires implementing another trait:</=
p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> Foo {
      <span class=3D"kw">fn</span> foo(&amp;<span class=3D"kw">self</span>)=
;
  }
 =20
  <span class=3D"kw">trait</span> FooBar : Foo {
      <span class=3D"kw">fn</span> foobar(&amp;<span class=3D"kw">self</spa=
n>);
  }</code></pre></div>
  <p>Implementors of <code>FooBar</code> must also implement <code>Foo</cod=
e>, like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Baz;
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> Baz {
      <span class=3D"kw">fn</span> foo(&amp;<span class=3D"kw">self</span>)=
 { <span class=3D"ot">println!</span>(<span class=3D"st">"foo"</span>); }
  }
 =20
  <span class=3D"kw">impl</span> FooBar <span class=3D"kw">for</span> Baz {
      <span class=3D"kw">fn</span> foobar(&amp;<span class=3D"kw">self</spa=
n>) { <span class=3D"ot">println!</span>(<span class=3D"st">"foobar"</span>=
); }
  }</code></pre></div>
  <p>If we forget to implement <code>Foo</code>, Rust will tell us:</p>
  <pre><code>error: the trait `main::Foo` is not implemented for the type `=
main::Baz` [E0277]</code></pre>
  <h2 id=3D"sec--drop">Drop</h2>
  <p>Now that we=E2=80=99ve discussed traits, let=E2=80=99s talk about a pa=
rticular trait provided by the Rust standard library, <a href=3D"http://doc=
.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>. The <code>Dr=
op</code> trait provides a way to run some code when a value goes out of sc=
ope. For example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> HasDrop;
 =20
  <span class=3D"kw">impl</span> <span class=3D"kw">Drop</span> <span class=
=3D"kw">for</span> HasDrop {
      <span class=3D"kw">fn</span> drop(&amp;<span class=3D"kw">mut</span> =
<span class=3D"kw">self</span>) {
          <span class=3D"ot">println!</span>(<span class=3D"st">"Dropping!"=
</span>);
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D HasDrop;
 =20
      <span class=3D"co">// do stuff</span>
 =20
  } <span class=3D"co">// x goes out of scope here</span></code></pre></div=
>
  <p>When <code>x</code> goes out of scope at the end of <code>main()</code=
>, the code for <code>Drop</code> will run. <code>Drop</code> has one metho=
d, which is also called <code>drop()</code>. It takes a mutable reference t=
o <code>self</code>.</p>
  <p>That=E2=80=99s it! The mechanics of <code>Drop</code> are very simple,=
 but there are some subtleties. For example, values are dropped in the oppo=
site order they are declared. Here=E2=80=99s another example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Firework {
      strength: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">impl</span> <span class=3D"kw">Drop</span> <span class=
=3D"kw">for</span> Firework {
      <span class=3D"kw">fn</span> drop(&amp;<span class=3D"kw">mut</span> =
<span class=3D"kw">self</span>) {
          <span class=3D"ot">println!</span>(<span class=3D"st">"BOOM times=
 {}!!!"</span>, <span class=3D"kw">self</span>.strength);
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> firecracker =3D Firework { strength: <s=
pan class=3D"dv">1</span> };
      <span class=3D"kw">let</span> tnt =3D Firework { strength: <span clas=
s=3D"dv">100</span> };
  }</code></pre></div>
  <p>This will output:</p>
  <pre><code>BOOM times 100!!!
  BOOM times 1!!!</code></pre>
  <p>The TNT goes off before the firecracker does, because it was declared =
afterwards. Last in, first out.</p>
  <p>So what is <code>Drop</code> good for? Generally, <code>Drop</code> is=
 used to clean up any resources associated with a <code>struct</code>. For =
example, the <a href=3D"http://doc.rust-lang.org/std/sync/struct.Arc.html">=
<code>Arc&lt;T&gt;</code> type</a> is a reference-counted type. When <code>=
Drop</code> is called, it will decrement the reference count, and if the to=
tal number of references is zero, will clean up the underlying value.</p>
  <h2 id=3D"sec--if-let">if let</h2>
  <p><code>if let</code> allows you to combine <code>if</code> and <code>le=
t</code> together to reduce the overhead of certain kinds of pattern matche=
s.</p>
  <p>For example, let=E2=80=99s say we have some sort of <code>Option&lt;T&=
gt;</code>. We want to call a function on it if it=E2=80=99s <code>Some&lt;=
T&gt;</code>, but do nothing if it=E2=80=99s <code>None</code>. That looks =
like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">match</span> option {
      <span class=3D"kw">Some</span>(x) =3D&gt; { foo(x) },
      <span class=3D"kw">None</span> =3D&gt; {},
  }</code></pre></div>
  <p>We don=E2=80=99t have to use <code>match</code> here, for example, we =
could use <code>if</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">if</span> option.is_some() {
      <span class=3D"kw">let</span> x =3D option.unwrap();
      foo(x);
  }</code></pre></div>
  <p>Neither of these options is particularly appealing. We can use <code>i=
f let</code> to do the same thing in a nicer way:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">if</span> <span class=3D"kw">let</span> =
<span class=3D"kw">Some</span>(x) =3D option {
      foo(x);
  }</code></pre></div>
  <p>If a <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13=
.html#sec--patterns">pattern</a> matches successfully, it binds any appropr=
iate parts of the value to the identifiers in the pattern, then evaluates t=
he expression. If the pattern doesn=E2=80=99t match, nothing happens.</p>
  <p>If you=E2=80=99d rather to do something else when the pattern does not=
 match, you can use <code>else</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">if</span> <span class=3D"kw">let</span> =
<span class=3D"kw">Some</span>(x) =3D option {
      foo(x);
  } <span class=3D"kw">else</span> {
      bar();
  }</code></pre></div>
  <h4 id=3D"while-let"><code>while let</code></h4>
  <p>In a similar fashion, <code>while let</code> can be used when you want=
 to conditionally loop as long as a value matches a certain pattern. It tur=
ns code like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">loop</span> {
      <span class=3D"kw">match</span> option {
          <span class=3D"kw">Some</span>(x) =3D&gt; <span class=3D"ot">prin=
tln!</span>(<span class=3D"st">"{}"</span>, x),
          _ =3D&gt; <span class=3D"kw">break</span>,
      }
  }</code></pre></div>
  <p>Into code like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">while</span> <span class=3D"kw">let</spa=
n> <span class=3D"kw">Some</span>(x) =3D option {
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
;
  }</code></pre></div>
  <h2 id=3D"sec--trait-objects">Trait Objects</h2>
  <p>When code involves polymorphism, there needs to be a mechanism to dete=
rmine which specific version is actually run. This is called =E2=80=98dispa=
tch=E2=80=99. There are two major forms of dispatch: static dispatch and dy=
namic dispatch. While Rust favors static dispatch, it also supports dynamic=
 dispatch through a mechanism called =E2=80=98trait objects=E2=80=99.</p>
  <h4 id=3D"background">Background</h4>
  <p>For the rest of this chapter, we=E2=80=99ll need a trait and some impl=
ementations. Let=E2=80=99s make a simple one, <code>Foo</code>. It has one =
method that is expected to return a <code>String</code>.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> Foo {
      <span class=3D"kw">fn</span> method(&amp;<span class=3D"kw">self</spa=
n>) -&gt; String;
  }</code></pre></div>
  <p>We=E2=80=99ll also implement this trait for <code>u8</code> and <code>=
String</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">impl</span> Foo <span class=3D"kw">for</=
span> <span class=3D"kw">u8</span> {
      <span class=3D"kw">fn</span> method(&amp;<span class=3D"kw">self</spa=
n>) -&gt; String { <span class=3D"ot">format!</span>(<span class=3D"st">"u8=
: {}"</span>, *<span class=3D"kw">self</span>) }
  }
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> String {
      <span class=3D"kw">fn</span> method(&amp;<span class=3D"kw">self</spa=
n>) -&gt; String { <span class=3D"ot">format!</span>(<span class=3D"st">"st=
ring: {}"</span>, *<span class=3D"kw">self</span>) }
  }</code></pre></div>
  <h4 id=3D"static-dispatch">Static dispatch</h4>
  <p>We can use this trait to perform static dispatch with trait bounds:</p=
>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> do_something&lt;T: Foo&gt;(x: =
T) {
      x.method();
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">5u8</span>;
      <span class=3D"kw">let</span> y =3D <span class=3D"st">"Hello"</span>=
.to_string();
 =20
      do_something(x);
      do_something(y);
  }</code></pre></div>
  <p>Rust uses =E2=80=98monomorphization=E2=80=99 to perform static dispatc=
h here. This means that Rust will create a special version of <code>do_some=
thing()</code> for both <code>u8</code> and <code>String</code>, and then r=
eplace the call sites with calls to these specialized functions. In other w=
ords, Rust generates something like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> do_something_u8(x: <span class=
=3D"kw">u8</span>) {
      x.method();
  }
 =20
  <span class=3D"kw">fn</span> do_something_string(x: String) {
      x.method();
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">5u8</span>;
      <span class=3D"kw">let</span> y =3D <span class=3D"st">"Hello"</span>=
.to_string();
 =20
      do_something_u8(x);
      do_something_string(y);
  }</code></pre></div>
  <p>This has a great upside: static dispatch allows function calls to be i=
nlined because the callee is known at compile time, and inlining is the key=
 to good optimization. Static dispatch is fast, but it comes at a tradeoff:=
 =E2=80=98code bloat=E2=80=99, due to many copies of the same function exis=
ting in the binary, one for each type.</p>
  <p>Furthermore, compilers aren=E2=80=99t perfect and may =E2=80=9Coptimiz=
e=E2=80=9D code to become slower. For example, functions inlined too eagerl=
y will bloat the instruction cache (cache rules everything around us). This=
 is part of the reason that <code>#[inline]</code> and <code>#[inline(alway=
s)]</code> should be used carefully, and one reason why using a dynamic dis=
patch is sometimes more efficient.</p>
  <p>However, the common case is that it is more efficient to use static di=
spatch, and one can always have a thin statically-dispatched wrapper functi=
on that does a dynamic dispatch, but not vice versa, meaning static calls a=
re more flexible. The standard library tries to be statically dispatched wh=
ere possible for this reason.</p>
  <h4 id=3D"dynamic-dispatch">Dynamic dispatch</h4>
  <p>Rust provides dynamic dispatch through a feature called =E2=80=98trait=
 objects=E2=80=99. Trait objects, like <code>&amp;Foo</code> or <code>Box&l=
t;Foo&gt;</code>, are normal values that store a value of <em>any</em> type=
 that implements the given trait, where the precise type can only be known =
at runtime.</p>
  <p>A trait object can be obtained from a pointer to a concrete type that =
implements the trait by <em>casting</em> it (e.g. <code>&amp;x as &amp;Foo<=
/code>) or <em>coercing</em> it (e.g.&nbsp;using <code>&amp;x</code> as an =
argument to a function that takes <code>&amp;Foo</code>).</p>
  <p>These trait object coercions and casts also work for pointers like <co=
de>&amp;mut T</code> to <code>&amp;mut Foo</code> and <code>Box&lt;T&gt;</c=
ode> to <code>Box&lt;Foo&gt;</code>, but that=E2=80=99s all at the moment. =
Coercions and casts are identical.</p>
  <p>This operation can be seen as =E2=80=98erasing=E2=80=99 the compiler=
=E2=80=99s knowledge about the specific type of the pointer, and hence trai=
t objects are sometimes referred to as =E2=80=98type erasure=E2=80=99.</p>
  <p>Coming back to the example above, we can use the same trait to perform=
 dynamic dispatch with trait objects by casting:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">
  <span class=3D"kw">fn</span> do_something(x: &amp;Foo) {
      x.method();
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"dv">5u8</span>;
      do_something(&amp;x <span class=3D"kw">as</span> &amp;Foo);
  }</code></pre></div>
  <p>or by coercing:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">
  <span class=3D"kw">fn</span> do_something(x: &amp;Foo) {
      x.method();
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D <span class=3D"st">"Hello"</span>=
.to_string();
      do_something(&amp;x);
  }</code></pre></div>
  <p>A function that takes a trait object is not specialized to each of the=
 types that implements <code>Foo</code>: only one copy is generated, often =
(but not always) resulting in less code bloat. However, this comes at the c=
ost of requiring slower virtual function calls, and effectively inhibiting =
any chance of inlining and related optimizations from occurring.</p>
  <h5 id=3D"why-pointers">Why pointers?</h5>
  <p>Rust does not put things behind a pointer by default, unlike many mana=
ged languages, so types can have different sizes. Knowing the size of the v=
alue at compile time is important for things like passing it as an argument=
 to a function, moving it about on the stack and allocating (and deallocati=
ng) space on the heap to store it.</p>
  <p>For <code>Foo</code>, we would need to have a value that could be at l=
east either a <code>String</code> (24 bytes) or a <code>u8</code> (1 byte),=
 as well as any other type for which dependent crates may implement <code>F=
oo</code> (any number of bytes at all). There=E2=80=99s no way to guarantee=
 that this last point can work if the values are stored without a pointer, =
because those other types can be arbitrarily large.</p>
  <p>Putting the value behind a pointer means the size of the value is not =
relevant when we are tossing a trait object around, only the size of the po=
inter itself.</p>
  <h5 id=3D"representation">Representation</h5>
  <p>The methods of the trait can be called on a trait object via a special=
 record of function pointers traditionally called a =E2=80=98vtable=E2=80=
=99 (created and managed by the compiler).</p>
  <p>Trait objects are both simple and complicated: their core representati=
on and layout is quite straight-forward, but there are some curly error mes=
sages and surprising behaviors to discover.</p>
  <p>Let=E2=80=99s start simple, with the runtime representation of a trait=
 object. The <code>std::raw</code> module contains structs with layouts tha=
t are the same as the complicated built-in types, <a href=3D"http://doc.rus=
t-lang.org/std/raw/struct.TraitObject.html">including trait objects</a>:</p=
>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">struct</sp=
an> TraitObject {
      <span class=3D"kw">pub</span> data: *<span class=3D"kw">mut</span> ()=
,
      <span class=3D"kw">pub</span> vtable: *<span class=3D"kw">mut</span> =
(),
  }</code></pre></div>
  <p>That is, a trait object like <code>&amp;Foo</code> consists of a =E2=
=80=98data=E2=80=99 pointer and a =E2=80=98vtable=E2=80=99 pointer.</p>
  <p>The data pointer addresses the data (of some unknown type <code>T</cod=
e>) that the trait object is storing, and the vtable pointer points to the =
vtable (=E2=80=98virtual method table=E2=80=99) corresponding to the implem=
entation of <code>Foo</code> for <code>T</code>.</p>
  <p>A vtable is essentially a struct of function pointers, pointing to the=
 concrete piece of machine code for each method in the implementation. A me=
thod call like <code>trait_object.method()</code> will retrieve the correct=
 pointer out of the vtable and then do a dynamic call of it. For example:</=
p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> FooVtable {
      destructor: <span class=3D"kw">fn</span>(*<span class=3D"kw">mut</spa=
n> ()),
      size: usize,
      align: usize,
      method: <span class=3D"kw">fn</span>(*const ()) -&gt; String,
  }
 =20
  <span class=3D"co">// u8:</span>
 =20
  <span class=3D"kw">fn</span> call_method_on_u8(x: *const ()) -&gt; String=
 {
      <span class=3D"co">// the compiler guarantees that this function is o=
nly called</span>
      <span class=3D"co">// with `x` pointing to a u8</span>
      <span class=3D"kw">let</span> byte: &amp;<span class=3D"kw">u8</span>=
 =3D <span class=3D"kw">unsafe</span> { &amp;*(x <span class=3D"kw">as</spa=
n> *const <span class=3D"kw">u8</span>) };
 =20
      byte.method()
  }
 =20
  <span class=3D"kw">static</span> Foo_for_u8_vtable: FooVtable =3D FooVtab=
le {
      destructor: <span class=3D"co">/* compiler magic */</span>,
      size: <span class=3D"dv">1</span>,
      align: <span class=3D"dv">1</span>,
 =20
      <span class=3D"co">// cast to a function pointer</span>
      method: call_method_on_u8 <span class=3D"kw">as</span> <span class=3D=
"kw">fn</span>(*const ()) -&gt; String,
  };
 =20
 =20
  <span class=3D"co">// String:</span>
 =20
  <span class=3D"kw">fn</span> call_method_on_String(x: *const ()) -&gt; St=
ring {
      <span class=3D"co">// the compiler guarantees that this function is o=
nly called</span>
      <span class=3D"co">// with `x` pointing to a String</span>
      <span class=3D"kw">let</span> string: &amp;String =3D <span class=3D"=
kw">unsafe</span> { &amp;*(x <span class=3D"kw">as</span> *const String) };
 =20
      string.method()
  }
 =20
  <span class=3D"kw">static</span> Foo_for_String_vtable: FooVtable =3D Foo=
Vtable {
      destructor: <span class=3D"co">/* compiler magic */</span>,
      <span class=3D"co">// values for a 64-bit computer, halve them for 32=
-bit ones</span>
      size: <span class=3D"dv">24</span>,
      align: <span class=3D"dv">8</span>,
 =20
      method: call_method_on_String <span class=3D"kw">as</span> <span clas=
s=3D"kw">fn</span>(*const ()) -&gt; String,
  };</code></pre></div>
  <p>The <code>destructor</code> field in each vtable points to a function =
that will clean up any resources of the vtable=E2=80=99s type, for <code>u8=
</code> it is trivial, but for <code>String</code> it will free the memory.=
 This is necessary for owning trait objects like <code>Box&lt;Foo&gt;</code=
>, which need to clean-up both the <code>Box</code> allocation as well as t=
he internal type when they go out of scope. The <code>size</code> and <code=
>align</code> fields store the size of the erased type, and its alignment r=
equirements; these are essentially unused at the moment since the informati=
on is embedded in the destructor, but will be used in the future, as trait =
objects are progressively made more flexible.</p>
  <p>Suppose we=E2=80=99ve got some values that implement <code>Foo</code>,=
 then the explicit form of construction and use of <code>Foo</code> trait o=
bjects might look a bit like (ignoring the type mismatches: they=E2=80=99re=
 all just pointers anyway):</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> a: String =3D <span class=3D"=
st">"foo"</span>.to_string();
  <span class=3D"kw">let</span> x: <span class=3D"kw">u8</span> =3D <span c=
lass=3D"dv">1</span>;
 =20
  <span class=3D"co">// let b: &amp;Foo =3D &amp;a;</span>
  <span class=3D"kw">let</span> b =3D TraitObject {
      <span class=3D"co">// store the data</span>
      data: &amp;a,
      <span class=3D"co">// store the methods</span>
      vtable: &amp;Foo_for_String_vtable
  };
 =20
  <span class=3D"co">// let y: &amp;Foo =3D x;</span>
  <span class=3D"kw">let</span> y =3D TraitObject {
      <span class=3D"co">// store the data</span>
      data: &amp;x,
      <span class=3D"co">// store the methods</span>
      vtable: &amp;Foo_for_u8_vtable
  };
 =20
  <span class=3D"co">// b.method();</span>
  (b.vtable.method)(b.data);
 =20
  <span class=3D"co">// y.method();</span>
  (y.vtable.method)(y.data);</code></pre></div>
  <p>If <code>b</code> or <code>y</code> were owning trait objects (<code>B=
ox&lt;Foo&gt;</code>), there would be a <code>(b.vtable.destructor)(b.data)=
</code> (respectively <code>y</code>) call when they went out of scope.</p>
  <h2 id=3D"sec--closures">Closures</h2>
  <p>Rust not only has named functions, but anonymous functions as well. An=
onymous functions that have an associated environment are called =E2=80=98c=
losures=E2=80=99, because they close over an environment. Rust has a really=
 great implementation of them, as we=E2=80=99ll see.</p>
  <h3 id=3D"syntax">Syntax</h3>
  <p>Closures look like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> plus_one =3D |x: <span class=
=3D"kw">i32</span>| x + <span class=3D"dv">1</span>;
 =20
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">2</span>, plus_on=
e(<span class=3D"dv">1</span>));</code></pre></div>
  <p>We create a binding, <code>plus_one</code>, and assign it to a closure=
. The closure=E2=80=99s arguments go between the pipes (<code>|</code>), an=
d the body is an expression, in this case, <code>x + 1</code>. Remember tha=
t <code>{ }</code> is an expression, so we can have multi-line closures too=
:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> plus_two =3D |x| {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> result: <=
span class=3D"kw">i32</span> =3D x;
 =20
      result +=3D <span class=3D"dv">1</span>;
      result +=3D <span class=3D"dv">1</span>;
 =20
      result
  };
 =20
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">4</span>, plus_tw=
o(<span class=3D"dv">2</span>));</code></pre></div>
  <p>You=E2=80=99ll notice a few things about closures that are a bit diffe=
rent than regular functions defined with <code>fn</code>. The first of whic=
h is that we did not need to annotate the types of arguments the closure ta=
kes or the values it returns. We can:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> plus_one =3D |x: <span class=
=3D"kw">i32</span>| -&gt; <span class=3D"kw">i32</span> { x + <span class=
=3D"dv">1</span> };
 =20
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">2</span>, plus_on=
e(<span class=3D"dv">1</span>));</code></pre></div>
  <p>But we don=E2=80=99t have to. Why is this? Basically, it was chosen fo=
r ergonomic reasons. While specifying the full type for named functions is =
helpful with things like documentation and type inference, the types of clo=
sures are rarely documented since they=E2=80=99re anonymous, and they don=
=E2=80=99t cause the kinds of error-at-a-distance that inferring named func=
tion types can.</p>
  <p>The second is that the syntax is similar, but a bit different. I=E2=80=
=99ve added spaces here to make them look a little closer:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span>  plus_one_v1   (x: <span class=
=3D"kw">i32</span> ) -&gt; <span class=3D"kw">i32</span> { x + <span class=
=3D"dv">1</span> }
  <span class=3D"kw">let</span> plus_one_v2 =3D |x: <span class=3D"kw">i32<=
/span> | -&gt; <span class=3D"kw">i32</span> { x + <span class=3D"dv">1</sp=
an> };
  <span class=3D"kw">let</span> plus_one_v3 =3D |x: <span class=3D"kw">i32<=
/span> |          x + <span class=3D"dv">1</span>  ;</code></pre></div>
  <p>Small differences, but they=E2=80=99re similar in ways.</p>
  <h3 id=3D"closures-and-their-environment">Closures and their environment<=
/h3>
  <p>Closures are called such because they =E2=80=98close over their enviro=
nment=E2=80=99. It looks like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> num =3D <span class=3D"dv">5<=
/span>;
  <span class=3D"kw">let</span> plus_num =3D |x: <span class=3D"kw">i32</sp=
an>| x + num;
 =20
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">10</span>, plus_n=
um(<span class=3D"dv">5</span>));</code></pre></div>
  <p>This closure, <code>plus_num</code>, refers to a <code>let</code> bind=
ing in its scope: <code>num</code>. More specifically, it borrows the bindi=
ng. If we do something that would conflict with that binding, we get an err=
or. Like this one:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 num =3D <span class=3D"dv">5</span>;
  <span class=3D"kw">let</span> plus_num =3D |x: <span class=3D"kw">i32</sp=
an>| x + num;
 =20
  <span class=3D"kw">let</span> y =3D &amp;<span class=3D"kw">mut</span> nu=
m;</code></pre></div>
  <p>Which errors with:</p>
  <pre><code>error: cannot borrow `num` as mutable because it is also borro=
wed as immutable
      let y =3D &amp;mut num;
                   ^~~
  note: previous borrow of `num` occurs here due to use in closure; the imm=
utable
    borrow prevents subsequent moves or mutable borrows of `num` until the =
borrow
    ends
      let plus_num =3D |x| x + num;
                     ^~~~~~~~~~~
  note: previous borrow ends here
  fn main() {
      let mut num =3D 5;
      let plus_num =3D |x| x + num;
     =20
      let y =3D &amp;mut num;
  }
  ^</code></pre>
  <p>A verbose yet helpful error message! As it says, we can=E2=80=99t take=
 a mutable borrow on <code>num</code> because the closure is already borrow=
ing it. If we let the closure go out of scope, we can:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 num =3D <span class=3D"dv">5</span>;
  {
      <span class=3D"kw">let</span> plus_num =3D |x: <span class=3D"kw">i32=
</span>| x + num;
 =20
  } <span class=3D"co">// plus_num goes out of scope, borrow of num ends</s=
pan>
 =20
  <span class=3D"kw">let</span> y =3D &amp;<span class=3D"kw">mut</span> nu=
m;</code></pre></div>
  <p>If your closure requires it, however, Rust will take ownership and mov=
e the environment instead:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> nums =3D <span class=3D"ot">v=
ec!</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span =
class=3D"dv">3</span>];
 =20
  <span class=3D"kw">let</span> takes_nums =3D || nums;
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"{:?}"</span>, nums=
);</code></pre></div>
  <p>This gives us:</p>
  <pre><code>note: `nums` moved into closure environment here because it ha=
s type
    `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-co=
pyable
  let takes_nums =3D || nums;
                      ^~~~~~~</code></pre>
  <p><code>Vec&lt;T&gt;</code> has ownership over its contents, and therefo=
re, when we refer to it in our closure, we have to take ownership of <code>=
nums</code>. It=E2=80=99s the same as if we=E2=80=99d passed <code>nums</co=
de> to a function that took ownership of it.</p>
  <h4 id=3D"move-closures"><code>move</code> closures</h4>
  <p>We can force our closure to take ownership of its environment with the=
 <code>move</code> keyword:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> num =3D <span class=3D"dv">5<=
/span>;
 =20
  <span class=3D"kw">let</span> owns_num =3D move |x: <span class=3D"kw">i3=
2</span>| x + num;</code></pre></div>
  <p>Now, even though the keyword is <code>move</code>, the variables follo=
w normal move semantics. In this case, <code>5</code> implements <code>Copy=
</code>, and so <code>owns_num</code> takes ownership of a copy of <code>nu=
m</code>. So what=E2=80=99s the difference?</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 num =3D <span class=3D"dv">5</span>;
 =20
  {=20
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> add_num =
=3D |x: <span class=3D"kw">i32</span>| num +=3D x;
 =20
      add_num(<span class=3D"dv">5</span>);
  }
 =20
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">10</span>, num);<=
/code></pre></div>
  <p>So in this case, our closure took a mutable reference to <code>num</co=
de>, and then when we called <code>add_num</code>, it mutated the underlyin=
g value, as we=E2=80=99d expect. We also needed to declare <code>add_num</c=
ode> as <code>mut</code> too, because we=E2=80=99re mutating its environmen=
t.</p>
  <p>If we change to a <code>move</code> closure, it=E2=80=99s different:</=
p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> <span class=3D"kw">mut</span>=
 num =3D <span class=3D"dv">5</span>;
 =20
  {=20
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> add_num =
=3D move |x: <span class=3D"kw">i32</span>| num +=3D x;
 =20
      add_num(<span class=3D"dv">5</span>);
  }
 =20
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">5</span>, num);</=
code></pre></div>
  <p>We only get <code>5</code>. Rather than taking a mutable borrow out on=
 our <code>num</code>, we took ownership of a copy.</p>
  <p>Another way to think about <code>move</code> closures: they give a clo=
sure its own stack frame. Without <code>move</code>, a closure may be tied =
to the stack frame that created it, while a <code>move</code> closure is se=
lf-contained. This means that you cannot generally return a non-<code>move<=
/code> closure from a function, for example.</p>
  <p>But before we talk about taking and returning closures, we should talk=
 some more about the way that closures are implemented. As a systems langua=
ge, Rust gives you tons of control over what your code does, and closures a=
re no different.</p>
  <h3 id=3D"closure-implementation">Closure implementation</h3>
  <p>Rust=E2=80=99s implementation of closures is a bit different than othe=
r languages. They are effectively syntax sugar for traits. You=E2=80=99ll w=
ant to make sure to have read the <a href=3D"https://killercup.github.io/tr=
pl-ebook/trpl-2015-05-13.html#sec--traits">traits chapter</a> before this o=
ne, as well as the chapter on <a href=3D"https://killercup.github.io/trpl-e=
book/trpl-2015-05-13.html#sec--trait-objects">trait objects</a>.</p>
  <p>Got all that? Good.</p>
  <p>The key to understanding how closures work under the hood is something=
 a bit strange: Using <code>()</code> to call a function, like <code>foo()<=
/code>, is an overloadable operator. From this, everything else clicks into=
 place. In Rust, we use the trait system to overload operators. Calling fun=
ctions is no different. We have three separate traits to overload with:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">trait</spa=
n> Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
      <span class=3D"kw">extern</span> <span class=3D"st">"rust-call"</span=
> <span class=3D"kw">fn</span> call(&amp;<span class=3D"kw">self</span>, ar=
gs: Args) -&gt; <span class=3D"kw">Self</span>::Output;
  }
 =20
  <span class=3D"kw">pub</span> <span class=3D"kw">trait</span> FnMut&lt;Ar=
gs&gt; : FnOnce&lt;Args&gt; {
      <span class=3D"kw">extern</span> <span class=3D"st">"rust-call"</span=
> <span class=3D"kw">fn</span> call_mut(&amp;<span class=3D"kw">mut</span> =
<span class=3D"kw">self</span>, args: Args) -&gt; <span class=3D"kw">Self</=
span>::Output;
  }
 =20
  <span class=3D"kw">pub</span> <span class=3D"kw">trait</span> FnOnce&lt;A=
rgs&gt; {
      <span class=3D"kw">type</span> Output;
 =20
      extern "rust-call" fn call_once(self, args: Args) -&gt; Self::Output;
  }</code></pre></div>
  <p>You=E2=80=99ll notice a few differences between these traits, but a bi=
g one is <code>self</code>: <code>Fn</code> takes <code>&amp;self</code>, <=
code>FnMut</code> takes <code>&amp;mut self</code>, and <code>FnOnce</code>=
 takes <code>self</code>. This covers all three kinds of <code>self</code> =
via the usual method call syntax. But we=E2=80=99ve split them up into thre=
e traits, rather than having a single one. This gives us a large amount of =
control over what kind of closures we can take.</p>
  <p>The <code>|| {}</code> syntax for closures is sugar for these three tr=
aits. Rust will generate a struct for the environment, <code>impl</code> th=
e appropriate trait, and then use it.</p>
  <h3 id=3D"taking-closures-as-arguments">Taking closures as arguments</h3>
  <p>Now that we know that closures are traits, we already know how to acce=
pt and return closures: just like any other trait!</p>
  <p>This also means that we can choose static vs dynamic dispatch as well.=
 First, let=E2=80=99s write a function which takes something callable, call=
s it, and returns the result:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> call_with_one&lt;F&gt;(some_cl=
osure: F) -&gt; <span class=3D"kw">i32</span>
      where F : Fn(<span class=3D"kw">i32</span>) -&gt; <span class=3D"kw">=
i32</span> {
 =20
      some_closure(<span class=3D"dv">1</span>)
  }
 =20
  <span class=3D"kw">let</span> answer =3D call_with_one(|x| x + <span clas=
s=3D"dv">2</span>);
 =20
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">3</span>, answer)=
;</code></pre></div>
  <p>We pass our closure, <code>|x| x + 2</code>, to <code>call_with_one</c=
ode>. It just does what it suggests: it calls the closure, giving it <code>=
1</code> as an argument.</p>
  <p>Let=E2=80=99s examine the signature of <code>call_with_one</code> in m=
ore depth:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> call_with_one&lt;F&gt;(some_cl=
osure: F) -&gt; <span class=3D"kw">i32</span></code></pre></div>
  <p>We take one parameter, and it has the type <code>F</code>. We also ret=
urn a <code>i32</code>. This part isn=E2=80=99t interesting. The next part =
is:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">    where F : Fn(<span class=3D"kw">i32</span>) -&gt; <span=
 class=3D"kw">i32</span> {</code></pre></div>
  <p>Because <code>Fn</code> is a trait, we can bound our generic with it. =
In this case, our closure takes a <code>i32</code> as an argument and retur=
ns an <code>i32</code>, and so the generic bound we use is <code>Fn(i32) -&=
gt; i32</code>.</p>
  <p>There=E2=80=99s one other key point here: because we=E2=80=99re boundi=
ng a generic with a trait, this will get monomorphized, and therefore, we=
=E2=80=99ll be doing static dispatch into the closure. That=E2=80=99s prett=
y neat. In many languages, closures are inherently heap allocated, and will=
 always involve dynamic dispatch. In Rust, we can stack allocate our closur=
e environment, and statically dispatch the call. This happens quite often w=
ith iterators and their adapters, which often take closures as arguments.</=
p>
  <p>Of course, if we want dynamic dispatch, we can get that too. A trait o=
bject handles this case, as usual:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> call_with_one(some_closure: &a=
mp;Fn(<span class=3D"kw">i32</span>) -&gt; <span class=3D"kw">i32</span>) -=
&gt; <span class=3D"kw">i32</span> {
      some_closure(<span class=3D"dv">1</span>)
  }
 =20
  <span class=3D"kw">let</span> answer =3D call_with_one(&amp;|x| x + <span=
 class=3D"dv">2</span>);
 =20
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">3</span>, answer)=
;</code></pre></div>
  <p>Now we take a trait object, a <code>&amp;Fn</code>. And we have to mak=
e a reference to our closure when we pass it to <code>call_with_one</code>,=
 so we use <code>&amp;||</code>.</p>
  <h3 id=3D"returning-closures">Returning closures</h3>
  <p>It=E2=80=99s very common for functional-style code to return closures =
in various situations. If you try to return a closure, you may run into an =
error. At first, it may seem strange, but we=E2=80=99ll figure it out. Here=
=E2=80=99s how you=E2=80=99d probably try to return a closure from a functi=
on:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> factory() -&gt; (Fn(<span clas=
s=3D"kw">i32</span>) -&gt; Vec&lt;<span class=3D"kw">i32</span>&gt;) {
      <span class=3D"kw">let</span> vec =3D <span class=3D"ot">vec!</span>[=
<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv=
">3</span>];
 =20
      |n| vec.push(n)
  }
 =20
  <span class=3D"kw">let</span> f =3D factory();
 =20
  <span class=3D"kw">let</span> answer =3D f(<span class=3D"dv">4</span>);
  <span class=3D"ot">assert_eq!</span>(<span class=3D"ot">vec!</span>[<span=
 class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</=
span>, <span class=3D"dv">4</span>], answer);</code></pre></div>
  <p>This gives us these long, related errors:</p>
  <pre><code>error: the trait `core::marker::Sized` is not implemented for =
the type
  `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` [E0277]
  f =3D factory();
  ^
  note: `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` does no=
t have a
  constant size known at compile-time
  f =3D factory();
  ^
  error: the trait `core::marker::Sized` is not implemented for the type
  `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` [E0277]
  factory() -&gt; (Fn(i32) -&gt; Vec&lt;i32&gt;) {
               ^~~~~~~~~~~~~~~~~~~~~
  note: `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` does no=
t have a constant size known at compile-time
  fa ctory() -&gt; (Fn(i32) -&gt; Vec&lt;i32&gt;) {
                ^~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>In order to return something from a function, Rust needs to know what =
size the return type is. But since <code>Fn</code> is a trait, it could be =
various things of various sizes: many different types can implement <code>F=
n</code>. An easy way to give something a size is to take a reference to it=
, as references have a known size. So we=E2=80=99d write this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> factory() -&gt; &amp;(Fn(<span=
 class=3D"kw">i32</span>) -&gt; Vec&lt;<span class=3D"kw">i32</span>&gt;) {
      <span class=3D"kw">let</span> vec =3D <span class=3D"ot">vec!</span>[=
<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv=
">3</span>];
 =20
      |n| vec.push(n)
  }
 =20
  <span class=3D"kw">let</span> f =3D factory();
 =20
  <span class=3D"kw">let</span> answer =3D f(<span class=3D"dv">4</span>);
  <span class=3D"ot">assert_eq!</span>(<span class=3D"ot">vec!</span>[<span=
 class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">3</=
span>, <span class=3D"dv">4</span>], answer);</code></pre></div>
  <p>But we get another error:</p>
  <pre><code>error: missing lifetime specifier [E0106]
  fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                  ^~~~~~~~~~~~~~~~~</code></pre>
  <p>Right. Because we have a reference, we need to give it a lifetime. But=
 our <code>factory()</code> function takes no arguments, so elision doesn=
=E2=80=99t kick in here. What lifetime can we choose? <code>'static</code>:=
</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> factory() -&gt; &amp;<span cla=
ss=3D"ot">'static</span> (Fn(<span class=3D"kw">i32</span>) -&gt; <span cla=
ss=3D"kw">i32</span>) {
      <span class=3D"kw">let</span> num =3D <span class=3D"dv">5</span>;
 =20
      |x| x + num
  }
 =20
  <span class=3D"kw">let</span> f =3D factory();
 =20
  <span class=3D"kw">let</span> answer =3D f(<span class=3D"dv">1</span>);
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">6</span>, answer)=
;</code></pre></div>
  <p>But we get another error:</p>
  <pre><code>error: mismatched types:
   expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,
      found `[closure &lt;anon&gt;:7:9: 7:20]`
  (expected &amp;-ptr,
      found closure) [E0308]
           |x| x + num
           ^~~~~~~~~~~</code></pre>
  <p>This error is letting us know that we don=E2=80=99t have a <code>&amp;=
'static Fn(i32) -&gt; i32</code>, we have a <code>[closure &lt;anon&gt;:7:9=
: 7:20]</code>. Wait, what?</p>
  <p>Because each closure generates its own environment <code>struct</code>=
 and implementation of <code>Fn</code> and friends, these types are anonymo=
us. They exist just solely for this closure. So Rust shows them as <code>cl=
osure &lt;anon&gt;</code>, rather than some autogenerated name.</p>
  <p>But why doesn=E2=80=99t our closure implement <code>&amp;'static Fn</c=
ode>? Well, as we discussed before, closures borrow their environment. And =
in this case, our environment is based on a stack-allocated <code>5</code>,=
 the <code>num</code> variable binding. So the borrow has a lifetime of the=
 stack frame. So if we returned this closure, the function call would be ov=
er, the stack frame would go away, and our closure is capturing an environm=
ent of garbage memory!</p>
  <p>So what to do? This <em>almost</em> works:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> factory() -&gt; Box&lt;Fn(<spa=
n class=3D"kw">i32</span>) -&gt; <span class=3D"kw">i32</span>&gt; {
      <span class=3D"kw">let</span> num =3D <span class=3D"dv">5</span>;
 =20
      Box::new(|x| x + num)
  }
  <span class=3D"kw">let</span> f =3D factory();
 =20
  <span class=3D"kw">let</span> answer =3D f(<span class=3D"dv">1</span>);
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">6</span>, answer)=
;</code></pre></div>
  <p>We use a trait object, by <code>Box</code>ing up the <code>Fn</code>. =
There=E2=80=99s just one last problem:</p>
  <pre><code>error: `num` does not live long enough
  Box::new(|x| x + num)
           ^~~~~~~~~~~</code></pre>
  <p>We still have a reference to the parent stack frame. With one last fix=
, we can make this work:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> factory() -&gt; Box&lt;Fn(<spa=
n class=3D"kw">i32</span>) -&gt; <span class=3D"kw">i32</span>&gt; {
      <span class=3D"kw">let</span> num =3D <span class=3D"dv">5</span>;
 =20
      Box::new(move |x| x + num)
  }
  <span class=3D"kw">let</span> f =3D factory();
 =20
  <span class=3D"kw">let</span> answer =3D f(<span class=3D"dv">1</span>);
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">6</span>, answer)=
;</code></pre></div>
  <p>By making the inner closure a <code>move Fn</code>, we create a new st=
ack frame for our closure. By <code>Box</code>ing it up, we=E2=80=99ve give=
n it a known size, and allowing it to escape our stack frame.</p>
  <h2 id=3D"sec--ufcs">Universal Function Call Syntax</h2>
  <p>Sometimes, functions can have the same names. Consider this code:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> Foo {
      <span class=3D"kw">fn</span> f(&amp;<span class=3D"kw">self</span>);
  }
 =20
  <span class=3D"kw">trait</span> Bar {
      <span class=3D"kw">fn</span> f(&amp;<span class=3D"kw">self</span>);
  }
 =20
  <span class=3D"kw">struct</span> Baz;
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> Baz {
      <span class=3D"kw">fn</span> f(&amp;<span class=3D"kw">self</span>) {=
 <span class=3D"ot">println!</span>(<span class=3D"st">"Baz=E2=80=99s impl =
of Foo"</span>); }
  }
 =20
  <span class=3D"kw">impl</span> Bar <span class=3D"kw">for</span> Baz {
      <span class=3D"kw">fn</span> f(&amp;<span class=3D"kw">self</span>) {=
 <span class=3D"ot">println!</span>(<span class=3D"st">"Baz=E2=80=99s impl =
of Bar"</span>); }
  }
 =20
  <span class=3D"kw">let</span> b =3D Baz;</code></pre></div>
  <p>If we were to try to call <code>b.f()</code>, we=E2=80=99d get an erro=
r:</p>
  <pre><code>error: multiple applicable methods in scope [E0034]
  b.f();
    ^~~
  note: candidate #1 is defined in an impl of the trait `main::Foo` for the=
 type
  `main::Baz`
      fn f(&amp;self) { println!("Baz=E2=80=99s impl of Foo"); }
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  note: candidate #2 is defined in an impl of the trait `main::Bar` for the=
 type
  `main::Baz`
      fn f(&amp;self) { println!("Baz=E2=80=99s impl of Bar"); }
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>We need a way to disambiguate which method we need. This feature is ca=
lled =E2=80=98universal function call syntax=E2=80=99, and it looks like th=
is:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">Foo::f(&amp;b);
  Bar::f(&amp;b);</code></pre></div>
  <p>Let=E2=80=99s break it down.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">Foo::
  Bar::</code></pre></div>
  <p>These halves of the invocation are the types of the two traits: <code>=
Foo</code> and <code>Bar</code>. This is what ends up actually doing the di=
sambiguation between the two: Rust calls the one from the trait name you us=
e.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">f(&amp;b)</code></pre></div>
  <p>When we call a method like <code>b.f()</code> using <a href=3D"https:/=
/killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--method-syntax">me=
thod syntax</a>, Rust will automatically borrow <code>b</code> if <code>f()=
</code> takes <code>&amp;self</code>. In this case, Rust will not, and so w=
e need to pass an explicit <code>&amp;b</code>.</p>
  <h3 id=3D"angle-bracket-form">Angle-bracket Form</h3>
  <p>The form of UFCS we just talked about:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">Trait::method(args);</code></pre></div>
  <p>Is a short-hand. There=E2=80=99s an expanded form of this that=E2=80=
=99s needed in some situations:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">&lt;Type <span class=3D"kw">as</span> Trait&gt;::method(arg=
s);</code></pre></div>
  <p>The <code>&lt;&gt;::</code> syntax is a means of providing a type hint=
. The type goes inside the <code>&lt;&gt;</code>s. In this case, the type i=
s <code>Type as Trait</code>, indicating that we want <code>Trait</code>=E2=
=80=99s version of <code>method</code> to be called here. The <code>as Trai=
t</code> part is optional if it=E2=80=99s not ambiguous. Same with the angl=
e brackets, hence the shorter form.</p>
  <p>Here=E2=80=99s an example of using the longer form.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> Foo {
      <span class=3D"kw">fn</span> clone(&amp;<span class=3D"kw">self</span=
>);
  }
 =20
  <span class=3D"ot">#[</span>derive<span class=3D"ot">(</span>Clone<span c=
lass=3D"ot">)]</span>
  <span class=3D"kw">struct</span> Bar;
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> Bar {
      <span class=3D"kw">fn</span> clone(&amp;<span class=3D"kw">self</span=
>) {
          <span class=3D"ot">println!</span>(<span class=3D"st">"Making a c=
lone of Bar"</span>);
 =20
          &lt;Bar <span class=3D"kw">as</span> Clone&gt;::clone(<span class=
=3D"kw">self</span>);
      }
  }</code></pre></div>
  <p>This will call the <code>Clone</code> trait=E2=80=99s <code>clone()</c=
ode> method, rather than <code>Foo</code>=E2=80=99s.</p>
  <h2 id=3D"sec--crates-and-modules">Crates and Modules</h2>
  <p>When a project starts getting large, it=E2=80=99s considered good soft=
ware engineering practice to split it up into a bunch of smaller pieces, an=
d then fit them together. It=E2=80=99s also important to have a well-define=
d interface, so that some of your functionality is private, and some is pub=
lic. To facilitate these kinds of things, Rust has a module system.</p>
  <h3 id=3D"basic-terminology-crates-and-modules">Basic terminology: Crates=
 and Modules</h3>
  <p>Rust has two distinct terms that relate to the module system: =E2=80=
=98crate=E2=80=99 and =E2=80=98module=E2=80=99. A crate is synonymous with =
a =E2=80=98library=E2=80=99 or =E2=80=98package=E2=80=99 in other languages=
. Hence =E2=80=9CCargo=E2=80=9D as the name of Rust=E2=80=99s package manag=
ement tool: you ship your crates to others with Cargo. Crates can produce a=
n executable or a library, depending on the project.</p>
  <p>Each crate has an implicit <em>root module</em> that contains the code=
 for that crate. You can then define a tree of sub-modules under that root =
module. Modules allow you to partition your code within the crate itself.</=
p>
  <p>As an example, let=E2=80=99s make a <em>phrases</em> crate, which will=
 give us various phrases in different languages. To keep things simple, we=
=E2=80=99ll stick to =E2=80=98greetings=E2=80=99 and =E2=80=98farewells=E2=
=80=99 as two kinds of phrases, and use English and Japanese (=E6=97=A5=E6=
=9C=AC=E8=AA=9E) as two languages for those phrases to be in. We=E2=80=99ll=
 use this module layout:</p>
  <pre><code>                                    +-----------+
                                  +---| greetings |
                                  |   +-----------+
                    +---------+   |
                +---| english |---+
                |   +---------+   |   +-----------+
                |                 +---| farewells |
  +---------+   |                     +-----------+
  | phrases |---+
  +---------+   |                     +-----------+
                |                 +---| greetings |
                |   +----------+  |   +-----------+
                +---| japanese |--+
                    +----------+  |
                                  |   +-----------+
                                  +---| farewells |
                                      +-----------+</code></pre>
  <p>In this example, <code>phrases</code> is the name of our crate. All of=
 the rest are modules. You can see that they form a tree, branching out fro=
m the crate <em>root</em>, which is the root of the tree: <code>phrases</co=
de> itself.</p>
  <p>Now that we have a plan, let=E2=80=99s define these modules in code. T=
o start, generate a new crate with Cargo:</p>
  <pre><code>$ cargo new phrases
  $ cd phrases</code></pre>
  <p>If you remember, this generates a simple project for us:</p>
  <pre><code>$ tree .
  .
  =E2=94=9C=E2=94=80=E2=94=80 Cargo.toml
  =E2=94=94=E2=94=80=E2=94=80 src
      =E2=94=94=E2=94=80=E2=94=80 lib.rs
 =20
  1 directory, 2 files</code></pre>
  <p><code>src/lib.rs</code> is our crate root, corresponding to the <code>=
phrases</code> in our diagram above.</p>
  <h3 id=3D"defining-modules">Defining Modules</h3>
  <p>To define each of our modules, we use the <code>mod</code> keyword. Le=
t=E2=80=99s make our <code>src/lib.rs</code> look like this:</p>
  <pre><code>mod english {
      mod greetings {
      }
 =20
      mod farewells {
      }
  }
 =20
  mod japanese {
      mod greetings {
      }
 =20
      mod farewells {
      }
  }</code></pre>
  <p>After the <code>mod</code> keyword, you give the name of the module. M=
odule names follow the conventions for other Rust identifiers: <code>lower_=
snake_case</code>. The contents of each module are within curly braces (<co=
de>{}</code>).</p>
  <p>Within a given <code>mod</code>, you can declare sub-<code>mod</code>s=
. We can refer to sub-modules with double-colon (<code>::</code>) notation:=
 our four nested modules are <code>english::greetings</code>, <code>english=
::farewells</code>, <code>japanese::greetings</code>, and <code>japanese::f=
arewells</code>. Because these sub-modules are namespaced under their paren=
t module, the names don=E2=80=99t conflict: <code>english::greetings</code>=
 and <code>japanese::greetings</code> are distinct, even though their names=
 are both <code>greetings</code>.</p>
  <p>Because this crate does not have a <code>main()</code> function, and i=
s called <code>lib.rs</code>, Cargo will build this crate as a library:</p>
  <pre><code>$ cargo build
     Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
  $ ls target/debug
  build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native</code></p=
re>
  <p><code>libphrase-hash.rlib</code> is the compiled crate. Before we see =
how to use this crate from another crate, let=E2=80=99s break it up into mu=
ltiple files.</p>
  <h3 id=3D"multiple-file-crates">Multiple file crates</h3>
  <p>If each crate were just one file, these files would get very large. It=
=E2=80=99s often easier to split up crates into multiple files, and Rust su=
pports this in two ways.</p>
  <p>Instead of declaring a module like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">mod</span> english {
      <span class=3D"co">// contents of our module go here</span>
  }</code></pre></div>
  <p>We can instead declare our module like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">mod</span> english;</code></pre></div>
  <p>If we do that, Rust will expect to find either a <code>english.rs</cod=
e> file, or a <code>english/mod.rs</code> file with the contents of our mod=
ule.</p>
  <p>Note that in these files, you don=E2=80=99t need to re-declare the mod=
ule: that=E2=80=99s already been done with the initial <code>mod</code> dec=
laration.</p>
  <p>Using these two techniques, we can break up our crate into two directo=
ries and seven files:</p>
  <pre><code>$ tree .
  .
  =E2=94=9C=E2=94=80=E2=94=80 Cargo.lock
  =E2=94=9C=E2=94=80=E2=94=80 Cargo.toml
  =E2=94=9C=E2=94=80=E2=94=80 src
  =E2=94=82&nbsp;&nbsp; =E2=94=9C=E2=94=80=E2=94=80 english
  =E2=94=82&nbsp;&nbsp; =E2=94=82&nbsp;&nbsp; =E2=94=9C=E2=94=80=E2=94=80 f=
arewells.rs
  =E2=94=82&nbsp;&nbsp; =E2=94=82&nbsp;&nbsp; =E2=94=9C=E2=94=80=E2=94=80 g=
reetings.rs
  =E2=94=82&nbsp;&nbsp; =E2=94=82&nbsp;&nbsp; =E2=94=94=E2=94=80=E2=94=80 m=
od.rs
  =E2=94=82&nbsp;&nbsp; =E2=94=9C=E2=94=80=E2=94=80 japanese
  =E2=94=82&nbsp;&nbsp; =E2=94=82&nbsp;&nbsp; =E2=94=9C=E2=94=80=E2=94=80 f=
arewells.rs
  =E2=94=82&nbsp;&nbsp; =E2=94=82&nbsp;&nbsp; =E2=94=9C=E2=94=80=E2=94=80 g=
reetings.rs
  =E2=94=82&nbsp;&nbsp; =E2=94=82&nbsp;&nbsp; =E2=94=94=E2=94=80=E2=94=80 m=
od.rs
  =E2=94=82&nbsp;&nbsp; =E2=94=94=E2=94=80=E2=94=80 lib.rs
  =E2=94=94=E2=94=80=E2=94=80 target
      =E2=94=94=E2=94=80=E2=94=80 debug
          =E2=94=9C=E2=94=80=E2=94=80 build
          =E2=94=9C=E2=94=80=E2=94=80 deps
          =E2=94=9C=E2=94=80=E2=94=80 examples
          =E2=94=9C=E2=94=80=E2=94=80 libphrases-a7448e02a0468eaa.rlib
          =E2=94=94=E2=94=80=E2=94=80 native</code></pre>
  <p><code>src/lib.rs</code> is our crate root, and looks like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">mod</span> english;
  <span class=3D"kw">mod</span> japanese;</code></pre></div>
  <p>These two declarations tell Rust to look for either <code>src/english.=
rs</code> and <code>src/japanese.rs</code>, or <code>src/english/mod.rs</co=
de> and <code>src/japanese/mod.rs</code>, depending on our preference. In t=
his case, because our modules have sub-modules, we=E2=80=99ve chosen the se=
cond. Both <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</c=
ode> look like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">mod</span> greetings;
  <span class=3D"kw">mod</span> farewells;</code></pre></div>
  <p>Again, these declarations tell Rust to look for either <code>src/engli=
sh/greetings.rs</code> and <code>src/japanese/greetings.rs</code> or <code>=
src/english/farewells/mod.rs</code> and <code>src/japanese/farewells/mod.rs=
</code>. Because these sub-modules don=E2=80=99t have their own sub-modules=
, we=E2=80=99ve chosen to make them <code>src/english/greetings.rs</code> a=
nd <code>src/japanese/farewells.rs</code>. Whew!</p>
  <p>The contents of <code>src/english/greetings.rs</code> and <code>src/ja=
panese/farewells.rs</code> are both empty at the moment. Let=E2=80=99s add =
some functions.</p>
  <p>Put this in <code>src/english/greetings.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> hello() -&gt; String {
      <span class=3D"st">"Hello!"</span>.to_string()
  }</code></pre></div>
  <p>Put this in <code>src/english/farewells.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> goodbye() -&gt; String {
      <span class=3D"st">"Goodbye."</span>.to_string()
  }</code></pre></div>
  <p>Put this in <code>src/japanese/greetings.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> hello() -&gt; String {
      <span class=3D"st">"=E3=81=93=E3=82=93=E3=81=AB=E3=81=A1=E3=81=AF"</s=
pan>.to_string()
  }</code></pre></div>
  <p>Of course, you can copy and paste this from this web page, or just typ=
e something else. It=E2=80=99s not important that you actually put =E2=80=
=98konnichiwa=E2=80=99 to learn about the module system.</p>
  <p>Put this in <code>src/japanese/farewells.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> goodbye() -&gt; String {
      <span class=3D"st">"=E3=81=95=E3=82=88=E3=81=86=E3=81=AA=E3=82=89"</s=
pan>.to_string()
  }</code></pre></div>
  <p>(This is =E2=80=98Say=C5=8Dnara=E2=80=99, if you=E2=80=99re curious.)<=
/p>
  <p>Now that we have some functionality in our crate, let=E2=80=99s try to=
 use it from another crate.</p>
  <h3 id=3D"importing-external-crates">Importing External Crates</h3>
  <p>We have a library crate. Let=E2=80=99s make an executable crate that i=
mports and uses our library.</p>
  <p>Make a <code>src/main.rs</code> and put this in it (it won=E2=80=99t q=
uite compile yet):</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate phrases;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello in Engli=
sh: {}"</span>, phrases::english::greetings::hello());
      <span class=3D"ot">println!</span>(<span class=3D"st">"Goodbye in Eng=
lish: {}"</span>, phrases::english::farewells::goodbye());
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello in Japan=
ese: {}"</span>, phrases::japanese::greetings::hello());
      <span class=3D"ot">println!</span>(<span class=3D"st">"Goodbye in Jap=
anese: {}"</span>, phrases::japanese::farewells::goodbye());
  }</code></pre></div>
  <p>The <code>extern crate</code> declaration tells Rust that we need to c=
ompile and link to the <code>phrases</code> crate. We can then use <code>ph=
rases</code>=E2=80=99 modules in this one. As we mentioned earlier, you can=
 use double colons to refer to sub-modules and the functions inside of them=
.</p>
  <p>Also, Cargo assumes that <code>src/main.rs</code> is the crate root of=
 a binary crate, rather than a library crate. Our package now has two crate=
s: <code>src/lib.rs</code> and <code>src/main.rs</code>. This pattern is qu=
ite common for executable crates: most functionality is in a library crate,=
 and the executable crate uses that library. This way, other programs can a=
lso use the library crate, and it=E2=80=99s also a nice separation of conce=
rns.</p>
  <p>This doesn=E2=80=99t quite work yet, though. We get four errors that l=
ook similar to this:</p>
  <pre><code>$ cargo build
     Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
  src/main.rs:4:38: 4:72 error: function `hello` is private
  src/main.rs:4     println!("Hello in English: {}", phrases::english::gree=
tings::hello());
                                                     ^~~~~~~~~~~~~~~~~~~~~~=
~~~~~~~~~~~~
  note: in expansion of format_args!
  &lt;std macros&gt;:2:25: 2:58 note: expansion site
  &lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
  &lt;std macros&gt;:3:1: 3:54 note: expansion site
  &lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
  phrases/src/main.rs:4:5: 4:76 note: expansion site</code></pre>
  <p>By default, everything is private in Rust. Let=E2=80=99s talk about th=
is in some more depth.</p>
  <h3 id=3D"exporting-a-public-interface">Exporting a Public Interface</h3>
  <p>Rust allows you to precisely control which aspects of your interface a=
re public, and so private is the default. To make things public, you use th=
e <code>pub</code> keyword. Let=E2=80=99s focus on the <code>english</code>=
 module first, so let=E2=80=99s reduce our <code>src/main.rs</code> to just=
 this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate phrases;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello in Engli=
sh: {}"</span>, phrases::english::greetings::hello());
      <span class=3D"ot">println!</span>(<span class=3D"st">"Goodbye in Eng=
lish: {}"</span>, phrases::english::farewells::goodbye());
  }</code></pre></div>
  <p>In our <code>src/lib.rs</code>, let=E2=80=99s add <code>pub</code> to =
the <code>english</code> module declaration:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">mod</span>=
 english;
  <span class=3D"kw">mod</span> japanese;</code></pre></div>
  <p>And in our <code>src/english/mod.rs</code>, let=E2=80=99s make both <c=
ode>pub</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">mod</span>=
 greetings;
  <span class=3D"kw">pub</span> <span class=3D"kw">mod</span> farewells;</c=
ode></pre></div>
  <p>In our <code>src/english/greetings.rs</code>, let=E2=80=99s add <code>=
pub</code> to our <code>fn</code> declaration:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">fn</span> =
hello() -&gt; String {
      <span class=3D"st">"Hello!"</span>.to_string()
  }</code></pre></div>
  <p>And also in <code>src/english/farewells.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">fn</span> =
goodbye() -&gt; String {
      <span class=3D"st">"Goodbye."</span>.to_string()
  }</code></pre></div>
  <p>Now, our crate compiles, albeit with warnings about not using the <cod=
e>japanese</code> functions:</p>
  <pre><code>$ cargo run
     Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
  src/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hell=
o`, #[warn(dead_code)] on by default
  src/japanese/greetings.rs:1 fn hello() -&gt; String {
  src/japanese/greetings.rs:2     "=E3=81=93=E3=82=93=E3=81=AB=E3=81=A1=E3=
=81=AF".to_string()
  src/japanese/greetings.rs:3 }
  src/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `good=
bye`, #[warn(dead_code)] on by default
  src/japanese/farewells.rs:1 fn goodbye() -&gt; String {
  src/japanese/farewells.rs:2     "=E3=81=95=E3=82=88=E3=81=86=E3=81=AA=E3=
=82=89".to_string()
  src/japanese/farewells.rs:3 }
       Running `target/debug/phrases`
  Hello in English: Hello!
  Goodbye in English: Goodbye.</code></pre>
  <p>Now that our functions are public, we can use them. Great! However, ty=
ping out <code>phrases::english::greetings::hello()</code> is very long and=
 repetitive. Rust has another keyword for importing names into the current =
scope, so that you can refer to them with shorter names. Let=E2=80=99s talk=
 about <code>use</code>.</p>
  <h3 id=3D"importing-modules-with-use">Importing Modules with <code>use</c=
ode></h3>
  <p>Rust has a <code>use</code> keyword, which allows us to import names i=
nto our local scope. Let=E2=80=99s change our <code>src/main.rs</code> to l=
ook like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate phrases;
 =20
  <span class=3D"kw">use</span> phrases::english::greetings;
  <span class=3D"kw">use</span> phrases::english::farewells;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello in Engli=
sh: {}"</span>, greetings::hello());
      <span class=3D"ot">println!</span>(<span class=3D"st">"Goodbye in Eng=
lish: {}"</span>, farewells::goodbye());
  }</code></pre></div>
  <p>The two <code>use</code> lines import each module into the local scope=
, so we can refer to the functions by a much shorter name. By convention, w=
hen importing functions, it=E2=80=99s considered best practice to import th=
e module, rather than the function directly. In other words, you <em>can</e=
m> do this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate phrases;
 =20
  <span class=3D"kw">use</span> phrases::english::greetings::hello;
  <span class=3D"kw">use</span> phrases::english::farewells::goodbye;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello in Engli=
sh: {}"</span>, hello());
      <span class=3D"ot">println!</span>(<span class=3D"st">"Goodbye in Eng=
lish: {}"</span>, goodbye());
  }</code></pre></div>
  <p>But it is not idiomatic. This is significantly more likely to introduc=
e a naming conflict. In our short program, it=E2=80=99s not a big deal, but=
 as it grows, it becomes a problem. If we have conflicting names, Rust will=
 give a compilation error. For example, if we made the <code>japanese</code=
> functions public, and tried to do this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate phrases;
 =20
  <span class=3D"kw">use</span> phrases::english::greetings::hello;
  <span class=3D"kw">use</span> phrases::japanese::greetings::hello;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello in Engli=
sh: {}"</span>, hello());
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello in Japan=
ese: {}"</span>, hello());
  }</code></pre></div>
  <p>Rust will give us a compile-time error:</p>
  <pre><code>   Compiling phrases v0.0.1 (file:///home/you/projects/phrases=
)
  src/main.rs:4:5: 4:40 error: a value named `hello` has already been impor=
ted in this module [E0252]
  src/main.rs:4 use phrases::japanese::greetings::hello;
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  error: aborting due to previous error
  Could not compile `phrases`.</code></pre>
  <p>If we=E2=80=99re importing multiple names from the same module, we don=
=E2=80=99t have to type it out twice. Instead of this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> phrases::english::greetings;
  <span class=3D"kw">use</span> phrases::english::farewells;</code></pre></=
div>
  <p>We can use this shortcut:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> phrases::english::{greetings,=
 farewells};</code></pre></div>
  <h4 id=3D"re-exporting-with-pub-use">Re-exporting with <code>pub use</cod=
e></h4>
  <p>You don=E2=80=99t just use <code>use</code> to shorten identifiers. Yo=
u can also use it inside of your crate to re-export a function inside anoth=
er module. This allows you to present an external interface that may not di=
rectly map to your internal code organization.</p>
  <p>Let=E2=80=99s look at an example. Modify your <code>src/main.rs</code>=
 to read like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">extern</span> crate phrases;
 =20
  <span class=3D"kw">use</span> phrases::english::{greetings,farewells};
  <span class=3D"kw">use</span> phrases::japanese;
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello in Engli=
sh: {}"</span>, greetings::hello());
      <span class=3D"ot">println!</span>(<span class=3D"st">"Goodbye in Eng=
lish: {}"</span>, farewells::goodbye());
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"Hello in Japan=
ese: {}"</span>, japanese::hello());
      <span class=3D"ot">println!</span>(<span class=3D"st">"Goodbye in Jap=
anese: {}"</span>, japanese::goodbye());
  }</code></pre></div>
  <p>Then, modify your <code>src/lib.rs</code> to make the <code>japanese</=
code> mod public:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">mod</span>=
 english;
  <span class=3D"kw">pub</span> <span class=3D"kw">mod</span> japanese;</co=
de></pre></div>
  <p>Next, make the two functions public, first in <code>src/japanese/greet=
ings.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">fn</span> =
hello() -&gt; String {
      <span class=3D"st">"=E3=81=93=E3=82=93=E3=81=AB=E3=81=A1=E3=81=AF"</s=
pan>.to_string()
  }</code></pre></div>
  <p>And then in <code>src/japanese/farewells.rs</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">fn</span> =
goodbye() -&gt; String {
      <span class=3D"st">"=E3=81=95=E3=82=88=E3=81=86=E3=81=AA=E3=82=89"</s=
pan>.to_string()
  }</code></pre></div>
  <p>Finally, modify your <code>src/japanese/mod.rs</code> to read like thi=
s:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">use</span>=
 <span class=3D"kw">self</span>::greetings::hello;
  <span class=3D"kw">pub</span> <span class=3D"kw">use</span> <span class=
=3D"kw">self</span>::farewells::goodbye;
 =20
  <span class=3D"kw">mod</span> greetings;
  <span class=3D"kw">mod</span> farewells;</code></pre></div>
  <p>The <code>pub use</code> declaration brings the function into scope at=
 this part of our module hierarchy. Because we=E2=80=99ve <code>pub use</co=
de>d this inside of our <code>japanese</code> module, we now have a <code>p=
hrases::japanese::hello()</code> function and a <code>phrases::japanese::go=
odbye()</code> function, even though the code for them lives in <code>phras=
es::japanese::greetings::hello()</code> and <code>phrases::japanese::farewe=
lls::goodbye()</code>. Our internal organization doesn=E2=80=99t define our=
 external interface.</p>
  <p>Here we have a <code>pub use</code> for each function we want to bring=
 into the <code>japanese</code> scope. We could alternatively use the wildc=
ard syntax to include everything from <code>greetings</code> into the curre=
nt scope: <code>pub use self::greetings::*</code>.</p>
  <p>What about the <code>self</code>? Well, by default, <code>use</code> d=
eclarations are absolute paths, starting from your crate root. <code>self</=
code> makes that path relative to your current place in the hierarchy inste=
ad. There=E2=80=99s one more special form of <code>use</code>: you can <cod=
e>use super::</code> to reach one level up the tree from your current locat=
ion. Some people like to think of <code>self</code> as <code>.</code> and <=
code>super</code> as <code>..</code>, from many shells=E2=80=99 display for=
 the current directory and the parent directory.</p>
  <p>Outside of <code>use</code>, paths are relative: <code>foo::bar()</cod=
e> refers to a function inside of <code>foo</code> relative to where we are=
. If that=E2=80=99s prefixed with <code>::</code>, as in <code>::foo::bar()=
</code>, it refers to a different <code>foo</code>, an absolute path from y=
our crate root.</p>
  <p>Also, note that we <code>pub use</code>d before we declared our <code>=
mod</code>s. Rust requires that <code>use</code> declarations go first.</p>
  <p>This will build and run:</p>
  <pre><code>$ cargo run
     Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
       Running `target/debug/phrases`
  Hello in English: Hello!
  Goodbye in English: Goodbye.
  Hello in Japanese: =E3=81=93=E3=82=93=E3=81=AB=E3=81=A1=E3=81=AF
  Goodbye in Japanese: =E3=81=95=E3=82=88=E3=81=86=E3=81=AA=E3=82=89</code>=
</pre>
  <h2 id=3D"sec--const-and-static"><code>const</code> and <code>static</cod=
e></h2>
  <p>Rust has a way of defining constants with the <code>const</code> keywo=
rd:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">const N: <span class=3D"kw">i32</span> =3D <span class=3D"d=
v">5</span>;</code></pre></div>
  <p>Unlike <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-=
13.html#sec--variable-bindings"><code>let</code></a> bindings, you must ann=
otate the type of a <code>const</code>.</p>
  <p>Constants live for the entire lifetime of a program. More specifically=
, constants in Rust have no fixed address in memory. This is because they=
=E2=80=99re effectively inlined to each place that they=E2=80=99re used. Re=
ferences to the same constant are not necessarily guaranteed to refer to th=
e same memory address for this reason.</p>
  <h3 id=3D"static-1"><code>static</code></h3>
  <p>Rust provides a =E2=80=98global variable=E2=80=99 sort of facility in =
static items. They=E2=80=99re similar to constants, but static items aren=
=E2=80=99t inlined upon use. This means that there is only one instance for=
 each value, and it=E2=80=99s at a fixed location in memory.</p>
  <p>Here=E2=80=99s an example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">static</span> N: <span class=3D"kw">i32<=
/span> =3D <span class=3D"dv">5</span>;</code></pre></div>
  <p>Unlike <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-=
13.html#sec--variable-bindings"><code>let</code></a> bindings, you must ann=
otate the type of a <code>static</code>.</p>
  <p>Statics live for the entire lifetime of a program, and therefore any r=
eference stored in a constant has a <a href=3D"https://killercup.github.io/=
trpl-ebook/trpl-2015-05-13.html#sec--lifetimes"><code>=E2=80=99static</code=
> lifetime</a>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">static</span> NAME: &amp;<span class=3D"=
ot">'static</span> <span class=3D"kw">str</span> =3D <span class=3D"st">"St=
eve"</span>;</code></pre></div>
  <h4 id=3D"mutability">Mutability</h4>
  <p>You can introduce mutability with the <code>mut</code> keyword:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">static</span> <span class=3D"kw">mut</sp=
an> N: <span class=3D"kw">i32</span> =3D <span class=3D"dv">5</span>;</code=
></pre></div>
  <p>Because this is mutable, one thread could be updating <code>N</code> w=
hile another is reading it, causing memory unsafety. As such both accessing=
 and mutating a <code>static mut</code> is <a href=3D"https://killercup.git=
hub.io/trpl-ebook/trpl-2015-05-13.html#sec--unsafe"><code>unsafe</code></a>=
, and so must be done in an <code>unsafe</code> block:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">
  <span class=3D"kw">unsafe</span> {
      N +=3D <span class=3D"dv">1</span>;
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"N: {}"</span>,=
 N);
  }</code></pre></div>
  <p>Furthermore, any type stored in a <code>static</code> must be <code>Sy=
nc</code>.</p>
  <h3 id=3D"initializing">Initializing</h3>
  <p>Both <code>const</code> and <code>static</code> have requirements for =
giving them a value. They may only be given a value that=E2=80=99s a consta=
nt expression. In other words, you cannot use the result of a function call=
 or anything similarly complex or at runtime.</p>
  <h3 id=3D"which-construct-should-i-use">Which construct should I use?</h3=
>
  <p>Almost always, if you can choose between the two, choose <code>const</=
code>. It=E2=80=99s pretty rare that you actually want a memory location as=
sociated with your constant, and using a const allows for optimizations lik=
e constant propagation not only in your crate but downstream crates.</p>
  <p>A const can be thought of as a <code>#define</code> in C: it has metad=
ata overhead but it has no runtime overhead. =E2=80=9CShould I use a #defin=
e or a static in C,=E2=80=9D is largely the same question as whether you sh=
ould use a const or a static in Rust.</p>
  <h2 id=3D"sec--attributes">Attributes</h2>
  <p>Declarations can be annotated with =E2=80=98attributes=E2=80=99 in Rus=
t. They look like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>test<span class=3D"ot">]</span>=
</code></pre></div>
  <p>or like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![test]</code></pre></div>
  <p>The difference between the two is the <code>!</code>, which changes wh=
at the attribute applies to:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>foo<span class=3D"ot">]</span>
  <span class=3D"kw">struct</span> Foo;
 =20
  <span class=3D"kw">mod</span> bar {
      #![bar]
  }</code></pre></div>
  <p>The <code>#[foo]</code> attribute applies to the next item, which is t=
he <code>struct</code> declaration. The <code>#![bar]</code> attribute appl=
ies to the item enclosing it, which is the <code>mod</code> declaration. Ot=
herwise, they=E2=80=99re the same. Both change the meaning of the item they=
=E2=80=99re attached to somehow.</p>
  <p>For example, consider a function like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
  <span class=3D"kw">fn</span> check() {
      <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">2</span>, <sp=
an class=3D"dv">1</span> + <span class=3D"dv">1</span>);
  }</code></pre></div>
  <p>It is marked with <code>#[test]</code>. This means it=E2=80=99s specia=
l: when you run <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015=
-05-13.html#sec--testing">tests</a>, this function will execute. When you c=
ompile as usual, it won=E2=80=99t even be included. This function is now a =
test function.</p>
  <p>Attributes may also have additional data:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>inline<span class=3D"ot">(</spa=
n>always<span class=3D"ot">)]</span>
  <span class=3D"kw">fn</span> super_fast_fn() {</code></pre></div>
  <p>Or even keys and values:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>t=
arget_os <span class=3D"ot">=3D</span> <span class=3D"st">"macos"</span><sp=
an class=3D"ot">)]</span>
  <span class=3D"kw">mod</span> macos_only {</code></pre></div>
  <p>Rust attributes are used for a number of different things. There is a =
full list of attributes <a href=3D"http://doc.rust-lang.org/reference.html#=
attributes">in the reference</a>. Currently, you are not allowed to create =
your own attributes, the Rust compiler defines them.</p>
  <h2 id=3D"sec--type-aliases"><code>type</code> aliases</h2>
  <p>The <code>type</code> keyword lets you declare an alias of another typ=
e:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">type</span> Name =3D String;</code></pre=
></div>
  <p>You can then use this type as if it were a real type:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">type</span> Name =3D String;
 =20
  <span class=3D"kw">let</span> x: Name =3D <span class=3D"st">"Hello"</spa=
n>.to_string();</code></pre></div>
  <p>Note, however, that this is an <em>alias</em>, not a new type entirely=
. In other words, because Rust is strongly typed, you=E2=80=99d expect a co=
mparison between two different types to fail:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: <span class=3D"kw">i32</sp=
an> =3D <span class=3D"dv">5</span>;
  <span class=3D"kw">let</span> y: <span class=3D"kw">i64</span> =3D <span =
class=3D"dv">5</span>;
 =20
  <span class=3D"kw">if</span> x =3D=3D y {
     <span class=3D"co">// ...</span>
  }</code></pre></div>
  <p>this gives</p>
  <pre><code>error: mismatched types:
   expected `i32`,
      found `i64`
  (expected i32,
      found i64) [E0308]
       if x =3D=3D y {
               ^</code></pre>
  <p>But, if we had an alias:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">type</span> Num =3D <span class=3D"kw">i=
32</span>;
 =20
  <span class=3D"kw">let</span> x: <span class=3D"kw">i32</span> =3D <span =
class=3D"dv">5</span>;
  <span class=3D"kw">let</span> y: <span class=3D"kw">Num</span> =3D <span =
class=3D"dv">5</span>;
 =20
  <span class=3D"kw">if</span> x =3D=3D y {
     <span class=3D"co">// ...</span>
  }</code></pre></div>
  <p>This compiles without error. Values of a <code>Num</code> type are the=
 same as a value of type <code>i32</code>, in every way.</p>
  <p>You can also use type aliases with generics:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::result;
 =20
  <span class=3D"kw">enum</span> ConcreteError {
      Foo,
      Bar,
  }
 =20
  <span class=3D"kw">type</span> Result&lt;T&gt; =3D result::<span class=3D=
"kw">Result</span>&lt;T, ConcreteError&gt;;</code></pre></div>
  <p>This creates a specialized version of the <code>Result</code> type, wh=
ich always has a <code>ConcreteError</code> for the <code>E</code> part of =
<code>Result&lt;T, E&gt;</code>. This is commonly used in the standard libr=
ary to create custom errors for each subsection. For example, <a href=3D"ht=
tp://doc.rust-lang.org/std/io/type.Result.html">io::Result</a>.</p>
  <h2 id=3D"sec--casting-between-types">Casting between types</h2>
  <p>Rust, with its focus on safety, provides two different ways of casting=
 different types between each other. The first, <code>as</code>, is for saf=
e casts. In contrast, <code>transmute</code> allows for arbitrary casting, =
and is one of the most dangerous features of Rust!</p>
  <h3 id=3D"as"><code>as</code></h3>
  <p>The <code>as</code> keyword does basic casting:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: <span class=3D"kw">i32</sp=
an> =3D <span class=3D"dv">5</span>;
 =20
  <span class=3D"kw">let</span> y =3D x <span class=3D"kw">as</span> <span =
class=3D"kw">i64</span>;</code></pre></div>
  <p>It only allows certain kinds of casting, however:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> a =3D [<span class=3D"dv">0u8=
</span>, <span class=3D"dv">0u8</span>, <span class=3D"dv">0u8</span>, <spa=
n class=3D"dv">0u8</span>];
 =20
  <span class=3D"kw">let</span> b =3D a <span class=3D"kw">as</span> <span =
class=3D"kw">u32</span>; <span class=3D"co">// four eights makes 32</span><=
/code></pre></div>
  <p>This errors with:</p>
  <pre><code>error: non-scalar cast: `[u8; 4]` as `u32`
  let b =3D a as u32; // four eights makes 32
          ^~~~~~~~</code></pre>
  <p>It=E2=80=99s a =E2=80=98non-scalar cast=E2=80=99 because we have multi=
ple values here: the four elements of the array. These kinds of casts are v=
ery dangerous, because they make assumptions about the way that multiple un=
derlying structures are implemented. For this, we need something more dange=
rous.</p>
  <h3 id=3D"transmute"><code>transmute</code></h3>
  <p>The <code>transmute</code> function is provided by a <a href=3D"https:=
//killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--intrinsics">comp=
iler intrinsic</a>, and what it does is very simple, but very scary. It tel=
ls Rust to treat a value of one type as though it were another type. It doe=
s this regardless of the typechecking system, and just completely trusts yo=
u.</p>
  <p>In our previous example, we know that an array of four <code>u8</code>=
s represents a <code>u32</code> properly, and so we want to do the cast. Us=
ing <code>transmute</code> instead of <code>as</code>, Rust lets us:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::mem;
 =20
  <span class=3D"kw">unsafe</span> {
      <span class=3D"kw">let</span> a =3D [<span class=3D"dv">0u8</span>, <=
span class=3D"dv">0u8</span>, <span class=3D"dv">0u8</span>, <span class=3D=
"dv">0u8</span>];
 =20
      <span class=3D"kw">let</span> b =3D mem::transmute::&lt;[<span class=
=3D"kw">u8</span>; <span class=3D"dv">4</span>], <span class=3D"kw">u32</sp=
an>&gt;(a);
  }</code></pre></div>
  <p>We have to wrap the operation in an <code>unsafe</code> block for this=
 to compile successfully. Technically, only the <code>mem::transmute</code>=
 call itself needs to be in the block, but it=E2=80=99s nice in this case t=
o enclose everything related, so you know where to look. In this case, the =
details about <code>a</code> are also important, and so they=E2=80=99re in =
the block. You=E2=80=99ll see code in either style, sometimes the context i=
s too far away, and wrapping all of the code in <code>unsafe</code> isn=E2=
=80=99t a great idea.</p>
  <p>While <code>transmute</code> does very little checking, it will at lea=
st make sure that the types are the same size. This errors:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::mem;
 =20
  <span class=3D"kw">unsafe</span> {
      <span class=3D"kw">let</span> a =3D [<span class=3D"dv">0u8</span>, <=
span class=3D"dv">0u8</span>, <span class=3D"dv">0u8</span>, <span class=3D=
"dv">0u8</span>];
 =20
      <span class=3D"kw">let</span> b =3D mem::transmute::&lt;[<span class=
=3D"kw">u8</span>; <span class=3D"dv">4</span>], <span class=3D"kw">u64</sp=
an>&gt;(a);
  }</code></pre></div>
  <p>with:</p>
  <pre><code>error: transmute called on types with different sizes: [u8; 4]=
 (32 bits) to u64
  (64 bits)</code></pre>
  <p>Other than that, you=E2=80=99re on your own!</p>
  <h2 id=3D"sec--associated-types">Associated Types</h2>
  <p>Associated types are a powerful part of Rust=E2=80=99s type system. Th=
ey=E2=80=99re related to the idea of a =E2=80=98type family=E2=80=99, in ot=
her words, grouping multiple types together. That description is a bit abst=
ract, so let=E2=80=99s dive right into an example. If you want to write a <=
code>Graph</code> trait, you have two types to be generic over: the node ty=
pe and the edge type. So you might write a trait, <code>Graph&lt;N, E&gt;</=
code>, that looks like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> Graph&lt;N, E&gt; {
      <span class=3D"kw">fn</span> has_edge(&amp;<span class=3D"kw">self</s=
pan>, &amp;N, &amp;N) -&gt; <span class=3D"kw">bool</span>;
      <span class=3D"kw">fn</span> edges(&amp;<span class=3D"kw">self</span=
>, &amp;N) -&gt; Vec&lt;E&gt;;
      <span class=3D"co">// etc</span>
  }</code></pre></div>
  <p>While this sort of works, it ends up being awkward. For example, any f=
unction that wants to take a <code>Graph</code> as a parameter now <em>also=
</em> needs to be generic over the <code>N</code>ode and <code>E</code>dge =
types too:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> distance&lt;N, E, G: Graph&lt;=
N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class=
=3D"kw">u32</span> { ... }</code></pre></div>
  <p>Our distance calculation works regardless of our <code>Edge</code> typ=
e, so the <code>E</code> stuff in this signature is just a distraction.</p>
  <p>What we really want to say is that a certain <code>E</code>dge and <co=
de>N</code>ode type come together to form each kind of <code>Graph</code>. =
We can do that with associated types:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> Graph {
      <span class=3D"kw">type</span> N;
      type E;
 =20
      fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
      fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;<span class=3D"kw">Sel=
f</span>::E&gt;;
      <span class=3D"co">// etc</span>
  }</code></pre></div>
  <p>Now, our clients can be abstract over a given <code>Graph</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> distance&lt;G: Graph&gt;(graph=
: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; <span class=3D"kw">uint</=
span> { ... }</code></pre></div>
  <p>No need to deal with the <code>E</code>dge type here!</p>
  <p>Let=E2=80=99s go over all this in more detail.</p>
  <h4 id=3D"defining-associated-types">Defining associated types</h4>
  <p>Let=E2=80=99s build that <code>Graph</code> trait. Here=E2=80=99s the =
definition:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">trait</span> Graph {
      <span class=3D"kw">type</span> N;
      type E;
 =20
      fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
      fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;<span class=3D"kw">Sel=
f</span>::E&gt;;
  }</code></pre></div>
  <p>Simple enough. Associated types use the <code>type</code> keyword, and=
 go inside the body of the trait, with the functions.</p>
  <p>These <code>type</code> declarations can have all the same thing as fu=
nctions do. For example, if we wanted our <code>N</code> type to implement =
<code>Display</code>, so we can print the nodes out, we could do this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::fmt;
 =20
  <span class=3D"kw">trait</span> Graph {
      <span class=3D"kw">type</span> N: fmt::Display;
      type E;
 =20
      fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
      fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;<span class=3D"kw">Sel=
f</span>::E&gt;;
  }</code></pre></div>
  <h4 id=3D"implementing-associated-types">Implementing associated types</h=
4>
  <p>Just like any trait, traits that use associated types use the <code>im=
pl</code> keyword to provide implementations. Here=E2=80=99s a simple imple=
mentation of Graph:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Node;
 =20
  <span class=3D"kw">struct</span> Edge;
 =20
  <span class=3D"kw">struct</span> MyGraph;
 =20
  <span class=3D"kw">impl</span> Graph <span class=3D"kw">for</span> MyGrap=
h {
      <span class=3D"kw">type</span> N =3D Node;
      <span class=3D"kw">type</span> E =3D Edge;
 =20
      <span class=3D"kw">fn</span> has_edge(&amp;<span class=3D"kw">self</s=
pan>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=3D"kw">bool</span> {
          <span class=3D"kw">true</span>
      }
 =20
      <span class=3D"kw">fn</span> edges(&amp;<span class=3D"kw">self</span=
>, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
          Vec::new()
      }
  }</code></pre></div>
  <p>This silly implementation always returns <code>true</code> and an empt=
y <code>Vec&lt;Edge&gt;</code>, but it gives you an idea of how to implemen=
t this kind of thing. We first need three <code>struct</code>s, one for the=
 graph, one for the node, and one for the edge. If it made more sense to us=
e a different type, that would work as well, we=E2=80=99re just going to us=
e <code>struct</code>s for all three here.</p>
  <p>Next is the <code>impl</code> line, which is just like implementing an=
y other trait.</p>
  <p>From here, we use <code>=3D</code> to define our associated types. The=
 name the trait uses goes on the left of the <code>=3D</code>, and the conc=
rete type we=E2=80=99re <code>impl</code>ementing this for goes on the righ=
t. Finally, we use the concrete types in our function declarations.</p>
  <h4 id=3D"trait-objects-with-associated-types">Trait objects with associa=
ted types</h4>
  <p>There=E2=80=99s one more bit of syntax we should talk about: trait obj=
ects. If you try to create a trait object from an associated type, like thi=
s:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> graph =3D MyGraph;
  <span class=3D"kw">let</span> obj =3D Box::new(graph) <span class=3D"kw">=
as</span> Box&lt;Graph&gt;;</code></pre></div>
  <p>You=E2=80=99ll get two errors:</p>
  <pre><code>error: the value of the associated type `E` (from the trait `m=
ain::Graph`) must
  be specified [E0191]
  let obj =3D Box::new(graph) as Box&lt;Graph&gt;;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  24:44 error: the value of the associated type `N` (from the trait
  `main::Graph`) must be specified [E0191]
  let obj =3D Box::new(graph) as Box&lt;Graph&gt;;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>We can=E2=80=99t create a trait object like this, because we don=E2=80=
=99t know the associated types. Instead, we can write this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> graph =3D MyGraph;
  <span class=3D"kw">let</span> obj =3D Box::new(graph) <span class=3D"kw">=
as</span> Box&lt;Graph&lt;N=3DNode, E=3DEdge&gt;&gt;;</code></pre></div>
  <p>The <code>N=3DNode</code> syntax allows us to provide a concrete type,=
 <code>Node</code>, for the <code>N</code> type parameter. Same with <code>=
E=3DEdge</code>. If we didn=E2=80=99t provide this constraint, we couldn=E2=
=80=99t be sure which <code>impl</code> to match this trait object to.</p>
  <h2 id=3D"sec--unsized-types">Unsized Types</h2>
  <p>Most types have a particular size, in bytes, that is knowable at compi=
le time. For example, an <code>i32</code> is thirty-two bits big, or four b=
ytes. However, there are some types which are useful to express, but do not=
 have a defined size. These are called =E2=80=98unsized=E2=80=99 or =E2=80=
=98dynamically sized=E2=80=99 types. One example is <code>[T]</code>. This =
type represents a certain number of <code>T</code> in sequence. But we don=
=E2=80=99t know how many there are, so the size is not known.</p>
  <p>Rust understands a few of these types, but they have some restrictions=
. There are three:</p>
  <ol type=3D"1">
  <li>We can only manipulate an instance of an unsized type via a pointer. =
An <code>&amp;[T]</code> works just fine, but a <code>[T]</code> does not.<=
/li>
  <li>Variables and arguments cannot have dynamically sized types.</li>
  <li>Only the last field in a <code>struct</code> may have a dynamically s=
ized type; the other fields must not. Enum variants must not have dynamical=
ly sized types as data.</li>
  </ol>
  <p>So why bother? Well, because <code>[T]</code> can only be used behind =
a pointer, if we didn=E2=80=99t have language support for unsized types, it=
 would be impossible to write this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">impl</span> Foo <span class=3D"kw">for</=
span> <span class=3D"kw">str</span> {</code></pre></div>
  <p>or</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">impl</span>&lt;T&gt; Foo <span class=3D"=
kw">for</span> [T] {</code></pre></div>
  <p>Instead, you would have to write:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">impl</span> Foo <span class=3D"kw">for</=
span> &amp;<span class=3D"kw">str</span> {</code></pre></div>
  <p>Meaning, this implementation would only work for <a href=3D"https://ki=
llercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--references-and-borro=
wing">references</a>, and not other types of pointers. With the <code>impl =
for str</code>, all pointers, including (at some point, there are some bugs=
 to fix first) user-defined custom smart pointers, can use this <code>impl<=
/code>.</p>
  <h3 id=3D"sized">?Sized</h3>
  <p>If you want to write a function that accepts a dynamically sized type,=
 you can use the special bound, <code>?Sized</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Foo&lt;T: ?<span class=3D"=
kw">Sized</span>&gt; {
      f: T,
  }</code></pre></div>
  <p>This <code>?</code>, read as =E2=80=9CT may be <code>Sized</code>=E2=
=80=9D, means that this bound is special: it lets us match more kinds, not =
less. It=E2=80=99s almost like every <code>T</code> implicitly has <code>T:=
 Sized</code>, and the <code>?</code> undoes this default.</p>
  <h2 id=3D"sec--operators-and-overloading">Operators and Overloading</h2>
  <p>Rust allows for a limited form of operator overloading. There are cert=
ain operators that are able to be overloaded. To support a particular opera=
tor between types, there=E2=80=99s a specific trait that you can implement,=
 which then overloads the operator.</p>
  <p>For example, the <code>+</code> operator can be overloaded with the <c=
ode>Add</code> trait:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::ops::<span class=3D"kw">=
Add</span>;
 =20
  <span class=3D"ot">#[</span>derive<span class=3D"ot">(</span>Debug<span c=
lass=3D"ot">)]</span>
  <span class=3D"kw">struct</span> Point {
      x: <span class=3D"kw">i32</span>,
      y: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">impl</span> <span class=3D"kw">Add</span> <span class=
=3D"kw">for</span> Point {
      <span class=3D"kw">type</span> Output =3D Point;
 =20
      <span class=3D"kw">fn</span> add(<span class=3D"kw">self</span>, othe=
r: Point) -&gt; Point {
          Point { x: <span class=3D"kw">self</span>.x + other.x, y: <span c=
lass=3D"kw">self</span>.y + other.y }
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> p1 =3D Point { x: <span class=3D"dv">1<=
/span>, y: <span class=3D"dv">0</span> };
      <span class=3D"kw">let</span> p2 =3D Point { x: <span class=3D"dv">2<=
/span>, y: <span class=3D"dv">3</span> };
 =20
      <span class=3D"kw">let</span> p3 =3D p1 + p2;
 =20
      <span class=3D"ot">println!</span>(<span class=3D"st">"{:?}"</span>, =
p3);
  }</code></pre></div>
  <p>In <code>main</code>, we can use <code>+</code> on our two <code>Point=
</code>s, since we=E2=80=99ve implemented <code>Add&lt;Output=3DPoint&gt;</=
code> for <code>Point</code>.</p>
  <p>There are a number of operators that can be overloaded this way, and a=
ll of their associated traits live in the <a href=3D"http://doc.rust-lang.o=
rg/std/ops/index.html"><code>std::ops</code></a> module. Check out its docu=
mentation for the full list.</p>
  <p>Implementing these traits follows a pattern. Let=E2=80=99s look at <a =
href=3D"http://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></=
a> in more detail:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">trait</spa=
n> <span class=3D"kw">Add</span>&lt;RHS =3D <span class=3D"kw">Self</span>&=
gt; {
      <span class=3D"kw">type</span> Output;
 =20
      fn add(self, rhs: RHS) -&gt; Self::Output;
  }</code></pre></div>
  <p>There=E2=80=99s three types in total involved here: the type you <code=
>impl Add</code> for, <code>RHS</code>, which defaults to <code>Self</code>=
, and <code>Output</code>. For an expression <code>let z =3D x + y</code>, =
<code>x</code> is the <code>Self</code> type, <code>y</code> is the RHS, an=
d <code>z</code> is the <code>Self::Output</code> type.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">impl</span> <span class=3D"kw">Add</span=
>&lt;<span class=3D"kw">i32</span>&gt; <span class=3D"kw">for</span> Point =
{
      <span class=3D"kw">type</span> Output =3D <span class=3D"kw">f64</spa=
n>;
 =20
      <span class=3D"kw">fn</span> add(<span class=3D"kw">self</span>, rhs:=
 <span class=3D"kw">i32</span>) -&gt; <span class=3D"kw">f64</span> {
          <span class=3D"co">// add an i32 to a Point and get an f64</span>
      }
  }</code></pre></div>
  <p>will let you do this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> p: Point =3D <span class=3D"c=
o">// ...</span>
  <span class=3D"kw">let</span> x: <span class=3D"kw">f64</span> =3D p + <s=
pan class=3D"dv">2i32</span>;</code></pre></div>
  <h2 id=3D"sec--deref-coercions">Deref coercions</h2>
  <p>The standard library provides a special trait, <a href=3D"http://doc.r=
ust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>. It=E2=80=99s=
 normally used to overload <code>*</code>, the dereference operator:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::ops::Deref;
 =20
  <span class=3D"kw">struct</span> DerefExample&lt;T&gt; {
      value: T,
  }
 =20
  <span class=3D"kw">impl</span>&lt;T&gt; Deref <span class=3D"kw">for</spa=
n> DerefExample&lt;T&gt; {
      <span class=3D"kw">type</span> Target =3D T;
 =20
      <span class=3D"kw">fn</span> deref(&amp;<span class=3D"kw">self</span=
>) -&gt; &amp;T {
          &amp;<span class=3D"kw">self</span>.value
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D DerefExample { value: <span class=
=3D"ch">'a'</span> };
      <span class=3D"ot">assert_eq!</span>(<span class=3D"ch">'a'</span>, *=
x);
  }</code></pre></div>
  <p>This is useful for writing custom pointer types. However, there=E2=80=
=99s a language feature related to <code>Deref</code>: =E2=80=98deref coerc=
ions=E2=80=99. Here=E2=80=99s the rule: If you have a type <code>U</code>, =
and it implements <code>Deref&lt;Target=3DT&gt;</code>, values of <code>&am=
p;U</code> will automatically coerce to a <code>&amp;T</code>. Here=E2=80=
=99s an example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(s: &amp;<span class=3D"kw"=
>str</span>) {
      <span class=3D"co">// borrow a string for a second</span>
  }
 =20
  <span class=3D"co">// String implements Deref&lt;Target=3Dstr&gt;</span>
  <span class=3D"kw">let</span> owned =3D <span class=3D"st">"Hello"</span>=
.to_string();
 =20
  <span class=3D"co">// therefore, this works:</span>
  foo(&amp;owned);</code></pre></div>
  <p>Using an ampersand in front of a value takes a reference to it. So <co=
de>owned</code> is a <code>String</code>, <code>&amp;owned</code> is an <co=
de>&amp;String</code>, and since <code>impl Deref&lt;Target=3Dstr&gt; for S=
tring</code>, <code>&amp;String</code> will deref to <code>&amp;str</code>,=
 which <code>foo()</code> takes.</p>
  <p>That=E2=80=99s it. This rule is one of the only places in which Rust d=
oes an automatic conversion for you, but it adds a lot of flexibility. For =
example, the <code>Rc&lt;T&gt;</code> type implements <code>Deref&lt;Target=
=3DT&gt;</code>, so this works:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::rc::Rc;
 =20
  <span class=3D"kw">fn</span> foo(s: &amp;<span class=3D"kw">str</span>) {
      <span class=3D"co">// borrow a string for a second</span>
  }
 =20
  <span class=3D"co">// String implements Deref&lt;Target=3Dstr&gt;</span>
  <span class=3D"kw">let</span> owned =3D <span class=3D"st">"Hello"</span>=
.to_string();
  <span class=3D"kw">let</span> counted =3D Rc::new(owned);
 =20
  <span class=3D"co">// therefore, this works:</span>
  foo(&amp;counted);</code></pre></div>
  <p>All we=E2=80=99ve done is wrap our <code>String</code> in an <code>Rc&=
lt;T&gt;</code>. But we can now pass the <code>Rc&lt;String&gt;</code> arou=
nd anywhere we=E2=80=99d have a <code>String</code>. The signature of <code=
>foo</code> didn=E2=80=99t change, but works just as well with either type.=
 This example has two conversions: <code>Rc&lt;String&gt;</code> to <code>S=
tring</code> and then <code>String</code> to <code>&amp;str</code>. Rust wi=
ll do this as many times as possible until the types match.</p>
  <p>Another very common implementation provided by the standard library is=
:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">fn</span> foo(s: &amp;[<span class=3D"kw=
">i32</span>]) {
      <span class=3D"co">// borrow a slice for a second</span>
  }
 =20
  <span class=3D"co">// Vec&lt;T&gt; implements Deref&lt;Target=3D[T]&gt;</=
span>
  <span class=3D"kw">let</span> owned =3D <span class=3D"ot">vec!</span>[<s=
pan class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"dv">=
3</span>];
 =20
  foo(&amp;owned);</code></pre></div>
  <p>Vectors can <code>Deref</code> to a slice.</p>
  <h4 id=3D"deref-and-method-calls">Deref and method calls</h4>
  <p><code>Deref</code> will also kick in when calling a method. In other w=
ords, these are the same two things in Rust:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> Foo;
 =20
  <span class=3D"kw">impl</span> Foo {
      <span class=3D"kw">fn</span> foo(&amp;<span class=3D"kw">self</span>)=
 { <span class=3D"ot">println!</span>(<span class=3D"st">"Foo"</span>); }
  }
 =20
  <span class=3D"kw">let</span> f =3D Foo;
 =20
  f.foo();</code></pre></div>
  <p>Even though <code>f</code> isn=E2=80=99t a reference, and <code>foo</c=
ode> takes <code>&amp;self</code>, this works. That=E2=80=99s because these=
 things are the same:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">f.foo();
  (&amp;f).foo();
  (&amp;&amp;f).foo();
  (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();</code></pre></div>
  <p>A value of type <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&am=
p;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code> can still have methods defined o=
n <code>Foo</code> called, because the compiler will insert as many * opera=
tions as necessary to get it right. And since it=E2=80=99s inserting <code>=
*</code>s, that uses <code>Deref</code>.</p>
  <h2 id=3D"sec--macros">Macros</h2>
  <p>By now you=E2=80=99ve learned about many of the tools Rust provides fo=
r abstracting and reusing code. These units of code reuse have a rich seman=
tic structure. For example, functions have a type signature, type parameter=
s have trait bounds, and overloaded functions must belong to a particular t=
rait.</p>
  <p>This structure means that Rust=E2=80=99s core abstractions have powerf=
ul compile-time correctness checking. But this comes at the price of reduce=
d flexibility. If you visually identify a pattern of repeated code, you may=
 find it=E2=80=99s difficult or cumbersome to express that pattern as a gen=
eric function, a trait, or anything else within Rust=E2=80=99s semantics.</=
p>
  <p>Macros allow us to abstract at a syntactic level. A macro invocation i=
s shorthand for an =E2=80=9Cexpanded=E2=80=9D syntactic form. This expansio=
n happens early in compilation, before any static checking. As a result, ma=
cros can capture many patterns of code reuse that Rust=E2=80=99s core abstr=
actions cannot.</p>
  <p>The drawback is that macro-based code can be harder to understand, bec=
ause fewer of the built-in rules apply. Like an ordinary function, a well-b=
ehaved macro can be used without understanding its implementation. However,=
 it can be difficult to design a well-behaved macro! Additionally, compiler=
 errors in macro code are harder to interpret, because they describe proble=
ms in the expanded code, not the source-level form that developers use.</p>
  <p>These drawbacks make macros something of a =E2=80=9Cfeature of last re=
sort=E2=80=9D. That=E2=80=99s not to say that macros are bad; they are part=
 of Rust because sometimes they=E2=80=99re needed for truly concise, well-a=
bstracted code. Just keep this tradeoff in mind.</p>
  <h3 id=3D"defining-a-macro">Defining a macro</h3>
  <p>You may have seen the <code>vec!</code> macro, used to initialize a <a=
 href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--v=
ectors">vector</a> with any number of elements.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: Vec&lt;<span class=3D"kw">=
u32</span>&gt; =3D <span class=3D"ot">vec!</span>[<span class=3D"dv">1</spa=
n>, <span class=3D"dv">2</span>, <span class=3D"dv">3</span>];</code></pre>=
</div>
  <p>This can=E2=80=99t be an ordinary function, because it takes any numbe=
r of arguments. But we can imagine it as syntactic shorthand for</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: Vec&lt;<span class=3D"kw">=
u32</span>&gt; =3D {
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> temp_vec =
=3D Vec::new();
      temp_vec.push(<span class=3D"dv">1</span>);
      temp_vec.push(<span class=3D"dv">2</span>);
      temp_vec.push(<span class=3D"dv">3</span>);
      temp_vec
  };</code></pre></div>
  <p>We can implement this shorthand, using a macro: <a href=3D"https://kil=
lercup.github.io/trpl-ebook/trpl-2015-05-13.html#fn1" class=3D"footnoteRef"=
 id=3D"fnref1"><sup>1</sup></a></p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> vec {
      ( $( $x:expr ),* ) =3D&gt; {
          {
              <span class=3D"kw">let</span> <span class=3D"kw">mut</span> t=
emp_vec =3D Vec::new();
              $(
                  temp_vec.push($x);
              )*
              temp_vec
          }
      };
  }</code></pre></div>
  <p>Whoa, that=E2=80=99s a lot of new syntax! Let=E2=80=99s break it down.=
</p>
  <pre><code>macro_rules! vec { ... }</code></pre>
  <p>This says we=E2=80=99re defining a macro named <code>vec</code>, much =
as <code>fn vec</code> would define a function named <code>vec</code>. In p=
rose, we informally write a macro=E2=80=99s name with an exclamation point,=
 e.g. <code>vec!</code>. The exclamation point is part of the invocation sy=
ntax and serves to distinguish a macro from an ordinary function.</p>
  <h4 id=3D"matching">Matching</h4>
  <p>The macro is defined through a series of rules, which are pattern-matc=
hing cases. Above, we had</p>
  <pre><code>( $( $x:expr ),* ) =3D&gt; { ... };</code></pre>
  <p>This is like a <code>match</code> expression arm, but the matching hap=
pens on Rust syntax trees, at compile time. The semicolon is optional on th=
e last (here, only) case. The =E2=80=9Cpattern=E2=80=9D on the left-hand si=
de of <code>=3D&gt;</code> is known as a =E2=80=98matcher=E2=80=99. These h=
ave <a href=3D"http://doc.rust-lang.org/reference.html#macros">their own li=
ttle grammar</a> within the language.</p>
  <p>The matcher <code>$x:expr</code> will match any Rust expression, bindi=
ng that syntax tree to the =E2=80=98metavariable=E2=80=99 <code>$x</code>. =
The identifier <code>expr</code> is a =E2=80=98fragment specifier=E2=80=99;=
 the full possibilities are enumerated later in this chapter. Surrounding t=
he matcher with <code>$(...),*</code> will match zero or more expressions, =
separated by commas.</p>
  <p>Aside from the special matcher syntax, any Rust tokens that appear in =
a matcher must match exactly. For example,</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> foo {
      (x =3D&gt; $e:expr) =3D&gt; (<span class=3D"ot">println!</span>(<span=
 class=3D"st">"mode X: {}"</span>, $e));
      (y =3D&gt; $e:expr) =3D&gt; (<span class=3D"ot">println!</span>(<span=
 class=3D"st">"mode Y: {}"</span>, $e));
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">foo!</span>(y =3D&gt; <span class=3D"dv">3</span>)=
;
  }</code></pre></div>
  <p>will print</p>
  <pre><code>mode Y: 3</code></pre>
  <p>With</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">foo!</span>(z =3D&gt; <span class=3D"dv"=
>3</span>);</code></pre></div>
  <p>we get the compiler error</p>
  <pre><code>error: no rules expected the token `z`</code></pre>
  <h4 id=3D"expansion">Expansion</h4>
  <p>The right-hand side of a macro rule is ordinary Rust syntax, for the m=
ost part. But we can splice in bits of syntax captured by the matcher. From=
 the original example:</p>
  <pre><code>$(
      temp_vec.push($x);
  )*</code></pre>
  <p>Each matched expression <code>$x</code> will produce a single <code>pu=
sh</code> statement in the macro expansion. The repetition in the expansion=
 proceeds in =E2=80=9Clockstep=E2=80=9D with repetition in the matcher (mor=
e on this in a moment).</p>
  <p>Because <code>$x</code> was already declared as matching an expression=
, we don=E2=80=99t repeat <code>:expr</code> on the right-hand side. Also, =
we don=E2=80=99t include a separating comma as part of the repetition opera=
tor. Instead, we have a terminating semicolon within the repeated block.</p=
>
  <p>Another detail: the <code>vec!</code> macro has <em>two</em> pairs of =
braces on the right-hand side. They are often combined like so:</p>
  <pre><code>macro_rules! foo {
      () =3D&gt; {{
          ...
      }}
  }</code></pre>
  <p>The outer braces are part of the syntax of <code>macro_rules!</code>. =
In fact, you can use <code>()</code> or <code>[]</code> instead. They simpl=
y delimit the right-hand side as a whole.</p>
  <p>The inner braces are part of the expanded syntax. Remember, the <code>=
vec!</code> macro is used in an expression context. To write an expression =
with multiple statements, including <code>let</code>-bindings, we use a blo=
ck. If your macro expands to a single expression, you don=E2=80=99t need th=
is extra layer of braces.</p>
  <p>Note that we never <em>declared</em> that the macro produces an expres=
sion. In fact, this is not determined until we use the macro as an expressi=
on. With care, you can write a macro whose expansion works in several conte=
xts. For example, shorthand for a data type could be valid as either an exp=
ression or a pattern.</p>
  <h4 id=3D"repetition">Repetition</h4>
  <p>The repetition operator follows two principal rules:</p>
  <ol type=3D"1">
  <li><code>$(...)*</code> walks through one =E2=80=9Clayer=E2=80=9D of rep=
etitions, for all of the <code>$name</code>s it contains, in lockstep, and<=
/li>
  <li>each <code>$name</code> must be under at least as many <code>$(...)*<=
/code>s as it was matched against. If it is under more, it=E2=80=99ll be du=
plicated, as appropriate.</li>
  </ol>
  <p>This baroque macro illustrates the duplication of variables from outer=
 repetition levels.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> o_O {
      (
          $(
              $x:expr; [ $( $y:expr ),* ]
          );*
      ) =3D&gt; {
          &amp;[ $($( $x + $y ),*),* ]
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> a: &amp;[<span class=3D"kw">i32</span>]
          =3D <span class=3D"ot">o_O!</span>(<span class=3D"dv">10</span>; =
[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span class=3D"d=
v">3</span>];
                 <span class=3D"dv">20</span>; [<span class=3D"dv">4</span>=
, <span class=3D"dv">5</span>, <span class=3D"dv">6</span>]);
 =20
      <span class=3D"ot">assert_eq!</span>(a, [<span class=3D"dv">11</span>=
, <span class=3D"dv">12</span>, <span class=3D"dv">13</span>, <span class=
=3D"dv">24</span>, <span class=3D"dv">25</span>, <span class=3D"dv">26</spa=
n>]);
  }</code></pre></div>
  <p>That=E2=80=99s most of the matcher syntax. These examples use <code>$(=
...)*</code>, which is a =E2=80=9Czero or more=E2=80=9D match. Alternativel=
y you can write <code>$(...)+</code> for a =E2=80=9Cone or more=E2=80=9D ma=
tch. Both forms optionally include a separator, which can be any token exce=
pt <code>+</code> or <code>*</code>.</p>
  <p>This system is based on =E2=80=9C<a href=3D"http://www.cs.indiana.edu/=
ftp/techreports/TR206.pdf">Macro-by-Example</a>=E2=80=9D (PDF link).</p>
  <h3 id=3D"hygiene">Hygiene</h3>
  <p>Some languages implement macros using simple text substitution, which =
leads to various problems. For example, this C program prints <code>13</cod=
e> instead of the expected <code>25</code>.</p>
  <pre><code>#define FIVE_TIMES(x) 5 * x
 =20
  int main() {
      printf("%d\n", FIVE_TIMES(2 + 3));
      return 0;
  }</code></pre>
  <p>After expansion we have <code>5 * 2 + 3</code>, and multiplication has=
 greater precedence than addition. If you=E2=80=99ve used C macros a lot, y=
ou probably know the standard idioms for avoiding this problem, as well as =
five or six others. In Rust, we don=E2=80=99t have to worry about it.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> five_times {
      ($x:expr) =3D&gt; (<span class=3D"dv">5</span> * $x);
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">25</span>, <s=
pan class=3D"ot">five_times!</span>(<span class=3D"dv">2</span> + <span cla=
ss=3D"dv">3</span>));
  }</code></pre></div>
  <p>The metavariable <code>$x</code> is parsed as a single expression node=
, and keeps its place in the syntax tree even after substitution.</p>
  <p>Another common problem in macro systems is =E2=80=98variable capture=
=E2=80=99. Here=E2=80=99s a C macro, using <a href=3D"https://gcc.gnu.org/o=
nlinedocs/gcc/Statement-Exprs.html">a GNU C extension</a> to emulate Rust=
=E2=80=99s expression blocks.</p>
  <pre><code>#define LOG(msg) ({ \
      int state =3D get_log_state(); \
      if (state &gt; 0) { \
          printf("log(%d): %s\n", state, msg); \
      } \
  })</code></pre>
  <p>Here=E2=80=99s a simple use case that goes terribly wrong:</p>
  <pre><code>const char *state =3D "reticulating splines";
  LOG(state)</code></pre>
  <p>This expands to</p>
  <pre><code>const char *state =3D "reticulating splines";
  int state =3D get_log_state();
  if (state &gt; 0) {
      printf("log(%d): %s\n", state, state);
  }</code></pre>
  <p>The second variable named <code>state</code> shadows the first one. Th=
is is a problem because the print statement should refer to both of them.</=
p>
  <p>The equivalent Rust macro has the desired behavior.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> log {
      ($msg:expr) =3D&gt; {{
          <span class=3D"kw">let</span> state: <span class=3D"kw">i32</span=
> =3D get_log_state();
          <span class=3D"kw">if</span> state &gt; <span class=3D"dv">0</spa=
n> {
              <span class=3D"ot">println!</span>(<span class=3D"st">"log({}=
): {}"</span>, state, $msg);
          }
      }};
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> state: &amp;<span class=3D"kw">str</spa=
n> =3D <span class=3D"st">"reticulating splines"</span>;
      <span class=3D"ot">log!</span>(state);
  }</code></pre></div>
  <p>This works because Rust has a <a href=3D"http://en.wikipedia.org/wiki/=
Hygienic_macro">hygienic macro system</a>. Each macro expansion happens in =
a distinct =E2=80=98syntax context=E2=80=99, and each variable is tagged wi=
th the syntax context where it was introduced. It=E2=80=99s as though the v=
ariable <code>state</code> inside <code>main</code> is painted a different =
=E2=80=9Ccolor=E2=80=9D from the variable <code>state</code> inside the mac=
ro, and therefore they don=E2=80=99t conflict.</p>
  <p>This also restricts the ability of macros to introduce new bindings at=
 the invocation site. Code such as the following will not work:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> foo {
      () =3D&gt; (<span class=3D"kw">let</span> x =3D <span class=3D"dv">3<=
/span>);
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">foo!</span>();
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
;
  }</code></pre></div>
  <p>Instead you need to pass the variable name into the invocation, so it=
=E2=80=99s tagged with the right syntax context.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> foo {
      ($v:ident) =3D&gt; (<span class=3D"kw">let</span> $v =3D <span class=
=3D"dv">3</span>);
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">foo!</span>(x);
      <span class=3D"ot">println!</span>(<span class=3D"st">"{}"</span>, x)=
;
  }</code></pre></div>
  <p>This holds for <code>let</code> bindings and loop labels, but not for =
<a href=3D"http://doc.rust-lang.org/reference.html#items">items</a>. So the=
 following code does compile:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> foo {
      () =3D&gt; (<span class=3D"kw">fn</span> x() { });
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">foo!</span>();
      x();
  }</code></pre></div>
  <h3 id=3D"recursive-macros">Recursive macros</h3>
  <p>A macro=E2=80=99s expansion can include more macro invocations, includ=
ing invocations of the very same macro being expanded. These recursive macr=
os are useful for processing tree-structured input, as illustrated by this =
(simplistic) HTML shorthand:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> write_html {
      ($w:expr, ) =3D&gt; (());
 =20
      ($w:expr, $e:tt) =3D&gt; (<span class=3D"ot">write!</span>($w, <span =
class=3D"st">"{}"</span>, $e));
 =20
      ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =3D&gt; {{
          <span class=3D"ot">write!</span>($w, <span class=3D"st">"&lt;{}&g=
t;"</span>, <span class=3D"ot">stringify!</span>($tag));
          <span class=3D"ot">write_html!</span>($w, $($inner)*);
          <span class=3D"ot">write!</span>($w, <span class=3D"st">"&lt;/{}&=
gt;"</span>, <span class=3D"ot">stringify!</span>($tag));
          <span class=3D"ot">write_html!</span>($w, $($rest)*);
      }};
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">use</span> std::fmt::Write;
      <span class=3D"kw">let</span> <span class=3D"kw">mut</span> out =3D S=
tring::new();
 =20
      <span class=3D"ot">write_html!</span>(&amp;<span class=3D"kw">mut</sp=
an> out,
          html[
              head[title[<span class=3D"st">"Macros guide"</span>]]
              body[h1[<span class=3D"st">"Macros are the best!"</span>]]
          ]);
 =20
      <span class=3D"ot">assert_eq!</span>(out,
          <span class=3D"st">"&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros g=
uide&lt;/title&gt;&lt;/head&gt;\</span>
  <span class=3D"st">         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt=
;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>);
  }</code></pre></div>
  <h3 id=3D"debugging-macro-code">Debugging macro code</h3>
  <p>To see the results of expanding macros, run <code>rustc --pretty expan=
ded</code>. The output represents a whole crate, so you can also feed it ba=
ck in to <code>rustc</code>, which will sometimes produce better error mess=
ages than the original compilation. Note that the <code>--pretty expanded</=
code> output may have a different meaning if multiple variables of the same=
 name (but different syntax contexts) are in play in the same scope. In thi=
s case <code>--pretty expanded,hygiene</code> will tell you about the synta=
x contexts.</p>
  <p><code>rustc</code> provides two syntax extensions that help with macro=
 debugging. For now, they are unstable and require feature gates.</p>
  <ul>
  <li><p><code>log_syntax!(...)</code> will print its arguments to standard=
 output, at compile time, and =E2=80=9Cexpand=E2=80=9D to nothing.</p></li>
  <li><p><code>trace_macros!(true)</code> will enable a compiler message ev=
ery time a macro is expanded. Use <code>trace_macros!(false)</code> later i=
n expansion to turn it off.</p></li>
  </ul>
  <h3 id=3D"syntactic-requirements">Syntactic requirements</h3>
  <p>Even when Rust code contains un-expanded macros, it can be parsed as a=
 full <a href=3D"https://killercup.github.io/trpl-ebook/glossary.html#abstr=
act-syntax-tree">syntax tree</a>. This property can be very useful for edit=
ors and other tools that process code. It also has a few consequences for t=
he design of Rust=E2=80=99s macro system.</p>
  <p>One consequence is that Rust must determine, when it parses a macro in=
vocation, whether the macro stands in for</p>
  <ul>
  <li>zero or more items,</li>
  <li>zero or more methods,</li>
  <li>an expression,</li>
  <li>a statement, or</li>
  <li>a pattern.</li>
  </ul>
  <p>A macro invocation within a block could stand for some items, or for a=
n expression / statement. Rust uses a simple rule to resolve this ambiguity=
. A macro invocation that stands for items must be either</p>
  <ul>
  <li>delimited by curly braces, e.g. <code>foo! { ... }</code>, or</li>
  <li>terminated by a semicolon, e.g. <code>foo!(...);</code></li>
  </ul>
  <p>Another consequence of pre-expansion parsing is that the macro invocat=
ion must consist of valid Rust tokens. Furthermore, parentheses, brackets, =
and braces must be balanced within a macro invocation. For example, <code>f=
oo!([)</code> is forbidden. This allows Rust to know where the macro invoca=
tion ends.</p>
  <p>More formally, the macro invocation body must be a sequence of =E2=80=
=98token trees=E2=80=99. A token tree is defined recursively as either</p>
  <ul>
  <li>a sequence of token trees surrounded by matching <code>()</code>, <co=
de>[]</code>, or <code>{}</code>, or</li>
  <li>any other single token.</li>
  </ul>
  <p>Within a matcher, each metavariable has a =E2=80=98fragment specifier=
=E2=80=99, identifying which syntactic form it matches.</p>
  <ul>
  <li><code>ident</code>: an identifier. Examples: <code>x</code>; <code>fo=
o</code>.</li>
  <li><code>path</code>: a qualified name. Example: <code>T::SpecialA</code=
>.</li>
  <li><code>expr</code>: an expression. Examples: <code>2 + 2</code>; <code=
>if true then { 1 } else { 2 }</code>; <code>f(42)</code>.</li>
  <li><code>ty</code>: a type. Examples: <code>i32</code>; <code>Vec&lt;(ch=
ar, String)&gt;</code>; <code>&amp;T</code>.</li>
  <li><code>pat</code>: a pattern. Examples: <code>Some(t)</code>; <code>(1=
7, 'a')</code>; <code>_</code>.</li>
  <li><code>stmt</code>: a single statement. Example: <code>let x =3D 3</co=
de>.</li>
  <li><code>block</code>: a brace-delimited sequence of statements. Example=
: <code>{ log(error, "hi"); return 12; }</code>.</li>
  <li><code>item</code>: an <a href=3D"http://doc.rust-lang.org/reference.h=
tml#items">item</a>. Examples: <code>fn foo() { }</code>; <code>struct Bar;=
</code>.</li>
  <li><code>meta</code>: a =E2=80=9Cmeta item=E2=80=9D, as found in attribu=
tes. Example: <code>cfg(target_os =3D "windows")</code>.</li>
  <li><code>tt</code>: a single token tree.</li>
  </ul>
  <p>There are additional rules regarding the next token after a metavariab=
le:</p>
  <ul>
  <li><code>expr</code> variables must be followed by one of: <code>=3D&gt;=
 , ;</code></li>
  <li><code>ty</code> and <code>path</code> variables must be followed by o=
ne of: <code>=3D&gt; , : =3D &gt; as</code></li>
  <li><code>pat</code> variables must be followed by one of: <code>=3D&gt; =
, =3D</code></li>
  <li>Other variables may be followed by any token.</li>
  </ul>
  <p>These rules provide some flexibility for Rust=E2=80=99s syntax to evol=
ve without breaking existing macros.</p>
  <p>The macro system does not deal with parse ambiguity at all. For exampl=
e, the grammar <code>$($t:ty)* $e:expr</code> will always fail to parse, be=
cause the parser would be forced to choose between parsing <code>$t</code> =
and parsing <code>$e</code>. Changing the invocation syntax to put a distin=
ctive token in front can solve the problem. In this case, you can write <co=
de>$(T $t:ty)* E $e:exp</code>.</p>
  <h3 id=3D"scoping-and-macro-importexport">Scoping and macro import/export=
</h3>
  <p>Macros are expanded at an early stage in compilation, before name reso=
lution. One downside is that scoping works differently for macros, compared=
 to other constructs in the language.</p>
  <p>Definition and expansion of macros both happen in a single depth-first=
, lexical-order traversal of a crate=E2=80=99s source. So a macro defined a=
t module scope is visible to any subsequent code in the same module, which =
includes the body of any subsequent child <code>mod</code> items.</p>
  <p>A macro defined within the body of a single <code>fn</code>, or anywhe=
re else not at module scope, is visible only within that item.</p>
  <p>If a module has the <code>macro_use</code> attribute, its macros are a=
lso visible in its parent module after the child=E2=80=99s <code>mod</code>=
 item. If the parent also has <code>macro_use</code> then the macros will b=
e visible in the grandparent after the parent=E2=80=99s <code>mod</code> it=
em, and so forth.</p>
  <p>The <code>macro_use</code> attribute can also appear on <code>extern c=
rate</code>. In this context it controls which macros are loaded from the e=
xternal crate, e.g.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>macro_use<span class=3D"ot">(</=
span>foo<span class=3D"ot">,</span> bar<span class=3D"ot">)]</span>
  <span class=3D"kw">extern</span> crate baz;</code></pre></div>
  <p>If the attribute is given simply as <code>#[macro_use]</code>, all mac=
ros are loaded. If there is no <code>#[macro_use]</code> attribute then no =
macros are loaded. Only macros defined with the <code>#[macro_export]</code=
> attribute may be loaded.</p>
  <p>To load a crate=E2=80=99s macros without linking it into the output, u=
se <code>#[no_link]</code> as well.</p>
  <p>An example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> m1 { () =3D&gt; (())=
 }
 =20
  <span class=3D"co">// visible here: m1</span>
 =20
  <span class=3D"kw">mod</span> foo {
      <span class=3D"co">// visible here: m1</span>
 =20
      <span class=3D"ot">#[</span>macro_export<span class=3D"ot">]</span>
      <span class=3D"ot">macro_rules!</span> m2 { () =3D&gt; (()) }
 =20
      <span class=3D"co">// visible here: m1, m2</span>
  }
 =20
  <span class=3D"co">// visible here: m1</span>
 =20
  <span class=3D"ot">macro_rules!</span> m3 { () =3D&gt; (()) }
 =20
  <span class=3D"co">// visible here: m1, m3</span>
 =20
  <span class=3D"ot">#[</span>macro_use<span class=3D"ot">]</span>
  <span class=3D"kw">mod</span> bar {
      <span class=3D"co">// visible here: m1, m3</span>
 =20
      <span class=3D"ot">macro_rules!</span> m4 { () =3D&gt; (()) }
 =20
      <span class=3D"co">// visible here: m1, m3, m4</span>
  }
 =20
  <span class=3D"co">// visible here: m1, m3, m4</span></code></pre></div>
  <p>When this library is loaded with <code>#[macro_use] extern crate</code=
>, only <code>m2</code> will be imported.</p>
  <p>The Rust Reference has a <a href=3D"http://doc.rust-lang.org/reference=
.html#macro-related-attributes">listing of macro-related attributes</a>.</p=
>
  <h3 id=3D"the-variable-crate">The variable <code>$crate</code></h3>
  <p>A further difficulty occurs when a macro is used in multiple crates. S=
ay that <code>mylib</code> defines</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">pub</span> <span class=3D"kw">fn</span> =
increment(x: <span class=3D"kw">u32</span>) -&gt; <span class=3D"kw">u32</s=
pan> {
      x + <span class=3D"dv">1</span>
  }
 =20
  <span class=3D"ot">#[</span>macro_export<span class=3D"ot">]</span>
  <span class=3D"ot">macro_rules!</span> inc_a {
      ($x:expr) =3D&gt; ( ::increment($x) )
  }
 =20
  <span class=3D"ot">#[</span>macro_export<span class=3D"ot">]</span>
  <span class=3D"ot">macro_rules!</span> inc_b {
      ($x:expr) =3D&gt; ( ::mylib::increment($x) )
  }</code></pre></div>
  <p><code>inc_a</code> only works within <code>mylib</code>, while <code>i=
nc_b</code> only works outside the library. Furthermore, <code>inc_b</code>=
 will break if the user imports <code>mylib</code> under another name.</p>
  <p>Rust does not (yet) have a hygiene system for crate references, but it=
 does provide a simple workaround for this problem. Within a macro imported=
 from a crate named <code>foo</code>, the special macro variable <code>$cra=
te</code> will expand to <code>::foo</code>. By contrast, when a macro is d=
efined and then used in the same crate, <code>$crate</code> will expand to =
nothing. This means we can write</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">#[</span>macro_export<span class=3D"ot">=
]</span>
  <span class=3D"ot">macro_rules!</span> inc {
      ($x:expr) =3D&gt; ( $crate::increment($x) )
  }</code></pre></div>
  <p>to define a single macro that works both inside and outside our librar=
y. The function name will expand to either <code>::increment</code> or <cod=
e>::mylib::increment</code>.</p>
  <p>To keep this system simple and correct, <code>#[macro_use] extern crat=
e ...</code> may only appear at the root of your crate, not inside <code>mo=
d</code>. This ensures that <code>$crate</code> is a single identifier.</p>
  <h3 id=3D"the-deep-end">The deep end</h3>
  <p>The introductory chapter mentioned recursive macros, but it did not gi=
ve the full story. Recursive macros are useful for another reason: Each rec=
ursive invocation gives you another opportunity to pattern-match the macro=
=E2=80=99s arguments.</p>
  <p>As an extreme example, it is possible, though hardly advisable, to imp=
lement the <a href=3D"http://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise =
Cyclic Tag</a> automaton within Rust=E2=80=99s macro system.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">macro_rules!</span> bct {
      <span class=3D"co">// cmd 0:  d ... =3D&gt; ...</span>
      (<span class=3D"dv">0</span>, $($ps:tt),* ; $_d:tt)
          =3D&gt; (<span class=3D"ot">bct!</span>($($ps),*, <span class=3D"=
dv">0</span> ; ));
      (<span class=3D"dv">0</span>, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
          =3D&gt; (<span class=3D"ot">bct!</span>($($ps),*, <span class=3D"=
dv">0</span> ; $($ds),*));
 =20
      <span class=3D"co">// cmd 1p:  1 ... =3D&gt; 1 ... p</span>
      (<span class=3D"dv">1</span>, $p:tt, $($ps:tt),* ; <span class=3D"dv"=
>1</span>)
          =3D&gt; (<span class=3D"ot">bct!</span>($($ps),*, <span class=3D"=
dv">1</span>, $p ; <span class=3D"dv">1</span>, $p));
      (<span class=3D"dv">1</span>, $p:tt, $($ps:tt),* ; <span class=3D"dv"=
>1</span>, $($ds:tt),*)
          =3D&gt; (<span class=3D"ot">bct!</span>($($ps),*, <span class=3D"=
dv">1</span>, $p ; <span class=3D"dv">1</span>, $($ds),*, $p));
 =20
      <span class=3D"co">// cmd 1p:  0 ... =3D&gt; 0 ...</span>
      (<span class=3D"dv">1</span>, $p:tt, $($ps:tt),* ; $($ds:tt),*)
          =3D&gt; (<span class=3D"ot">bct!</span>($($ps),*, <span class=3D"=
dv">1</span>, $p ; $($ds),*));
 =20
      <span class=3D"co">// halt on empty data string</span>
      ( $($ps:tt),* ; )
          =3D&gt; (());
  }</code></pre></div>
  <p>Exercise: use macros to reduce duplication in the above definition of =
the <code>bct!</code> macro.</p>
  <h3 id=3D"common-macros">Common macros</h3>
  <p>Here are some common macros you=E2=80=99ll see in Rust code.</p>
  <h4 id=3D"panic">panic!</h4>
  <p>This macro causes the current thread to panic. You can give it a messa=
ge to panic with:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"ot">panic!</span>(<span class=3D"st">"oh no!=
"</span>);</code></pre></div>
  <h4 id=3D"vec">vec!</h4>
  <p>The <code>vec!</code> macro is used throughout the book, so you=E2=80=
=99ve probably seen it already. It creates <code>Vec&lt;T&gt;</code>s with =
ease:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!=
</span>[<span class=3D"dv">1</span>, <span class=3D"dv">2</span>, <span cla=
ss=3D"dv">3</span>, <span class=3D"dv">4</span>, <span class=3D"dv">5</span=
>];</code></pre></div>
  <p>It also lets you make vectors with repeating values. For example, a hu=
ndred zeroes:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!=
</span>[<span class=3D"dv">0</span>; <span class=3D"dv">100</span>];</code>=
</pre></div>
  <h4 id=3D"assert-and-assert_eq">assert! and assert_eq!</h4>
  <p>These two macros are used in tests. <code>assert!</code> takes a boole=
an, and <code>assert_eq!</code> takes two values and compares them. Truth p=
asses, success <code>panic!</code>s. Like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"co">// A-ok!</span>
 =20
  <span class=3D"ot">assert!</span>(<span class=3D"kw">true</span>);
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">5</span>, <span c=
lass=3D"dv">3</span> + <span class=3D"dv">2</span>);
 =20
  <span class=3D"co">// nope :(</span>
 =20
  <span class=3D"ot">assert!</span>(<span class=3D"dv">5</span> &lt; <span =
class=3D"dv">3</span>);
  <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">5</span>, <span c=
lass=3D"dv">3</span>);</code></pre></div>
  <h4 id=3D"try">try!</h4>
  <p><code>try!</code> is used for error handling. It takes something that =
can return a <code>Result&lt;T, E&gt;</code>, and gives <code>T</code> if i=
t=E2=80=99s a <code>Ok&lt;T&gt;</code>, and <code>return</code>s with the <=
code>Err(E)</code> if it=E2=80=99s that. Like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::fs::File;
 =20
  <span class=3D"kw">fn</span> foo() -&gt; std::io::<span class=3D"kw">Resu=
lt</span>&lt;()&gt; {
      <span class=3D"kw">let</span> f =3D <span class=3D"ot">try!</span>(Fi=
le::create(<span class=3D"st">"foo.txt"</span>));
 =20
      <span class=3D"kw">Ok</span>(())
  }</code></pre></div>
  <p>This is cleaner than doing this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">use</span> std::fs::File;
 =20
  <span class=3D"kw">fn</span> foo() -&gt; std::io::<span class=3D"kw">Resu=
lt</span>&lt;()&gt; {
      <span class=3D"kw">let</span> f =3D File::create(<span class=3D"st">"=
foo.txt"</span>);
 =20
      <span class=3D"kw">let</span> f =3D <span class=3D"kw">match</span> f=
 {
          <span class=3D"kw">Ok</span>(t) =3D&gt; t,
          <span class=3D"kw">Err</span>(e) =3D&gt; <span class=3D"kw">retur=
n</span> <span class=3D"kw">Err</span>(e),
      };
 =20
      <span class=3D"kw">Ok</span>(())
  }</code></pre></div>
  <h4 id=3D"unreachable">unreachable!</h4>
  <p>This macro is used when you think some code should never execute:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">if</span> <span class=3D"kw">false</span=
> {
      <span class=3D"ot">unreachable!</span>();
  }</code></pre></div>
  <p>Sometimes, the compiler may make you have a different branch that you =
know will never, ever run. In these cases, use this macro, so that if you e=
nd up wrong, you=E2=80=99ll get a <code>panic!</code> about it.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x: <span class=3D"kw">Option<=
/span>&lt;<span class=3D"kw">i32</span>&gt; =3D <span class=3D"kw">None</sp=
an>;
 =20
  <span class=3D"kw">match</span> x {
      <span class=3D"kw">Some</span>(_) =3D&gt; <span class=3D"ot">unreacha=
ble!</span>(),
      <span class=3D"kw">None</span> =3D&gt; <span class=3D"ot">println!</s=
pan>(<span class=3D"st">"I know x is None!"</span>),
  }</code></pre></div>
  <h4 id=3D"unimplemented">unimplemented!</h4>
  <p>The <code>unimplemented!</code> macro can be used when you=E2=80=99re =
trying to get your functions to typecheck, and don=E2=80=99t want to worry =
about writing out the body of the function. One example of this situation i=
s implementing a trait with multiple required methods, where you want to ta=
ckle one at a time. Define the others as <code>unimplemented!</code> until =
you=E2=80=99re ready to write them.</p>
  <h3 id=3D"procedural-macros">Procedural macros</h3>
  <p>If Rust=E2=80=99s macro system can=E2=80=99t do what you need, you may=
 want to write a <a href=3D"https://killercup.github.io/trpl-ebook/trpl-201=
5-05-13.html#sec--compiler-plugins">compiler plugin</a> instead. Compared t=
o <code>macro_rules!</code> macros, this is significantly more work, the in=
terfaces are much less stable, and bugs can be much harder to track down. I=
n exchange you get the flexibility of running arbitrary Rust code within th=
e compiler. Syntax extension plugins are sometimes called =E2=80=98procedur=
al macros=E2=80=99 for this reason.</p>
  <h2 id=3D"sec--raw-pointers">Raw Pointers</h2>
  <p>Rust has a number of different smart pointer types in its standard lib=
rary, but there are two types that are extra-special. Much of Rust=E2=80=99=
s safety comes from compile-time checks, but raw pointers don=E2=80=99t hav=
e such guarantees, and are <a href=3D"https://killercup.github.io/trpl-eboo=
k/trpl-2015-05-13.html#sec--unsafe">unsafe</a> to use.</p>
  <p><code>*const T</code> and <code>*mut T</code> are called =E2=80=98raw =
pointers=E2=80=99 in Rust. Sometimes, when writing certain kinds of librari=
es, you=E2=80=99ll need to get around Rust=E2=80=99s safety guarantees for =
some reason. In this case, you can use raw pointers to implement your libra=
ry, while exposing a safe interface for your users. For example, <code>*</c=
ode> pointers are allowed to alias, allowing them to be used to write share=
d-ownership types, and even thread-safe shared memory types (the <code>Rc&l=
t;T&gt;</code> and <code>Arc&lt;T&gt;</code> types are both implemented ent=
irely in Rust).</p>
  <p>Here are some things to remember about raw pointers that are different=
 than other pointer types. They:</p>
  <ul>
  <li>are not guaranteed to point to valid memory and are not even guarante=
ed to be non-null (unlike both <code>Box</code> and <code>&amp;</code>);</l=
i>
  <li>do not have any automatic clean-up, unlike <code>Box</code>, and so r=
equire manual resource management;</li>
  <li>are plain-old-data, that is, they don=E2=80=99t move ownership, again=
 unlike <code>Box</code>, hence the Rust compiler cannot protect against bu=
gs like use-after-free;</li>
  <li>lack any form of lifetimes, unlike <code>&amp;</code>, and so the com=
piler cannot reason about dangling pointers; and</li>
  <li>have no guarantees about aliasing or mutability other than mutation n=
ot being allowed directly through a <code>*const T</code>.</li>
  </ul>
  <h3 id=3D"basics">Basics</h3>
  <p>Creating a raw pointer is perfectly safe:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
  <span class=3D"kw">let</span> raw =3D &amp;x <span class=3D"kw">as</span>=
 *const <span class=3D"kw">i32</span>;
 =20
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> y =3D <span c=
lass=3D"dv">10</span>;
  <span class=3D"kw">let</span> raw_mut =3D &amp;<span class=3D"kw">mut</sp=
an> y <span class=3D"kw">as</span> *<span class=3D"kw">mut</span> <span cla=
ss=3D"kw">i32</span>;</code></pre></div>
  <p>However, dereferencing one is not. This won=E2=80=99t work:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
  <span class=3D"kw">let</span> raw =3D &amp;x <span class=3D"kw">as</span>=
 *const <span class=3D"kw">i32</span>;
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"raw points at {}"<=
/span>, *raw);</code></pre></div>
  <p>It gives this error:</p>
  <pre><code>error: dereference of unsafe pointer requires unsafe function =
or block [E0133]
       println!("raw points at{}", *raw);
                                   ^~~~</code></pre>
  <p>When you dereference a raw pointer, you=E2=80=99re taking responsibili=
ty that it=E2=80=99s not pointing somewhere that would be incorrect. As suc=
h, you need <code>unsafe</code>:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D <span class=3D"dv">5</s=
pan>;
  <span class=3D"kw">let</span> raw =3D &amp;x <span class=3D"kw">as</span>=
 *const <span class=3D"kw">i32</span>;
 =20
  <span class=3D"kw">let</span> points_at =3D <span class=3D"kw">unsafe</sp=
an> { *raw };
 =20
  <span class=3D"ot">println!</span>(<span class=3D"st">"raw points at {}"<=
/span>, points_at);</code></pre></div>
  <p>For more operations on raw pointers, see <a href=3D"http://doc.rust-la=
ng.org/std/primitive.pointer.html">their API documentation</a>.</p>
  <h3 id=3D"ffi">FFI</h3>
  <p>Raw pointers are useful for FFI: Rust=E2=80=99s <code>*const T</code> =
and <code>*mut T</code> are similar to C=E2=80=99s <code>const T*</code> an=
d <code>T*</code>, respectfully. For more about this use, consult the <a hr=
ef=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--ffi"=
>FFI chapter</a>.</p>
  <h3 id=3D"references-and-raw-pointers">References and raw pointers</h3>
  <p>At runtime, a raw pointer <code>*</code> and a reference pointing to t=
he same piece of data have an identical representation. In fact, an <code>&=
amp;T</code> reference will implicitly coerce to an <code>*const T</code> r=
aw pointer in safe code and similarly for the <code>mut</code> variants (bo=
th coercions can be performed explicitly with, respectively, <code>value as=
 *const T</code> and <code>value as *mut T</code>).</p>
  <p>Going the opposite direction, from <code>*const</code> to a reference =
<code>&amp;</code>, is not safe. A <code>&amp;T</code> is always valid, and=
 so, at a minimum, the raw pointer <code>*const T</code> has to point to a =
valid instance of type <code>T</code>. Furthermore, the resulting pointer m=
ust satisfy the aliasing and mutability laws of references. The compiler as=
sumes these properties are true for any references, no matter how they are =
created, and so any conversion from raw pointers is asserting that they hol=
d. The programmer <em>must</em> guarantee this.</p>
  <p>The recommended method for the conversion is</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> i: <span class=3D"kw">u32</sp=
an> =3D <span class=3D"dv">1</span>;
 =20
  <span class=3D"co">// explicit cast</span>
  <span class=3D"kw">let</span> p_imm: *const <span class=3D"kw">u32</span>=
 =3D &amp;i <span class=3D"kw">as</span> *const <span class=3D"kw">u32</spa=
n>;
  <span class=3D"kw">let</span> <span class=3D"kw">mut</span> m: <span clas=
s=3D"kw">u32</span> =3D <span class=3D"dv">2</span>;
 =20
  <span class=3D"co">// implicit coercion</span>
  <span class=3D"kw">let</span> p_mut: *<span class=3D"kw">mut</span> <span=
 class=3D"kw">u32</span> =3D &amp;<span class=3D"kw">mut</span> m;
 =20
  <span class=3D"kw">unsafe</span> {
      <span class=3D"kw">let</span> ref_imm: &amp;<span class=3D"kw">u32</s=
pan> =3D &amp;*p_imm;
      <span class=3D"kw">let</span> ref_mut: &amp;<span class=3D"kw">mut</s=
pan> <span class=3D"kw">u32</span> =3D &amp;<span class=3D"kw">mut</span> *=
p_mut;
  }</code></pre></div>
  <p>The <code>&amp;*x</code> dereferencing style is preferred to using a <=
code>transmute</code>. The latter is far more powerful than necessary, and =
the more restricted operation is harder to use incorrectly; for example, it=
 requires that <code>x</code> is a pointer (unlike <code>transmute</code>).=
</p>
  <h2 id=3D"sec--unsafe"><code>unsafe</code></h2>
  <p>Rust=E2=80=99s main draw is its powerful static guarantees about behav=
ior. But safety checks are conservative by nature: there are some programs =
that are actually safe, but the compiler is not able to verify this is true=
. To write these kinds of programs, we need to tell the compiler to relax i=
ts restrictions a bit. For this, Rust has a keyword, <code>unsafe</code>. C=
ode using <code>unsafe</code> has less restrictions than normal code does.<=
/p>
  <p>Let=E2=80=99s go over the syntax, and then we=E2=80=99ll talk semantic=
s. <code>unsafe</code> is used in two contexts. The first one is to mark a =
function as unsafe:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">unsafe</span> <span class=3D"kw">fn</spa=
n> danger_will_robinson() {
      <span class=3D"co">// scary stuff </span>
  }</code></pre></div>
  <p>All functions called from <a href=3D"https://killercup.github.io/trpl-=
ebook/trpl-2015-05-13.html#sec--ffi">FFI</a> must be marked as <code>unsafe=
</code>, for example. The second use of <code>unsafe</code> is an unsafe bl=
ock:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">unsafe</span> {
      <span class=3D"co">// scary stuff</span>
  }</code></pre></div>
  <p>It=E2=80=99s important to be able to explicitly delineate code that ma=
y have bugs that cause big problems. If a Rust program segfaults, you can b=
e sure it=E2=80=99s somewhere in the sections marked <code>unsafe</code>.</=
p>
  <h3 id=3D"what-does-safe-mean">What does =E2=80=98safe=E2=80=99 mean?</h3=
>
  <p>Safe, in the context of Rust, means =E2=80=9Cdoesn=E2=80=99t do anythi=
ng unsafe.=E2=80=9D Easy!</p>
  <p>Okay, let=E2=80=99s try again: what is not safe to do? Here=E2=80=99s =
a list:</p>
  <ul>
  <li>Data races</li>
  <li>Dereferencing a null/dangling raw pointer</li>
  <li>Reads of <a href=3D"http://llvm.org/docs/LangRef.html#undefined-value=
s">undef</a> (uninitialized) memory</li>
  <li>Breaking the <a href=3D"http://llvm.org/docs/LangRef.html#pointer-ali=
asing-rules">pointer aliasing rules</a> with raw pointers.</li>
  <li><code>&amp;mut T</code> and <code>&amp;T</code> follow LLVM=E2=80=99s=
 scoped <a href=3D"http://llvm.org/docs/LangRef.html#noalias">noalias</a> m=
odel, except if the <code>&amp;T</code> contains an <code>UnsafeCell&lt;U&g=
t;</code>. Unsafe code must not violate these aliasing guarantees.</li>
  <li>Mutating an immutable value/reference without <code>UnsafeCell&lt;U&g=
t;</code></li>
  <li>Invoking undefined behavior via compiler intrinsics:</li>
  <li>Indexing outside of the bounds of an object with <code>std::ptr::offs=
et</code> (<code>offset</code> intrinsic), with the exception of one byte p=
ast the end which is permitted.</li>
  <li>Using <code>std::ptr::copy_nonoverlapping_memory</code> (<code>memcpy=
32</code>/<code>memcpy64</code> intrinsics) on overlapping buffers</li>
  <li>Invalid values in primitive types, even in private fields/locals:</li=
>
  <li>Null/dangling references or boxes</li>
  <li>A value other than <code>false</code> (0) or <code>true</code> (1) in=
 a <code>bool</code></li>
  <li>A discriminant in an <code>enum</code> not included in its type defin=
ition</li>
  <li>A value in a <code>char</code> which is a surrogate or above <code>ch=
ar::MAX</code></li>
  <li>Non-UTF-8 byte sequences in a <code>str</code></li>
  <li>Unwinding into Rust from foreign code or unwinding from Rust into for=
eign code.</li>
  </ul>
  <p>Whew! That=E2=80=99s a bunch of stuff. It=E2=80=99s also important to =
notice all kinds of behaviors that are certainly bad, but are expressly <em=
>not</em> unsafe:</p>
  <ul>
  <li>Deadlocks</li>
  <li>Reading data from private fields</li>
  <li>Leaks due to reference count cycles</li>
  <li>Exiting without calling destructors</li>
  <li>Sending signals</li>
  <li>Accessing/modifying the file system</li>
  <li>Integer overflow</li>
  </ul>
  <p>Rust cannot prevent all kinds of software problems. Buggy code can and=
 will be written in Rust. These things aren=E2=80=99t great, but they don=
=E2=80=99t qualify as <code>unsafe</code> specifically.</p>
  <h3 id=3D"unsafe-superpowers">Unsafe Superpowers</h3>
  <p>In both unsafe functions and unsafe blocks, Rust will let you do three=
 things that you normally can not do. Just three. Here they are:</p>
  <ol type=3D"1">
  <li>Access or update a <a href=3D"https://killercup.github.io/trpl-ebook/=
const-and-static.html#static">static mutable variable</a>.</li>
  <li>Dereference a raw pointer.</li>
  <li>Call unsafe functions. This is the most powerful ability.</li>
  </ol>
  <p>That=E2=80=99s it. It=E2=80=99s important that <code>unsafe</code> doe=
s not, for example, =E2=80=98turn off the borrow checker=E2=80=99. Adding <=
code>unsafe</code> to some random Rust code doesn=E2=80=99t change its sema=
ntics, it won=E2=80=99t just start accepting anything.</p>
  <p>But it will let you write things that <em>do</em> break some of the ru=
les. Let=E2=80=99s go over these three abilities in order.</p>
  <h4 id=3D"access-or-update-a-static-mut">Access or update a <code>static =
mut</code></h4>
  <p>Rust has a feature called =E2=80=98<code>static mut</code>=E2=80=99 wh=
ich allows for mutable global state. Doing so can cause a data race, and as=
 such is inherently not safe. For more details, see the <a href=3D"https://=
killercup.github.io/trpl-ebook/const-and-static.html#static">static</a> sec=
tion of the book.</p>
  <h4 id=3D"dereference-a-raw-pointer">Dereference a raw pointer</h4>
  <p>Raw pointers let you do arbitrary pointer arithmetic, and can cause a =
number of different memory safety and security issues. In some senses, the =
ability to dereference an arbitrary pointer is one of the most dangerous th=
ings you can do. For more on raw pointers, see <a href=3D"https://killercup=
.github.io/trpl-ebook/trpl-2015-05-13.html#sec--raw-pointers">their section=
 of the book</a>.</p>
  <h4 id=3D"call-unsafe-functions">Call unsafe functions</h4>
  <p>This last ability works with both aspects of <code>unsafe</code>: you =
can only call functions marked <code>unsafe</code> from inside an unsafe bl=
ock.</p>
  <p>This ability is powerful and varied. Rust exposes some <a href=3D"http=
s://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec--intrinsics">co=
mpiler intrinsics</a> as unsafe functions, and some unsafe functions bypass=
 safety checks, trading safety for speed.</p>
  <p>I=E2=80=99ll repeat again: even though you <em>can</em> do arbitrary t=
hings in unsafe blocks and functions doesn=E2=80=99t mean you should. The c=
ompiler will act as though you=E2=80=99re upholding its invariants, so be c=
areful!</p>
  <h1 id=3D"sec--nightly-rust">Nightly Rust</h1>
  <p>Rust provides three distribution channels for Rust: nightly, beta, and=
 stable. Unstable features are only available on nightly Rust. For more det=
ails on this process, see =E2=80=98<a href=3D"http://blog.rust-lang.org/201=
4/10/30/Stability.html">Stability as a deliverable</a>=E2=80=99.</p>
  <p>To install nightly Rust, you can use <code>rustup.sh</code>:</p>
  <pre><code>$ curl -s https://static.rust-lang.org/rustup.sh | sh -s -- --=
channel=3Dnightly</code></pre>
  <p>If you=E2=80=99re concerned about the <a href=3D"http://curlpipesh.tum=
blr.com/">potential insecurity</a> of using <code>curl | sh</code>, please =
keep reading and see our disclaimer below. And feel free to use a two-step =
version of the installation and examine our installation script:</p>
  <pre><code>$ curl -f -L https://static.rust-lang.org/rustup.sh -O
  $ sh rustup.sh --channel=3Dnightly</code></pre>
  <p>If you=E2=80=99re on Windows, please download either the <a href=3D"ht=
tps://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.msi">32=
-bit installer</a> or the <a href=3D"https://static.rust-lang.org/dist/rust=
-1.0.0-beta-x86_64-pc-windows-gnu.msi">64-bit installer</a> and run it.</p>
  <h4 id=3D"uninstalling-1">Uninstalling</h4>
  <p>If you decide you don=E2=80=99t want Rust anymore, we=E2=80=99ll be a =
bit sad, but that=E2=80=99s okay. Not every programming language is great f=
or everyone. Just run the uninstall script:</p>
  <pre><code>$ sudo /usr/local/lib/rustlib/uninstall.sh</code></pre>
  <p>If you used the Windows installer, just re-run the <code>.msi</code> a=
nd it will give you an uninstall option.</p>
  <p>Some people, and somewhat rightfully so, get very upset when we tell y=
ou to <code>curl | sh</code>. Basically, when you do this, you are trusting=
 that the good people who maintain Rust aren=E2=80=99t going to hack your c=
omputer and do bad things. That=E2=80=99s a good instinct! If you=E2=80=99r=
e one of those people, please check out the documentation on <a href=3D"htt=
ps://github.com/rust-lang/rust#building-from-source">building Rust from Sou=
rce</a>, or <a href=3D"http://www.rust-lang.org/install.html">the official =
binary downloads</a>.</p>
  <p>Oh, we should also mention the officially supported platforms:</p>
  <ul>
  <li>Windows (7, 8, Server 2008 R2)</li>
  <li>Linux (2.6.18 or later, various distributions), x86 and x86-64</li>
  <li>OSX 10.7 (Lion) or greater, x86 and x86-64</li>
  </ul>
  <p>We extensively test Rust on these platforms, and a few others, too, li=
ke Android. But these are the ones most likely to work, as they have the mo=
st testing.</p>
  <p>Finally, a comment about Windows. Rust considers Windows to be a first=
-class platform upon release, but if we=E2=80=99re honest, the Windows expe=
rience isn=E2=80=99t as integrated as the Linux/OS X experience is. We=E2=
=80=99re working on it! If anything does not work, it is a bug. Please let =
us know if that happens. Each and every commit is tested against Windows ju=
st like any other platform.</p>
  <p>If you=E2=80=99ve got Rust installed, you can open up a shell, and typ=
e this:</p>
  <pre><code>$ rustc --version</code></pre>
  <p>You should see the version number, commit hash, commit date and build =
date:</p>
  <pre><code>rustc 1.0.0-nightly (f11f3e7ba 2015-01-04) (built 2015-01-06)<=
/code></pre>
  <p>If you did, Rust has been installed successfully! Congrats!</p>
  <p>This installer also installs a copy of the documentation locally, so y=
ou can read it offline. On UNIX systems, <code>/usr/local/share/doc/rust</c=
ode> is the location. On Windows, it=E2=80=99s in a <code>share/doc</code> =
directory, inside wherever you installed Rust to.</p>
  <p>If not, there are a number of places where you can get help. The easie=
st is <a href=3D"irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.=
mozilla.org</a>, which you can access through <a href=3D"http://chat.mibbit=
.com/?server=3Dirc.mozilla.org&amp;channel=3D%23rust">Mibbit</a>. Click tha=
t link, and you=E2=80=99ll be chatting with other Rustaceans (a silly nickn=
ame we call ourselves), and we can help you out. Other great resources incl=
ude <a href=3D"http://users.rust-lang.org/">the user=E2=80=99s forum</a>, a=
nd <a href=3D"http://stackoverflow.com/questions/tagged/rust">Stack Overflo=
w</a>.</p>
  <h2 id=3D"sec--compiler-plugins">Compiler Plugins</h2>
  <h3 id=3D"introduction-2">Introduction</h3>
  <p><code>rustc</code> can load compiler plugins, which are user-provided =
libraries that extend the compiler=E2=80=99s behavior with new syntax exten=
sions, lint checks, etc.</p>
  <p>A plugin is a dynamic library crate with a designated <em>registrar</e=
m> function that registers extensions with <code>rustc</code>. Other crates=
 can load these extensions using the crate attribute <code>#![plugin(...)]<=
/code>. See the <a href=3D"http://doc.rust-lang.org/rustc/plugin/index.html=
"><code>rustc::plugin</code></a> documentation for more about the mechanics=
 of defining and loading a plugin.</p>
  <p>If present, arguments passed as <code>#![plugin(foo(... args ...))]</c=
ode> are not interpreted by rustc itself. They are provided to the plugin t=
hrough the <code>Registry</code>=E2=80=99s <a href=3D"http://doc.rust-lang.=
org/rustc/plugin/registry/struct.Registry.html#method.args"><code>args</cod=
e> method</a>.</p>
  <p>In the vast majority of cases, a plugin should <em>only</em> be used t=
hrough <code>#![plugin]</code> and not through an <code>extern crate</code>=
 item. Linking a plugin would pull in all of libsyntax and librustc as depe=
ndencies of your crate. This is generally unwanted unless you are building =
another plugin. The <code>plugin_as_library</code> lint checks these guidel=
ines.</p>
  <p>The usual practice is to put compiler plugins in their own crate, sepa=
rate from any <code>macro_rules!</code> macros or ordinary Rust code meant =
to be used by consumers of a library.</p>
  <h3 id=3D"syntax-extensions">Syntax extensions</h3>
  <p>Plugins can extend Rust=E2=80=99s syntax in various ways. One kind of =
syntax extension is the procedural macro. These are invoked the same way as=
 <a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13.html#sec=
--macros">ordinary macros</a>, but the expansion is performed by arbitrary =
Rust code that manipulates <a href=3D"http://doc.rust-lang.org/syntax/ast/i=
ndex.html">syntax trees</a> at compile time.</p>
  <p>Let=E2=80=99s write a plugin <a href=3D"https://github.com/rust-lang/r=
ust/tree/master/src/test/auxiliary/roman_numerals.rs"><code>roman_numerals.=
rs</code></a> that implements Roman numeral integer literals.</p>
  <pre><code>#![crate_type=3D"dylib"]
  #![feature(plugin_registrar, rustc_private)]
 =20
  extern crate syntax;
  extern crate rustc;
 =20
  use syntax::codemap::Span;
  use syntax::parse::token;
  use syntax::ast::{TokenTree, TtToken};
  use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};
  use syntax::ext::build::AstBuilder;  // trait for expr_usize
  use rustc::plugin::Registry;
 =20
  fn expand_rn(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
          -&gt; Box&lt;MacResult + 'static&gt; {
 =20
      static NUMERALS: &amp;'static [(&amp;'static str, u32)] =3D &amp;[
          ("M", 1000), ("CM", 900), ("D", 500), ("CD", 400),
          ("C",  100), ("XC",  90), ("L",  50), ("XL",  40),
          ("X",   10), ("IX",   9), ("V",   5), ("IV",   4),
          ("I",    1)];
 =20
      let text =3D match args {
          [TtToken(_, token::Ident(s, _))] =3D&gt; token::get_ident(s).to_s=
tring(),
          _ =3D&gt; {
              cx.span_err(sp, "argument should be a single identifier");
              return DummyResult::any(sp);
          }
      };
 =20
      let mut text =3D &amp;*text;
      let mut total =3D 0;
      while !text.is_empty() {
          match NUMERALS.iter().find(|&amp;&amp;(rn, _)| text.starts_with(r=
n)) {
              Some(&amp;(rn, val)) =3D&gt; {
                  total +=3D val;
                  text =3D &amp;text[rn.len()..];
              }
              None =3D&gt; {
                  cx.span_err(sp, "invalid Roman numeral");
                  return DummyResult::any(sp);
              }
          }
      }
 =20
      MacEager::expr(cx.expr_u32(sp, total))
  }
 =20
  #[plugin_registrar]
  pub fn plugin_registrar(reg: &amp;mut Registry) {
      reg.register_macro("rn", expand_rn);
  }</code></pre>
  <p>Then we can use <code>rn!()</code> like any other macro:</p>
  <pre><code>#![feature(plugin)]
  #![plugin(roman_numerals)]
 =20
  fn main() {
      assert_eq!(rn!(MMXV), 2015);
  }</code></pre>
  <p>The advantages over a simple <code>fn(&amp;str) -&gt; u32</code> are:<=
/p>
  <ul>
  <li>The (arbitrarily complex) conversion is done at compile time.</li>
  <li>Input validation is also performed at compile time.</li>
  <li>It can be extended to allow use in patterns, which effectively gives =
a way to define new literal syntax for any data type.</li>
  </ul>
  <p>In addition to procedural macros, you can define new <a href=3D"http:/=
/doc.rust-lang.org/reference.html#derive"><code>derive</code></a>-like attr=
ibutes and other kinds of extensions. See <a href=3D"http://doc.rust-lang.o=
rg/rustc/plugin/registry/struct.Registry.html#method.register_syntax_extens=
ion"><code>Registry::register_syntax_extension</code></a> and the <a href=
=3D"http://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html"><co=
de>SyntaxExtension</code> enum</a>. For a more involved macro example, see =
<a href=3D"https://github.com/rust-lang/regex/blob/master/regex_macros/src/=
lib.rs"><code>regex_macros</code></a>.</p>
  <h4 id=3D"tips-and-tricks">Tips and tricks</h4>
  <p>Some of the <a href=3D"https://killercup.github.io/trpl-ebook/macros.h=
tml#debugging-macro-code">macro debugging tips</a> are applicable.</p>
  <p>You can use <a href=3D"http://doc.rust-lang.org/syntax/parse/index.htm=
l"><code>syntax::parse</code></a> to turn token trees into higher-level syn=
tax elements like expressions:</p>
  <pre><code>fn expand_foo(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[Toke=
nTree])
          -&gt; Box&lt;MacResult+'static&gt; {
 =20
      let mut parser =3D cx.new_parser_from_tts(args);
 =20
      let expr: P&lt;Expr&gt; =3D parser.parse_expr();</code></pre>
  <p>Looking through <a href=3D"https://github.com/rust-lang/rust/blob/mast=
er/src/libsyntax/parse/parser.rs"><code>libsyntax</code> parser code</a> wi=
ll give you a feel for how the parsing infrastructure works.</p>
  <p>Keep the <a href=3D"http://doc.rust-lang.org/syntax/codemap/struct.Spa=
n.html"><code>Span</code>s</a> of everything you parse, for better error re=
porting. You can wrap <a href=3D"http://doc.rust-lang.org/syntax/codemap/st=
ruct.Spanned.html"><code>Spanned</code></a> around your custom data structu=
res.</p>
  <p>Calling <a href=3D"http://doc.rust-lang.org/syntax/ext/base/struct.Ext=
Ctxt.html#method.span_fatal"><code>ExtCtxt::span_fatal</code></a> will imme=
diately abort compilation. It=E2=80=99s better to instead call <a href=3D"h=
ttp://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_err=
"><code>ExtCtxt::span_err</code></a> and return <a href=3D"http://doc.rust-=
lang.org/syntax/ext/base/struct.DummyResult.html"><code>DummyResult</code><=
/a>, so that the compiler can continue and find further errors.</p>
  <p>To print syntax fragments for debugging, you can use <a href=3D"http:/=
/doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_note"><c=
ode>span_note</code></a> together with <a href=3D"http://doc.rust-lang.org/=
syntax/print/pprust/index.html#functions"><code>syntax::print::pprust::*_to=
_string</code></a>.</p>
  <p>The example above produced an integer literal using <a href=3D"http://=
doc.rust-lang.org/syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usiz=
e"><code>AstBuilder::expr_usize</code></a>. As an alternative to the <code>=
AstBuilder</code> trait, <code>libsyntax</code> provides a set of <a href=
=3D"http://doc.rust-lang.org/syntax/ext/quote/index.html">quasiquote macros=
</a>. They are undocumented and very rough around the edges. However, the i=
mplementation may be a good starting point for an improved quasiquote as an=
 ordinary plugin library.</p>
  <h3 id=3D"lint-plugins">Lint plugins</h3>
  <p>Plugins can extend <a href=3D"http://doc.rust-lang.org/reference.html#=
lint-check-attributes">Rust=E2=80=99s lint infrastructure</a> with addition=
al checks for code style, safety, etc. You can see <a href=3D"https://githu=
b.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs"><c=
ode>src/test/auxiliary/lint_plugin_test.rs</code></a> for a full example, t=
he core of which is reproduced here:</p>
  <pre><code>declare_lint!(TEST_LINT, Warn,
                "Warn about items named 'lintme'");
 =20
  struct Pass;
 =20
  impl LintPass for Pass {
      fn get_lints(&amp;self) -&gt; LintArray {
          lint_array!(TEST_LINT)
      }
 =20
      fn check_item(&amp;mut self, cx: &amp;Context, it: &amp;ast::Item) {
          let name =3D token::get_ident(it.ident);
          if name.get() =3D=3D "lintme" {
              cx.span_lint(TEST_LINT, it.span, "item is named 'lintme'");
          }
      }
  }
 =20
  #[plugin_registrar]
  pub fn plugin_registrar(reg: &amp;mut Registry) {
      reg.register_lint_pass(box Pass as LintPassObject);
  }</code></pre>
  <p>Then code like</p>
  <pre><code>#![plugin(lint_plugin_test)]
 =20
  fn lintme() { }</code></pre>
  <p>will produce a compiler warning:</p>
  <pre><code>foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_=
lint)] on by default
  foo.rs:4 fn lintme() { }
           ^~~~~~~~~~~~~~~</code></pre>
  <p>The components of a lint plugin are:</p>
  <ul>
  <li><p>one or more <code>declare_lint!</code> invocations, which define s=
tatic <a href=3D"http://doc.rust-lang.org/rustc/lint/struct.Lint.html"><cod=
e>Lint</code></a> structs;</p></li>
  <li><p>a struct holding any state needed by the lint pass (here, none);</=
p></li>
  <li><p>a <a href=3D"http://doc.rust-lang.org/rustc/lint/trait.LintPass.ht=
ml"><code>LintPass</code></a> implementation defining how to check each syn=
tax element. A single <code>LintPass</code> may call <code>span_lint</code>=
 for several different <code>Lint</code>s, but should register them all thr=
ough the <code>get_lints</code> method.</p></li>
  </ul>
  <p>Lint passes are syntax traversals, but they run at a late stage of com=
pilation where type information is available. <code>rustc</code>=E2=80=99s =
<a href=3D"https://github.com/rust-lang/rust/blob/master/src/librustc/lint/=
builtin.rs">built-in lints</a> mostly use the same infrastructure as lint p=
lugins, and provide examples of how to access type information.</p>
  <p>Lints defined by plugins are controlled by the usual <a href=3D"http:/=
/doc.rust-lang.org/reference.html#lint-check-attributes">attributes and com=
piler flags</a>, e.g. <code>#[allow(test_lint)]</code> or <code>-A test-lin=
t</code>. These identifiers are derived from the first argument to <code>de=
clare_lint!</code>, with appropriate case and punctuation conversion.</p>
  <p>You can run <code>rustc -W help foo.rs</code> to see a list of lints k=
nown to <code>rustc</code>, including those provided by plugins loaded by <=
code>foo.rs</code>.</p>
  <h2 id=3D"sec--inline-assembly">Inline Assembly</h2>
  <p>For extremely low-level manipulations and performance reasons, one mig=
ht wish to control the CPU directly. Rust supports using inline assembly to=
 do this via the <code>asm!</code> macro. The syntax roughly matches that o=
f GCC &amp; Clang:</p>
  <pre><code>asm!(assembly template
     : output operands
     : input operands
     : clobbers
     : options
     );</code></pre>
  <p>Any use of <code>asm</code> is feature gated (requires <code>#![featur=
e(asm)]</code> on the crate to allow) and of course requires an <code>unsaf=
e</code> block.</p>
  <blockquote>
  <p><strong>Note</strong>: the examples here are given in x86/x86-64 assem=
bly, but all platforms are supported.</p>
  </blockquote>
  <h4 id=3D"assembly-template">Assembly template</h4>
  <p>The <code>assembly template</code> is the only required parameter and =
must be a literal string (i.e. <code>""</code>)</p>
  <pre><code>#![feature(asm)]
 =20
  #[cfg(any(target_arch =3D "x86", target_arch =3D "x86_64"))]
  fn foo() {
      unsafe {
          asm!("NOP");
      }
  }
 =20
  // other platforms
  #[cfg(not(any(target_arch =3D "x86", target_arch =3D "x86_64")))]
  fn foo() { /* ... */ }
 =20
  fn main() {
      // ...
      foo();
      // ...
  }</code></pre>
  <p>(The <code>feature(asm)</code> and <code>#[cfg]</code>s are omitted fr=
om now on.)</p>
  <p>Output operands, input operands, clobbers and options are all optional=
 but you must add the right number of <code>:</code> if you skip them:</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch =3D "x86", target_arch =3D "x86_64"))]
  # fn main() { unsafe {
  asm!("xor %eax, %eax"
      :
      :
      : "{eax}"
     );
  # } }</code></pre>
  <p>Whitespace also doesn=E2=80=99t matter:</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch =3D "x86", target_arch =3D "x86_64"))]
  # fn main() { unsafe {
  asm!("xor %eax, %eax" ::: "{eax}");
  # } }</code></pre>
  <h4 id=3D"operands">Operands</h4>
  <p>Input and output operands follow the same format: <code>: "constraints=
1"(expr1), "constraints2"(expr2), ..."</code>. Output operand expressions m=
ust be mutable lvalues, or not yet assigned:</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch =3D "x86", target_arch =3D "x86_64"))]
  fn add(a: i32, b: i32) -&gt; i32 {
      let c: i32;
      unsafe {
          asm!("add $2, $0"
               : "=3Dr"(c)
               : "0"(a), "r"(b)
               );
      }
      c
  }
  # #[cfg(not(any(target_arch =3D "x86", target_arch =3D "x86_64")))]
  # fn add(a: i32, b: i32) -&gt; i32 { a + b }
 =20
  fn main() {
      assert_eq!(add(3, 14159), 14162)
  }</code></pre>
  <p>If you would like to use real operands in this position, however, you =
are required to put curly braces <code>{}</code> around the register that y=
ou want, and you are required to put the specific size of the operand. This=
 is useful for very low level programming, where which register you use is =
important:</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch =3D "x86", target_arch =3D "x86_64"))]
  # unsafe fn read_byte_in(port: u16) -&gt; u8 {
  let result: u8;
  asm!("in %dx, %al" : "=3D{al}"(result) : "{dx}"(port));
  result
  # }</code></pre>
  <h4 id=3D"clobbers">Clobbers</h4>
  <p>Some instructions modify registers which might otherwise have held dif=
ferent values so we use the clobbers list to indicate to the compiler not t=
o assume any values loaded into those registers will stay valid.</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch =3D "x86", target_arch =3D "x86_64"))]
  # fn main() { unsafe {
  // Put the value 0x200 in eax
  asm!("mov $$0x200, %eax" : /* no outputs */ : /* no inputs */ : "{eax}");
  # } }</code></pre>
  <p>Input and output registers need not be listed since that information i=
s already communicated by the given constraints. Otherwise, any other regis=
ters used either implicitly or explicitly should be listed.</p>
  <p>If the assembly changes the condition code register <code>cc</code> sh=
ould be specified as one of the clobbers. Similarly, if the assembly modifi=
es memory, <code>memory</code> should also be specified.</p>
  <h4 id=3D"options">Options</h4>
  <p>The last section, <code>options</code> is specific to Rust. The format=
 is comma separated literal strings (i.e. <code>:"foo", "bar", "baz"</code>=
). It=E2=80=99s used to specify some extra info about the inline assembly:<=
/p>
  <p>Current valid options are:</p>
  <ol type=3D"1">
  <li><em>volatile</em> - specifying this is analogous to <code>__asm__ __v=
olatile__ (...)</code> in gcc/clang.</li>
  <li><em>alignstack</em> - certain instructions expect the stack to be ali=
gned a certain way (i.e.&nbsp;SSE) and specifying this indicates to the com=
piler to insert its usual stack alignment code</li>
  <li><em>intel</em> - use intel syntax instead of the default AT&amp;T.</l=
i>
  </ol>
  <!-- -->
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch =3D "x86", target_arch =3D "x86_64"))]
  # fn main() {
  let result: i32;
  unsafe {
     asm!("mov eax, 2" : "=3D{eax}"(result) : : : "intel")
  }
  println!("eax is currently {}", result);
  # }</code></pre>
  <h2 id=3D"sec--no-stdlib">No stdlib</h2>
  <p>By default, <code>std</code> is linked to every Rust crate. In some co=
ntexts, this is undesirable, and can be avoided with the <code>#![no_std]</=
code> attribute attached to the crate.</p>
  <pre><code>// a minimal library
  #![crate_type=3D"lib"]
  #![feature(no_std)]
  #![no_std]
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>Obviously there=E2=80=99s more to life than just libraries: one can us=
e <code>#[no_std]</code> with an executable, controlling the entry point is=
 possible in two ways: the <code>#[start]</code> attribute, or overriding t=
he default shim for the C <code>main</code> function with your own.</p>
  <p>The function marked <code>#[start]</code> is passed the command line p=
arameters in the same format as C:</p>
  <pre><code>#![feature(lang_items, start, no_std, libc)]
  #![no_std]
 =20
  // Pull in the system libc library for what crt0.o likely requires
  extern crate libc;
 =20
  // Entry point for this program
  #[start]
  fn start(_argc: isize, _argv: *const *const u8) -&gt; isize {
      0
  }
 =20
  // These functions and traits are used by the compiler, but not
  // for a bare-bones hello world. These are normally
  // provided by libstd.
  #[lang =3D "stack_exhausted"] extern fn stack_exhausted() {}
  #[lang =3D "eh_personality"] extern fn eh_personality() {}
  #[lang =3D "panic_fmt"] fn panic_fmt() -&gt; ! { loop {} }
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>To override the compiler-inserted <code>main</code> shim, one has to d=
isable it with <code>#![no_main]</code> and then create the appropriate sym=
bol with the correct ABI and the correct name, which requires overriding th=
e compiler=E2=80=99s name mangling too:</p>
  <pre><code>#![feature(no_std)]
  #![no_std]
  #![no_main]
  #![feature(lang_items, start)]
 =20
  extern crate libc;
 =20
  #[no_mangle] // ensure that this symbol is called `main` in the output
  pub extern fn main(argc: i32, argv: *const *const u8) -&gt; i32 {
      0
  }
 =20
  #[lang =3D "stack_exhausted"] extern fn stack_exhausted() {}
  #[lang =3D "eh_personality"] extern fn eh_personality() {}
  #[lang =3D "panic_fmt"] fn panic_fmt() -&gt; ! { loop {} }
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>The compiler currently makes a few assumptions about symbols which are=
 available in the executable to call. Normally these functions are provided=
 by the standard library, but without it you must define your own.</p>
  <p>The first of these three functions, <code>stack_exhausted</code>, is i=
nvoked whenever stack overflow is detected. This function has a number of r=
estrictions about how it can be called and what it must do, but if the stac=
k limit register is not being maintained then a thread always has an =E2=80=
=9Cinfinite stack=E2=80=9D and this function shouldn=E2=80=99t get triggere=
d.</p>
  <p>The second of these three functions, <code>eh_personality</code>, is u=
sed by the failure mechanisms of the compiler. This is often mapped to GCC=
=E2=80=99s personality function (see the <a href=3D"http://doc.rust-lang.or=
g/std/rt/unwind/index.html">libstd implementation</a> for more information)=
, but crates which do not trigger a panic can be assured that this function=
 is never called. The final function, <code>panic_fmt</code>, is also used =
by the failure mechanisms of the compiler.</p>
  <h4 id=3D"using-libcore">Using libcore</h4>
  <blockquote>
  <p><strong>Note</strong>: the core library=E2=80=99s structure is unstabl=
e, and it is recommended to use the standard library instead wherever possi=
ble.</p>
  </blockquote>
  <p>With the above techniques, we=E2=80=99ve got a bare-metal executable r=
unning some Rust code. There is a good deal of functionality provided by th=
e standard library, however, that is necessary to be productive in Rust. If=
 the standard library is not sufficient, then <a href=3D"http://doc.rust-la=
ng.org/core/index.html">libcore</a> is designed to be used instead.</p>
  <p>The core library has very few dependencies and is much more portable t=
han the standard library itself. Additionally, the core library has most of=
 the necessary functionality for writing idiomatic and effective Rust code.=
</p>
  <p>As an example, here is a program that will calculate the dot product o=
f two vectors provided from C, using idiomatic Rust practices.</p>
  <pre><code>#![feature(lang_items, start, no_std, core, libc)]
  #![no_std]
 =20
  # extern crate libc;
  extern crate core;
 =20
  use core::prelude::*;
 =20
  use core::mem;
 =20
  #[no_mangle]
  pub extern fn dot_product(a: *const u32, a_len: u32,
                            b: *const u32, b_len: u32) -&gt; u32 {
      use core::raw::Slice;
 =20
      // Convert the provided arrays into Rust slices.
      // The core::raw module guarantees that the Slice
      // structure has the same memory layout as a &amp;[T]
      // slice.
      //
      // This is an unsafe operation because the compiler
      // cannot tell the pointers are valid.
      let (a_slice, b_slice): (&amp;[u32], &amp;[u32]) =3D unsafe {
          mem::transmute((
              Slice { data: a, len: a_len as usize },
              Slice { data: b, len: b_len as usize },
          ))
      };
 =20
      // Iterate over the slices, collecting the result
      let mut ret =3D 0;
      for (i, j) in a_slice.iter().zip(b_slice.iter()) {
          ret +=3D (*i) * (*j);
      }
      return ret;
  }
 =20
  #[lang =3D "panic_fmt"]
  extern fn panic_fmt(args: &amp;core::fmt::Arguments,
                      file: &amp;str,
                      line: u32) -&gt; ! {
      loop {}
  }
 =20
  #[lang =3D "stack_exhausted"] extern fn stack_exhausted() {}
  #[lang =3D "eh_personality"] extern fn eh_personality() {}
  # #[start] fn start(argc: isize, argv: *const *const u8) -&gt; isize { 0 =
}
  # fn main() {}</code></pre>
  <p>Note that there is one extra lang item here which differs from the exa=
mples above, <code>panic_fmt</code>. This must be defined by consumers of l=
ibcore because the core library declares panics, but it does not define it.=
 The <code>panic_fmt</code> lang item is this crate=E2=80=99s definition of=
 panic, and it must be guaranteed to never return.</p>
  <p>As can be seen in this example, the core library is intended to provid=
e the power of Rust in all circumstances, regardless of platform requiremen=
ts. Further libraries, such as liballoc, add functionality to libcore which=
 make other platform-specific assumptions, but continue to be more portable=
 than the standard library itself.</p>
  <h2 id=3D"sec--intrinsics">Intrinsics</h2>
  <blockquote>
  <p><strong>Note</strong>: intrinsics will forever have an unstable interf=
ace, it is recommended to use the stable interfaces of libcore rather than =
intrinsics directly.</p>
  </blockquote>
  <p>These are imported as if they were FFI functions, with the special <co=
de>rust-intrinsic</code> ABI. For example, if one was in a freestanding con=
text, but wished to be able to <code>transmute</code> between types, and pe=
rform efficient pointer arithmetic, one would import those functions via a =
declaration like</p>
  <pre><code># #![feature(intrinsics)]
  # fn main() {}
 =20
  extern "rust-intrinsic" {
      fn transmute&lt;T, U&gt;(x: T) -&gt; U;
 =20
      fn offset&lt;T&gt;(dst: *const T, offset: isize) -&gt; *const T;
  }</code></pre>
  <p>As with any other FFI functions, these are always <code>unsafe</code> =
to call.</p>
  <h2 id=3D"sec--lang-items">Lang items</h2>
  <blockquote>
  <p><strong>Note</strong>: lang items are often provided by crates in the =
Rust distribution, and lang items themselves have an unstable interface. It=
 is recommended to use officially distributed crates instead of defining yo=
ur own lang items.</p>
  </blockquote>
  <p>The <code>rustc</code> compiler has certain pluggable operations, that=
 is, functionality that isn=E2=80=99t hard-coded into the language, but is =
implemented in libraries, with a special marker to tell the compiler it exi=
sts. The marker is the attribute <code>#[lang =3D "..."]</code> and there a=
re various different values of <code>...</code>, i.e.&nbsp;various differen=
t =E2=80=98lang items=E2=80=99.</p>
  <p>For example, <code>Box</code> pointers require two lang items, one for=
 allocation and one for deallocation. A freestanding program that uses the =
<code>Box</code> sugar for dynamic allocations via <code>malloc</code> and =
<code>free</code>:</p>
  <pre><code>#![feature(lang_items, box_syntax, start, no_std, libc)]
  #![no_std]
 =20
  extern crate libc;
 =20
  extern {
      fn abort() -&gt; !;
  }
 =20
  #[lang =3D "owned_box"]
  pub struct Box&lt;T&gt;(*mut T);
 =20
  #[lang =3D "exchange_malloc"]
  unsafe fn allocate(size: usize, _align: usize) -&gt; *mut u8 {
      let p =3D libc::malloc(size as libc::size_t) as *mut u8;
 =20
      // malloc failed
      if p as usize =3D=3D 0 {
          abort();
      }
 =20
      p
  }
  #[lang =3D "exchange_free"]
  unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {
      libc::free(ptr as *mut libc::c_void)
  }
 =20
  #[start]
  fn main(argc: isize, argv: *const *const u8) -&gt; isize {
      let x =3D box 1;
 =20
      0
  }
 =20
  #[lang =3D "stack_exhausted"] extern fn stack_exhausted() {}
  #[lang =3D "eh_personality"] extern fn eh_personality() {}
  #[lang =3D "panic_fmt"] fn panic_fmt() -&gt; ! { loop {} }</code></pre>
  <p>Note the use of <code>abort</code>: the <code>exchange_malloc</code> l=
ang item is assumed to return a valid pointer, and so needs to do the check=
 internally.</p>
  <p>Other features provided by lang items include:</p>
  <ul>
  <li>overloadable operators via traits: the traits corresponding to the <c=
ode>=3D=3D</code>, <code>&lt;</code>, dereferencing (<code>*</code>) and <c=
ode>+</code> (etc.) operators are all marked with lang items; those specifi=
c four are <code>eq</code>, <code>ord</code>, <code>deref</code>, and <code=
>add</code> respectively.</li>
  <li>stack unwinding and general failure; the <code>eh_personality</code>,=
 <code>fail</code> and <code>fail_bounds_checks</code> lang items.</li>
  <li>the traits in <code>std::marker</code> used to indicate types of vari=
ous kinds; lang items <code>send</code>, <code>sync</code> and <code>copy</=
code>.</li>
  <li>the marker types and variance indicators found in <code>std::marker</=
code>; lang items <code>covariant_type</code>, <code>contravariant_lifetime=
</code>, etc.</li>
  </ul>
  <p>Lang items are loaded lazily by the compiler; e.g.&nbsp;if one never u=
ses <code>Box</code> then there is no need to define functions for <code>ex=
change_malloc</code> and <code>exchange_free</code>. <code>rustc</code> wil=
l emit an error when an item is needed but not found in the current crate o=
r any that it depends on.</p>
  <h2 id=3D"sec--link-args">Link args</h2>
  <p>There is one other way to tell rustc how to customize linking, and tha=
t is via the <code>link_args</code> attribute. This attribute is applied to=
 <code>extern</code> blocks and specifies raw flags which need to get passe=
d to the linker when producing an artifact. An example usage would be:</p>
  <pre><code>#![feature(link_args)]
 =20
  #[link_args =3D "-foo -bar -baz"]
  extern {}
  # fn main() {}</code></pre>
  <p>Note that this feature is currently hidden behind the <code>feature(li=
nk_args)</code> gate because this is not a sanctioned way of performing lin=
king. Right now rustc shells out to the system linker, so it makes sense to=
 provide extra command line arguments, but this will not always be the case=
. In the future rustc may use LLVM directly to link native libraries in whi=
ch case <code>link_args</code> will have no meaning.</p>
  <p>It is highly recommended to <em>not</em> use this attribute, and rathe=
r use the more formal <code>#[link(...)]</code> attribute on <code>extern</=
code> blocks instead.</p>
  <h2 id=3D"sec--benchmark-tests">Benchmark Tests</h2>
  <p>Rust supports benchmark tests, which can test the performance of your =
code. Let=E2=80=99s make our <code>src/lib.rs</code> look like this (commen=
ts elided):</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(test)]
 =20
  <span class=3D"kw">extern</span> crate test;
 =20
  <span class=3D"kw">pub</span> <span class=3D"kw">fn</span> add_two(a: <sp=
an class=3D"kw">i32</span>) -&gt; <span class=3D"kw">i32</span> {
      a + <span class=3D"dv">2</span>
  }
 =20
  <span class=3D"ot">#[</span>cfg<span class=3D"ot">(</span>test<span class=
=3D"ot">)]</span>
  <span class=3D"kw">mod</span> tests {
      <span class=3D"kw">use</span> <span class=3D"kw">super</span>::*;
      <span class=3D"kw">use</span> test::Bencher;
 =20
      <span class=3D"ot">#[</span>test<span class=3D"ot">]</span>
      <span class=3D"kw">fn</span> it_works() {
          <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">4</span>,=
 add_two(<span class=3D"dv">2</span>));
      }
 =20
      <span class=3D"ot">#[</span>bench<span class=3D"ot">]</span>
      <span class=3D"kw">fn</span> bench_add_two(b: &amp;<span class=3D"kw"=
>mut</span> Bencher) {
          b.iter(|| add_two(<span class=3D"dv">2</span>));
      }
  }</code></pre></div>
  <p>Note the <code>test</code> feature gate, which enables this unstable f=
eature.</p>
  <p>We=E2=80=99ve imported the <code>test</code> crate, which contains our=
 benchmarking support. We have a new function as well, with the <code>bench=
</code> attribute. Unlike regular tests, which take no arguments, benchmark=
 tests take a <code>&amp;mut Bencher</code>. This <code>Bencher</code> prov=
ides an <code>iter</code> method, which takes a closure. This closure conta=
ins the code we=E2=80=99d like to benchmark.</p>
  <p>We can run benchmark tests with <code>cargo bench</code>:</p>
  <pre><code>$ cargo bench
     Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
       Running target/release/adder-91b3e234d4ed382a
 =20
  running 2 tests
  test tests::it_works ... ignored
  test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)
 =20
  test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured</code></pre>
  <p>Our non-benchmark test was ignored. You may have noticed that <code>ca=
rgo bench</code> takes a bit longer than <code>cargo test</code>. This is b=
ecause Rust runs our benchmark a number of times, and then takes the averag=
e. Because we=E2=80=99re doing so little work in this example, we have a <c=
ode>1 ns/iter (+/- 0)</code>, but this would show the variance if there was=
 one.</p>
  <p>Advice on writing benchmarks:</p>
  <ul>
  <li>Move setup code outside the <code>iter</code> loop; only put the part=
 you want to measure inside</li>
  <li>Make the code do =E2=80=9Cthe same thing=E2=80=9D on each iteration; =
do not accumulate or change state</li>
  <li>Make the outer function idempotent too; the benchmark runner is likel=
y to run it many times</li>
  <li>Make the inner <code>iter</code> loop short and fast so benchmark run=
s are fast and the calibrator can adjust the run-length at fine resolution<=
/li>
  <li>Make the code in the <code>iter</code> loop do something simple, to a=
ssist in pinpointing performance improvements (or regressions)</li>
  </ul>
  <h4 id=3D"gotcha-optimizations">Gotcha: optimizations</h4>
  <p>There=E2=80=99s another tricky part to writing benchmarks: benchmarks =
compiled with optimizations activated can be dramatically changed by the op=
timizer so that the benchmark is no longer benchmarking what one expects. F=
or example, the compiler might recognize that some calculation has no exter=
nal effects and remove it entirely.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(test)]
 =20
  <span class=3D"kw">extern</span> crate test;
  <span class=3D"kw">use</span> test::Bencher;
 =20
  <span class=3D"ot">#[</span>bench<span class=3D"ot">]</span>
  <span class=3D"kw">fn</span> bench_xor_1000_ints(b: &amp;<span class=3D"k=
w">mut</span> Bencher) {
      b.iter(|| {
          (<span class=3D"dv">0.</span>.<span class=3D"dv">1000</span>).fol=
d(<span class=3D"dv">0</span>, |old, new| old ^ new);
      });
  }</code></pre></div>
  <p>gives the following results</p>
  <pre><code>running 1 test
  test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)
 =20
  test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured</code></pre>
  <p>The benchmarking runner offers two ways to avoid this. Either, the clo=
sure that the <code>iter</code> method receives can return an arbitrary val=
ue which forces the optimizer to consider the result used and ensures it ca=
nnot remove the computation entirely. This could be done for the example ab=
ove by adjusting the <code>b.iter</code> call to</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">b.iter(|| {
      <span class=3D"co">// note lack of `;` (could also use an explicit `r=
eturn`).</span>
      (<span class=3D"dv">0.</span>.<span class=3D"dv">1000</span>).fold(<s=
pan class=3D"dv">0</span>, |old, new| old ^ new)
  });</code></pre></div>
  <p>Or, the other option is to call the generic <code>test::black_box</cod=
e> function, which is an opaque =E2=80=9Cblack box=E2=80=9D to the optimize=
r and so forces it to consider any argument as used.</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(test)]
 =20
  <span class=3D"kw">extern</span> crate test;
 =20
  b.iter(|| {
      <span class=3D"kw">let</span> n =3D test::black_box(<span class=3D"dv=
">1000</span>);
 =20
      (<span class=3D"dv">0.</span>.n).fold(<span class=3D"dv">0</span>, |a=
, b| a ^ b)
  })</code></pre></div>
  <p>Neither of these read or modify the value, and are very cheap for smal=
l values. Larger values can be passed indirectly to reduce overhead (e.g. <=
code>black_box(&amp;huge_struct)</code>).</p>
  <p>Performing either of the above changes gives the following benchmarkin=
g results</p>
  <pre><code>running 1 test
  test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)
 =20
  test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured</code></pre>
  <p>However, the optimizer can still modify a testcase in an undesirable m=
anner even when using either of the above.</p>
  <h2 id=3D"sec--box-syntax-and-patterns">Box Syntax and Patterns</h2>
  <p>Currently the only stable way to create a <code>Box</code> is via the =
<code>Box::new</code> method. Also it is not possible in stable Rust to des=
tructure a <code>Box</code> in a match pattern. The unstable <code>box</cod=
e> keyword can be used to both create and destructure a <code>Box</code>. A=
n example usage would be:</p>
  <pre><code>#![feature(box_syntax, box_patterns)]
 =20
  fn main() {
      let b =3D Some(box 5);
      match b {
          Some(box n) if n &lt; 0 =3D&gt; {
              println!("Box contains negative number {}", n);
          },
          Some(box n) if n &gt;=3D 0 =3D&gt; {
              println!("Box contains non-negative number {}", n);
          },
          None =3D&gt; {
              println!("No box");
          },
          _ =3D&gt; unreachable!()
      }
  }</code></pre>
  <p>Note that these features are currently hidden behind the <code>box_syn=
tax</code> (box creation) and <code>box_patterns</code> (destructuring and =
pattern matching) gates because the syntax may still change in the future.<=
/p>
  <h3 id=3D"returning-pointers">Returning Pointers</h3>
  <p>In many languages with pointers, you=E2=80=99d return a pointer from a=
 function so as to avoid copying a large data structure. For example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">struct</span> BigStruct {
      one: <span class=3D"kw">i32</span>,
      two: <span class=3D"kw">i32</span>,
      <span class=3D"co">// etc</span>
      one_hundred: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> foo(x: Box&lt;BigStruct&gt;) -&gt; Box&lt;Bi=
gStruct&gt; {
      Box::new(*x)
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D Box::new(BigStruct {
          one: <span class=3D"dv">1</span>,
          two: <span class=3D"dv">2</span>,
          one_hundred: <span class=3D"dv">100</span>,
      });
 =20
      <span class=3D"kw">let</span> y =3D foo(x);
  }</code></pre></div>
  <p>The idea is that by passing around a box, you=E2=80=99re only copying =
a pointer, rather than the hundred <code>int</code>s that make up the <code=
>BigStruct</code>.</p>
  <p>This is an antipattern in Rust. Instead, write this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(box_syntax)]
 =20
  <span class=3D"kw">struct</span> BigStruct {
      one: <span class=3D"kw">i32</span>,
      two: <span class=3D"kw">i32</span>,
      <span class=3D"co">// etc</span>
      one_hundred: <span class=3D"kw">i32</span>,
  }
 =20
  <span class=3D"kw">fn</span> foo(x: Box&lt;BigStruct&gt;) -&gt; BigStruct=
 {
      *x
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> x =3D Box::new(BigStruct {
          one: <span class=3D"dv">1</span>,
          two: <span class=3D"dv">2</span>,
          one_hundred: <span class=3D"dv">100</span>,
      });
 =20
      <span class=3D"kw">let</span> y: Box&lt;BigStruct&gt; =3D box foo(x);
  }</code></pre></div>
  <p>This gives you flexibility without sacrificing performance.</p>
  <p>You may think that this gives us terrible performance: return a value =
and then immediately box it up ?! Isn=E2=80=99t this pattern the worst of b=
oth worlds? Rust is smarter than that. There is no copy in this code. <code=
>main</code> allocates enough room for the <code>box</code>, passes a point=
er to that memory into <code>foo</code> as <code>x</code>, and then <code>f=
oo</code> writes the value straight into the <code>Box&lt;T&gt;</code>.</p>
  <p>This is important enough that it bears repeating: pointers are not for=
 optimizing returning values from your code. Allow the caller to choose how=
 they want to use your output.</p>
  <h2 id=3D"sec--slice-patterns">Slice Patterns</h2>
  <p>If you want to match against a slice or array, you can use <code>&amp;=
</code> with the <code>slice_patterns</code> feature:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(slice_patterns)]
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> v =3D <span class=3D"ot">vec!</span>[<s=
pan class=3D"st">"match_this"</span>, <span class=3D"st">"1"</span>];
 =20
      <span class=3D"kw">match</span> &amp;v[..] {
          [<span class=3D"st">"match_this"</span>, second] =3D&gt; <span cl=
ass=3D"ot">println!</span>(<span class=3D"st">"The second element is {}"</s=
pan>, second),
          _ =3D&gt; {},
      }
  }</code></pre></div>
  <p>The <code>advanced_slice_patterns</code> gate lets you use <code>..</c=
ode> to indicate any number of elements inside a pattern matching a slice. =
This wildcard can only be used once for a given array. If there=E2=80=99s a=
n identifier before the <code>..</code>, the result of the slice will be bo=
und to that name. For example:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(advanced_slice_patterns, slice_patterns)]
 =20
  <span class=3D"kw">fn</span> is_symmetric(list: &amp;[<span class=3D"kw">=
u32</span>]) -&gt; <span class=3D"kw">bool</span> {
      <span class=3D"kw">match</span> list {
          [] | [_] =3D&gt; <span class=3D"kw">true</span>,
          [x, inside.., y] <span class=3D"kw">if</span> x =3D=3D y =3D&gt; =
is_symmetric(inside),
          _ =3D&gt; <span class=3D"kw">false</span>
      }
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"kw">let</span> sym =3D &amp;[<span class=3D"dv">0</spa=
n>, <span class=3D"dv">1</span>, <span class=3D"dv">4</span>, <span class=
=3D"dv">2</span>, <span class=3D"dv">4</span>, <span class=3D"dv">1</span>,=
 <span class=3D"dv">0</span>];
      <span class=3D"ot">assert!</span>(is_symmetric(sym));
 =20
      <span class=3D"kw">let</span> not_sym =3D &amp;[<span class=3D"dv">0<=
/span>, <span class=3D"dv">1</span>, <span class=3D"dv">7</span>, <span cla=
ss=3D"dv">2</span>, <span class=3D"dv">4</span>, <span class=3D"dv">1</span=
>, <span class=3D"dv">0</span>];
      <span class=3D"ot">assert!</span>(!is_symmetric(not_sym));
  }</code></pre></div>
  <h2 id=3D"sec--associated-constants">Associated Constants</h2>
  <p>With the <code>associated_consts</code> feature, you can define consta=
nts like this:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(associated_consts)]
 =20
  <span class=3D"kw">trait</span> Foo {
      const ID: <span class=3D"kw">i32</span>;
  }
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> <span cl=
ass=3D"kw">i32</span> {
      const ID: <span class=3D"kw">i32</span> =3D <span class=3D"dv">1</spa=
n>;
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">1</span>, <sp=
an class=3D"kw">i32</span>::ID);
  }</code></pre></div>
  <p>Any implementor of <code>Foo</code> will have to define <code>ID</code=
>. Without the definition:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(associated_consts)]
 =20
  <span class=3D"kw">trait</span> Foo {
      const ID: <span class=3D"kw">i32</span>;
  }
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> <span cl=
ass=3D"kw">i32</span> {
  }</code></pre></div>
  <p>gives</p>
  <pre><code>error: not all trait items implemented, missing: `ID` [E0046]
       impl Foo for i32 {
       }</code></pre>
  <p>A default value can be implemented as well:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(associated_consts)]
 =20
  <span class=3D"kw">trait</span> Foo {
      const ID: <span class=3D"kw">i32</span> =3D <span class=3D"dv">1</spa=
n>;
  }
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> <span cl=
ass=3D"kw">i32</span> {
  }
 =20
  <span class=3D"kw">impl</span> Foo <span class=3D"kw">for</span> <span cl=
ass=3D"kw">i64</span> {
      const ID: <span class=3D"kw">i32</span> =3D <span class=3D"dv">5</spa=
n>;
  }
 =20
  <span class=3D"kw">fn</span> main() {
      <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">1</span>, <sp=
an class=3D"kw">i32</span>::ID);
      <span class=3D"ot">assert_eq!</span>(<span class=3D"dv">5</span>, <sp=
an class=3D"kw">i64</span>::ID);
  }</code></pre></div>
  <p>As you can see, when implementing <code>Foo</code>, you can leave it u=
nimplemented, as with <code>i32</code>. It will then use the default value.=
 But, as in <code>i64</code>, we can also add our own definition.</p>
  <p>Associated constants don=E2=80=99t have to be associated with a trait.=
 An <code>impl</code> block for a <code>struct</code> works fine too:</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust">#![feature(associated_consts)]
 =20
  <span class=3D"kw">struct</span> Foo;
 =20
  <span class=3D"kw">impl</span> Foo {
      <span class=3D"kw">pub</span> const FOO: <span class=3D"kw">u32</span=
> =3D <span class=3D"dv">3</span>;
  }</code></pre></div>
  <h1 id=3D"sec--glossary">Glossary</h1>
  <p>Not every Rustacean has a background in systems programming, nor in co=
mputer science, so we=E2=80=99ve added explanations of terms that might be =
unfamiliar.</p>
  <h5 id=3D"arity">Arity</h5>
  <p>Arity refers to the number of arguments a function or operation takes.=
</p>
  <div class=3D"sourceCode"><pre class=3D"sourceCode rust"><code class=3D"s=
ourceCode rust"><span class=3D"kw">let</span> x =3D (<span class=3D"dv">2</=
span>, <span class=3D"dv">3</span>);
  <span class=3D"kw">let</span> y =3D (<span class=3D"dv">4</span>, <span c=
lass=3D"dv">6</span>);
  <span class=3D"kw">let</span> z =3D (<span class=3D"dv">8</span>, <span c=
lass=3D"dv">2</span>, <span class=3D"dv">6</span>);</code></pre></div>
  <p>In the example above <code>x</code> and <code>y</code> have arity 2. <=
code>z</code> has arity 3.</p>
  <h5 id=3D"abstract-syntax-tree">Abstract Syntax Tree</h5>
  <p>When a compiler is compiling your program, it does a number of differe=
nt things. One of the things that it does is turn the text of your program =
into an =E2=80=98abstract syntax tree=E2=80=99, or=E2=80=98AST=E2=80=99. Th=
is tree is a representation of the structure of your program. For example, =
<code>2 + 3</code> can be turned into a tree:</p>
  <pre><code>  +
   / \
  2   3</code></pre>
  <p>And <code>2 + (3 * 4)</code> would look like this:</p>
  <pre><code>  +
   / \
  2   *
     / \
    3   4</code></pre>
  <h1 id=3D"sec--academic-research">Academic Research</h1>
  <p>An incomplete list of papers that have had some influence in Rust.</p>
  <p>Recommended for inspiration and a better understanding of Rust=E2=80=
=99s background.</p>
  <h5 id=3D"type-system">Type system</h5>
  <ul>
  <li><a href=3D"http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handout=
s/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
  <li><a href=3D"http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe ma=
nual memory management in Cyclone</a></li>
  <li><a href=3D"http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz">Ty=
peclasses: making ad-hoc polymorphism less ad hoc</a></li>
  <li><a href=3D"https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.=
pdf">Macros that work together</a></li>
  <li><a href=3D"http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Trai=
ts: composable units of behavior</a></li>
  <li><a href=3D"http://www.cs.uwm.edu/faculty/boyland/papers/unique-prepri=
nt.ps">Alias burying</a> - We tried something similar and abandoned it.</li=
>
  <li><a href=3D"http://www.computingscience.nl/research/techreps/repo/CS-2=
002/2002-048.pdf">External uniqueness is unique enough</a></li>
  <li><a href=3D"https://research.microsoft.com/pubs/170528/msr-tr-2012-79.=
pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
  <li><a href=3D"http://www.cs.ucla.edu/~palsberg/tba/papers/tofte-talpin-i=
andc97.pdf">Region Based Memory Management</a></li>
  </ul>
  <h5 id=3D"concurrency">Concurrency</h5>
  <ul>
  <li><a href=3D"https://research.microsoft.com/pubs/69431/osr2007_rethinki=
ngsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
  <li><a href=3D"https://research.microsoft.com/pubs/67482/singsharp.pdf">L=
anguage support for fast and reliable message passing in singularity OS</a>=
</li>
  <li><a href=3D"http://supertech.csail.mit.edu/papers/steal.pdf">Schedulin=
g multithreaded computations by work stealing</a></li>
  <li><a href=3D"http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/pa=
pers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocess=
ors</a></li>
  <li><a href=3D"http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_s=
paa00.pdf">The data locality of work stealing</a></li>
  <li><a href=3D"http://citeseerx.ist.psu.edu/viewdoc/download?doi=3D10.1.1=
.170.1097&amp;rep=3Drep1&amp;type=3Dpdf">Dynamic circular work stealing deq=
ue</a> - The Chase/Lev deque</li>
  <li><a href=3D"http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-fi=
rst and help-first scheduling policies for async-finish task parallelism</a=
> - More general than fully-strict work stealing</li>
  <li><a href=3D"http://www.coopsoft.com/ar/CalamityArticle.html">A Java fo=
rk/join calamity</a> - critique of Java=E2=80=99s fork/join library, partic=
ularly its application of work stealing to non-strict computation</li>
  <li><a href=3D"http://www.ece.rutgers.edu/%7Eparashar/Classes/ece572-pape=
rs/05/ps-ousterhout.pdf">Scheduling techniques for concurrent systems</a></=
li>
  <li><a href=3D"http://www.blagodurov.net/files/a8-blagodurov.pdf">Content=
ion aware scheduling</a></li>
  <li><a href=3D"http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/p=
apers/TR-12-1.pdf">Balanced work stealing for time-sharing multicores</a></=
li>
  <li><a href=3D"http://www.upcrc.illinois.edu/workshops/paraplop10/papers/=
paraplop10_submission_8.pdf">Three layer cake</a></li>
  <li><a href=3D"http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pd=
f">Non-blocking steal-half work queues</a></li>
  <li><a href=3D"http://www.mpi-sws.org/~turon/reagents.pdf">Reagents: expr=
essing and composing fine-grained concurrency</a></li>
  <li><a href=3D"https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_sync=
h.pdf">Algorithms for scalable synchronization of shared-memory multiproces=
sors</a></li>
  </ul>
  <h5 id=3D"others">Others</h5>
  <ul>
  <li><a href=3D"https://www.usenix.org/legacy/events/hotos03/tech/full_pap=
ers/candea/candea.pdf">Crash-only software</a></li>
  <li><a href=3D"http://people.cs.umass.edu/~emery/pubs/berger-pldi2001.pdf=
">Composing High-Performance Memory Allocators</a></li>
  <li><a href=3D"http://people.cs.umass.edu/~emery/pubs/berger-oopsla2002.p=
df">Reconsidering Custom Memory Allocation</a></li>
  </ul>
  <h5 id=3D"papers-about-rust">Papers <em>about</em> Rust</h5>
  <ul>
  <li><a href=3D"http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf">GPU =
programming in Rust</a></li>
  <li><a href=3D"https://www.usenix.org/conference/hotpar12/parallel-closur=
es-new-twist-old-idea">Parallel closures: a new twist on an old idea</a> - =
not exactly about rust, but by nmatsakis</li>
  </ul>
  <section class=3D"footnotes">
  <hr>
  <ol>
  <li id=3D"fn1"><p>The actual definition of <code>vec!</code> in libcollec=
tions differs from the one presented here, for reasons of efficiency and re=
usability.<a href=3D"https://killercup.github.io/trpl-ebook/trpl-2015-05-13=
.html#fnref1">=E2=86=A9</a></p></li>
  </ol>
  </section>
</article>



<div id=3D"monica-content-root" class=3D"monica-widget" data-darkreader-mod=
e=3D"dynamic" data-darkreader-scheme=3D"dark"><meta name=3D"darkreader" con=
tent=3D"13da0a7888674f0db39d752edbdc9cc2"><template shadowmode=3D"open"><di=
v><div class=3D"_monica-dark root-container-UmvGjM"><div class=3D"content-r=
oot-rb-FdpxmT"></div><div class=3D"content-root-WCIiJJ"><div class=3D"sideb=
ar-entry-btn-hvXPZj sidebar-entry-btn-right-doBuCO" style=3D"visibility: vi=
sible; bottom: 61.8px;"><div class=3D"float-btn-box-yen8CN"><div class=3D"f=
loat-btn-dmQyFz large-width-anF0uz"><img src=3D"chrome-extension://ofpnmcal=
abcbjgholdjcjblkibolbppb/static/global/src/static/monicaLogo.png" class=3D"=
logo-img-drxdFH" style=3D"width: 24px; height: 24px; border-radius: 4px;"><=
span class=3D"shortcut--0OZjH" style=3D"opacity: 0;">Ctrl+M</span></div></d=
iv><div class=3D"extra-tools-box-Q-raLQ toolbar-AlHpmQ" style=3D"bottom: -1=
2px;"><div class=3D"trigger-area-rZm0LF"></div><div class=3D"top-t5av-O"></=
div><div class=3D"bot-bqr602"></div></div></div><div class=3D"dialog-root-Z=
bJNQk"></div><div class=3D"reading-summary-status-bar-yFqhHz"></div></div><=
/div></div></template></div></body></html>
------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-0b32818c-8c61-49c0-98aa-bc20aa5b3500@mhtml.blink

@charset "utf-8";
=0A
------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-e9ba41b3-219c-440e-ad30-388f4d34c3ce@mhtml.blink

@charset "utf-8";
=0A
------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-f7d6d5fc-044b-4592-9e4f-f9dfe718106d@mhtml.blink

@charset "utf-8";

[data-darkreader-inline-bgcolor] { background-color: var(--darkreader-inlin=
e-bgcolor) !important; }

[data-darkreader-inline-bgimage] { background-image: var(--darkreader-inlin=
e-bgimage) !important; }

[data-darkreader-inline-border] { border-color: var(--darkreader-inline-bor=
der) !important; }

[data-darkreader-inline-border-bottom] { border-bottom-color: var(--darkrea=
der-inline-border-bottom) !important; }

[data-darkreader-inline-border-left] { border-left-color: var(--darkreader-=
inline-border-left) !important; }

[data-darkreader-inline-border-right] { border-right-color: var(--darkreade=
r-inline-border-right) !important; }

[data-darkreader-inline-border-top] { border-top-color: var(--darkreader-in=
line-border-top) !important; }

[data-darkreader-inline-boxshadow] { box-shadow: var(--darkreader-inline-bo=
xshadow) !important; }

[data-darkreader-inline-color] { color: var(--darkreader-inline-color) !imp=
ortant; }

[data-darkreader-inline-fill] { fill: var(--darkreader-inline-fill) !import=
ant; }

[data-darkreader-inline-stroke] { stroke: var(--darkreader-inline-stroke) !=
important; }

[data-darkreader-inline-outline] { outline-color: var(--darkreader-inline-o=
utline) !important; }

[data-darkreader-inline-stopcolor] { stop-color: var(--darkreader-inline-st=
opcolor) !important; }
------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-310c9226-4456-4e42-98b5-aef68f03c5de@mhtml.blink

@charset "utf-8";

:root { --darkreader-neutral-background: #212222; --darkreader-neutral-text=
: #eae3d9; --darkreader-selection-background: #165aaa; --darkreader-selecti=
on-text: #fbf5ec; }
------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-76122411-25f7-4e75-b2d6-c955bbfb8df9@mhtml.blink

@charset "utf-8";

:root { }
------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-e9acce45-c998-4616-9b25-1b2cc40c553b@mhtml.blink

@charset "utf-8";

div.sourceCode { overflow-x: auto; }

table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode { margin: 0p=
x; padding: 0px; vertical-align: baseline; border: none; }

table.sourceCode { width: 100%; line-height: 100%; background-color: rgb(24=
8, 248, 248); }

td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; =
color: rgb(170, 170, 170); border-right: 1px solid rgb(170, 170, 170); }

td.sourceCode { padding-left: 5px; }

pre, code { background-color: rgb(248, 248, 248); }

code > span.kw { color: rgb(32, 74, 135); font-weight: bold; }

code > span.dt { color: rgb(32, 74, 135); }

code > span.dv { color: rgb(0, 0, 207); }

code > span.bn { color: rgb(0, 0, 207); }

code > span.fl { color: rgb(0, 0, 207); }

code > span.ch { color: rgb(78, 154, 6); }

code > span.st { color: rgb(78, 154, 6); }

code > span.co { color: rgb(143, 89, 2); font-style: italic; }

code > span.ot { color: rgb(143, 89, 2); }

code > span.al { color: rgb(239, 41, 41); }

code > span.fu { color: rgb(0, 0, 0); }

code > span.er { font-weight: bold; }
------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-77aa0ce5-7c2e-4dee-8b26-1617090c7abd@mhtml.blink

@charset "utf-8";

@font-face { font-family: monica-ext-font_YIBBBFG; src: url("chrome-extensi=
on://ofpnmcalabcbjgholdjcjblkibolbppb/static/fonts/Hind-Light.otf"); font-w=
eight: 300; font-display: swap; }

@font-face { font-family: monica-ext-font_YIBBBFG; src: url("chrome-extensi=
on://ofpnmcalabcbjgholdjcjblkibolbppb/static/fonts/Hind-Regular.otf"); font=
-weight: 400; font-display: swap; }

@font-face { font-family: monica-ext-font_YIBBBFG; src: url("chrome-extensi=
on://ofpnmcalabcbjgholdjcjblkibolbppb/static/fonts/Hind-Medium.otf"); font-=
weight: 500; font-display: swap; }

@font-face { font-family: monica-ext-font_YIBBBFG; src: url("chrome-extensi=
on://ofpnmcalabcbjgholdjcjblkibolbppb/static/fonts/Hind-SemiBold.otf"); fon=
t-weight: 600; font-display: swap; }
------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: application/octet-stream
Content-Transfer-Encoding: base64
Content-Location: chrome-extension://ofpnmcalabcbjgholdjcjblkibolbppb/static/fonts/Hind-Medium.otf

T1RUTwAKAIAAAwAgQ0ZGIKAm7IkAAAhsAAA80kdTVUKqfcPRAABFQAAAAkRPUy8yWYTxoQAAARAA
AABgY21hcDp0KeEAAAY4AAACEmhlYWQh0ydQAAAArAAAADZoaGVhCbkGGAAAAOQAAAAkaG10eLiS
OikAAEeEAAAFXG1heHABV1AAAAABCAAAAAZuYW1leIahbgAAAXAAAATGcG9zdP+4ADIAAAhMAAAA
IAABAAAAAwAAJuJbMV8PPPUAAwPoAAAAAN6d/u0AAAAA3p3k0P+L/v8F8wOxAAAABgACAAAAAAAA
AAEAAAPe/vIAWgZw/4v/XgXzAAEAAAAAAAAAAAAAAAAAAAFXAABQAAFXAAAABAIMAfQABQAAArwC
igAAAIwCvAKKAAAB3QAyAPoAAAAAAAAAAAAAAACAAAAnAAAAAgAAAAAAAAAASVRGTwDAAAD7BAPe
/vIAWgPeAQ4gAACTAAAAAAH7AqIAAAAgAAMAAAARANIAAwABBAkAAAB6AAAAAwABBAkAAQAWAHoA
AwABBAkAAgAOAJAAAwABBAkAAwAsAJ4AAwABBAkABAAWAHoAAwABBAkABQAaAMoAAwABBAkABgAW
AOQAAwABBAkABwBWAPoAAwABBAkACAAmAVAAAwABBAkACQBAAXYAAwABBAkACgBGAbYAAwABBAkA
CwA6AfwAAwABBAkADABWAjYAAwABBAkADQEgAowAAwABBAkADgA0A6wAAwABBAkAEAAIA+AAAwAB
BAkAEQAMA+gAQwBvAHAAeQByAGkAZwBoAHQAIAAyADAAMQA0AC0AMgAwADIAMgAgAEkAbgBkAGkA
YQBuACAAVAB5AHAAZQAgAEYAbwB1AG4AZAByAHkALgAgAEEAbABsACAAcgBpAGcAaAB0AHMAIABy
AGUAcwBlAHIAdgBlAGQALgBIAGkAbgBkACAATQBlAGQAaQB1AG0AUgBlAGcAdQBsAGEAcgAzAC4A
MAAwADAAOwBJAFQARgBPADsASABpAG4AZAAtAE0AZQBkAGkAdQBtAFYAZQByAHMAaQBvAG4AIAAz
AC4AMAAwADAASABpAG4AZAAtAE0AZQBkAGkAdQBtAEgAaQBuAGQAIABpAHMAIABhACAAdAByAGEA
ZABlAG0AYQByAGsAIABvAGYAIABJAG4AZABpAGEAbgAgAFQAeQBwAGUAIABGAG8AdQBuAGQAcgB5
AC4ASQBuAGQAaQBhAG4AIABUAHkAcABlACAARgBvAHUAbgBkAHIAeQBNAGEAbgB1AHMAaABpACAA
UABhAHIAaQBrAGgALAAgAFMAYQB0AHkAYQAgAFIAYQBqAHAAdQByAG8AaABpAHQARgBvAG4AdAAg
AHIAZQAtAGUAbgBnAGkAbgBlAGUAcgBlAGQAIABiAHkAIABSAGEAaAB1AGwAIABHAGEAagBqAGEA
cgAuAGgAdAB0AHAAcwA6AC8ALwBpAG4AZABpAGEAbgB0AHkAcABlAGYAbwB1AG4AZAByAHkALgBj
AG8AbQBoAHQAdABwAHMAOgAvAC8AdwB3AHcALgBpAG4AZABpAGEAbgB0AHkAcABlAGYAbwB1AG4A
ZAByAHkALgBjAG8AbQAvAGQAZQBzAGkAZwBuAGUAcgBzAFQAaABpAHMAIABGAG8AbgB0ACAAUwBv
AGYAdAB3AGEAcgBlACAAaQBzACAAbABpAGMAZQBuAHMAZQBkACAAdQBuAGQAZQByACAAdABoAGUA
IABTAEkATAAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAsACAAVgBlAHIAcwBp
AG8AbgAgADEALgAxAC4AIABUAGgAaQBzACAAbABpAGMAZQBuAHMAZQAgAGkAcwAgAGEAdgBhAGkA
bABhAGIAbABlACAAdwBpAHQAaAAgAGEAIABGAEEAUQAgAGEAdAA6ACAAaAB0AHQAcAA6AC8ALwBz
AGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAGgAdAB0AHAAOgAvAC8AcwBjAHIA
aQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATABIAGkAbgBkAE0AZQBkAGkAdQBtAAAAAAAC
AAAAAwAAABQAAwABAAAAFAAEAf4AAAB4AEAABQA4AAAADQAgAH4BBwETARsBHwEjASsBMQE3AT4B
SAFNAVsBZQFrAXMBfgGSAhsCvALHAskC3QPAIAsgFCAaIB4gIiAmIDAgOiBEIKggrCC6IL0hEyEi
ISYhLiICIgYiDyISIhUiGiIeIisiSCJgImUlyiXM+P/7BP//AAAAAAANACAAIQCgAQwBFgEeASIB
KgEuATYBOQFBAUwBUAFeAWoBbgF4AZICGAK8AsYCyQLYA8AgCyATIBggHCAgICYgMCA5IEQgqCCs
ILkgvSETISIhJiEuIgIiBiIPIhEiFSIZIh4iKyJIImAiZCXKJcz4//sA//8AAf/1/+P/6f/I/8T/
wv/A/77/uP+2/7L/sf+v/6z/qv+o/6T/ov+e/4v/Bv1K/lz+W/5N/Wvf/OEZ4RbhFeEU4RHhCOEA
4PffXOCQAADggeAs4B7gG+AU30HfPt823zXfM98w3y3fId8F3u7e69uH2jwHCgAAAAEAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAA
BQE9AVQBUgFTAVUBVgAAAAMAAAAAAAD/tQAyAAAAAAAAAAAAAAAAAAAAAAAAAAABAAQCAAEBAQxI
aW5kLU1lZGl1bQABAQE8+I4A+I8B+JAMAPiRAviSA/gXBEAMA/sJ+5UdAAAF8/pFBR0AAAVTDx0A
AAbjEJYdAAAx9hIdAAAG5REAeAIAAQAFAAcADAAXACQAMgA+AEEASABSAFcAXgBlAGsAcQB4AH8A
hQCLAJEAlwCdAKMAqQCvALYAvQDHANEA2ADfAOUA6wDxAPcBAwEPARYBHQEkASsBNQFBAU0BUwFZ
AWUBcQF3AX0BgwGJAZUBoQGnAa0BtAG7AcgB1QHbAeEB7QH5Af8CBQILAhECGQIhAikCMQI3Aj0C
RAJLAlACVQJiAm8CdgJ9AoMCiQKTAp0CqQK1AsECzQLWAtgC3ALnAuwC8QL0Av0DCAMRAxgDIQMu
AzwDQwNLA1MDXgNmA28DewOCA4UDigOPA5IDvQP6BAUECU5VTExDUnJ1cGVlaW5kaWFucnVwZWVh
cG9zdHJvcGhlbW9kemVyb3dpZHRoc3BhY2VjaXJjbGVkb3R0ZWRJVEZuYnNwYWNlc29mdGh5cGhl
bm1pY3JvQW1hY3JvbmFtYWNyb25BYnJldmVhYnJldmVBb2dvbmVrYW9nb25la0NhY3V0ZWNhY3V0
ZUNjYXJvbmNjYXJvbkRjYXJvbmRjYXJvbkRjcm9hdGRjcm9hdEVtYWNyb25lbWFjcm9uRWRvdGFj
Y2VudGVkb3RhY2NlbnRFb2dvbmVrZW9nb25la0VjYXJvbmVjYXJvbkdicmV2ZWdicmV2ZUdjb21t
YWFjY2VudGdjb21tYWFjY2VudEltYWNyb25pbWFjcm9uSW9nb25la2lvZ29uZWtJZG90YWNjZW50
S2NvbW1hYWNjZW50a2NvbW1hYWNjZW50TGFjdXRlbGFjdXRlTGNvbW1hYWNjZW50bGNvbW1hYWNj
ZW50TGNhcm9ubGNhcm9uTmFjdXRlbmFjdXRlTmNvbW1hYWNjZW50bmNvbW1hYWNjZW50TmNhcm9u
bmNhcm9uT21hY3Jvbm9tYWNyb25PaHVuZ2FydW1sYXV0b2h1bmdhcnVtbGF1dFJhY3V0ZXJhY3V0
ZVJjb21tYWFjY2VudHJjb21tYWFjY2VudFJjYXJvbnJjYXJvblNhY3V0ZXNhY3V0ZVNjZWRpbGxh
c2NlZGlsbGFUY2VkaWxsYXRjZWRpbGxhVGNhcm9udGNhcm9uVW1hY3JvbnVtYWNyb25VcmluZ3Vy
aW5nVWh1bmdhcnVtbGF1dHVodW5nYXJ1bWxhdXRVb2dvbmVrdW9nb25la1phY3V0ZXphY3V0ZVpk
b3RhY2NlbnR6ZG90YWNjZW50U2NvbW1hYWNjZW50c2NvbW1hYWNjZW50VGNvbW1hYWNjZW50dGNv
bW1hYWNjZW50bWFjcm9ubW9kcGlFdXJvdHVya2lzaGxpcmFydWJsZWxpdHJlT2htZXN0aW1hdGVk
cGFydGlhbGRpZmZpbmNyZW1lbnRwcm9kdWN0c3VtbWF0aW9uZGl2aXNpb25zbGFzaGJ1bGxldG9w
ZXJhdG9ycmFkaWNhbGluZmluaXR5aW50ZWdyYWxhcHByb3hlcXVhbG5vdGVxdWFsbGVzc2VxdWFs
Z3JlYXRlcmVxdWFsbG96ZW5nZWZfZmZfZl9pZl9mX2wzLjBIaW5kIGlzIGEgdHJhZGVtYXJrIG9m
IEluZGlhbiBUeXBlIEZvdW5kcnkuQ29weXJpZ2h0IDIwMTQtMjAyMiBJbmRpYW4gVHlwZSBGb3Vu
ZHJ5LiBBbGwgcmlnaHRzIHJlc2VydmVkLkhpbmQgTWVkaXVtSGluZAAAAQGHAQABAAGJBQACBQBo
AAAJNwB8AABCHQGPAABgAgBnAABkAACgAABmAACDAACqAACLAABqAACXAAGQAAClAACAAAChAACc
AACkAACpAAB9AAGRAABzAAByAACFAACWAACPAAB4AACeAACbAACjAAB7AACuAACrAQCwAACtAACv
AACKAACxAAC1AACyAgC5AAC2AgCaAAC6AAC+AAC7AQC/AAC9AACoAACNAADEAADBAgDFAACdAACV
AADLAADIAQDNAADKAADMAACQAADOAADSAADPAgDWAADTAgCnAADXAADbAADYAQDcAADaAACfAACT
AADhAADeAgDiAACiAADjAAGSHgCRAAGxBwCMAACSAAG5CQCOAACUAAHDCQDAAADdAAHNCwDGAAHZ
AwDHAADkAABlAAHdAwB+AACIAAHhAACBAQCEAACHAAB/AACGAAHiAABvAACJAABBAAAIAAB1AABp
AAB3AAB2AABwAQB0AAB5AQBrAQBjAAHjAwCZAAHnBQCmAAHtCQBtAQH3AgEAAVcCAAEAGAAbAB4A
IQBtAK8AswC2AZkB3QH+Ag0CZwLDAxADmAOdA8wD/QRpBIMEiASMBJQEowTdBPMFKQV3BZ0F2QYy
BkgGqgcBBw8HKQdLB2AHgwfKCGkIlAjZCN0JAgkJCR0JIgk5CUMJZQlpCW0JyAnNCdQJ/go6Cj4K
QgpGCk0KegrZCxILGQsgCzQLRwtcC3QLgAuIC44LygvOC9YL3AwCDAgMLQw0DFkMeQyBDL8Mwwz7
DQYNRg1LDVANVQ1cDYYN4Q4SDhgOHw6NDpkPBw8xDzQPVg+jD/MQWRCbELMRPhFFEcUSDhI3EkgS
TBKrEq4S2hL/EwYTRhNOE3kTmROiE6kTtxPtFBAUHRQnFHsUwxTPFNsU5xT1FQMVERU5FUIVTRVY
FWMVbxV5FYQVkhWeFaIVsBW8FcgV1BXiFfAWHhaEFo4WmBaiFq4WuRbnFzUXPxdJF1MXXxdqF3cX
9xgAGAsYFhggGC0YNRhAGEoYVBi4GMUYzxjZGOYY8xj/GTgZpRmxGbwZxhnSGd0Z6Rn1GgMaDhoc
GigaYxq6GsMa0BrYGuIbFRsrGy8bZRtxG3wbiRuWG6Yb0RvbG+Yb9BwBHAscIRwuHDccThxlHHEc
eRyCHKYcsRy7HMMczxzdHOsdER0wHTodQx1NHVUdXh1mHXQdfx2NHZkd4B5bHmQebh53HoAeiB6R
HpwepR6uHrcewh7MHtQe3R7qHvkfBh8gHy0fOR9GH1IfjR+tH7ofxR/QH90f6h/1IAAgVSBeIGkg
cSB6IIIgiiCNIJUgnSCkILcgvyDHIOkg9SECIRQhGCEpIUohaSGGIZ4hxiHdIe8iZSJ5Io0ikiL8
IycjYSPJJCckciTEJRQlRCVuJZMlnyWkJbQl8CZVJpEmsCbmJwonLydzJ5wnvyf4KC0oX/dg9z8W
+C75UfwuBs1OFfer/Nf7qwYO/LkO/LkO+8MO+AFSCvhmpBWYcF2UVBsrPFgvOchlxXMfy3C6eF0a
aW9zVVdVnqNkHi4He6vEfcgb9wDRwOfaTrBKqB9Wo1iduBqtp6O7vLt/eqgeDojK+DsV94IGTYFd
aDQbLDkG91T7iAX3EAb7W/eI9xeP2dCX9Rnu2yMGgq55q2+jCPcz2/xJO+gG27dmVZsf+30GDvvr
lgr8uQ73A/eV+MRkCqWdnaWleZ1xaQr3EnwVc553paSdn6OleZ5ycXh4cR77iG8VcZ14paWdnqWk
eZ5xcXl4ch7352MVcp54pKWdnqSleZ5xcnh4cR78OUUVcp94paOfnqSkd55zcXd4ch74a1utCqV4
nXJpCvx4PRVynnmkpZ2dpKV5nnFyeHhxHvhuUxVynnilo56epKV4nnNxeHhxHvw6T60KpHiecnF5
eHIe9/FlFXGeeaSkn52lpHeecnJ4eHIe+4xmFXGed6Wknp+lo3ifcnF4d3Me9xN7ZAqlnp2lpXid
cWkKDvrf9ycW91j5DjgK+00V91j3TTgK/Q4V91j5DjgK+00V91j3TTgK/Q4V91j5DjgK+00V91j3
TftYBvwuBPdY9037WAYO+7Pe92oV6/hgKwZ2/PoVZKhusrGqqLKxbKplZG5sZR4O+3evCvcr+4gV
4PeINgYO90L3DxbhBq4xCvc6Bmj7OQXiBq4xCvcV2fsFBrL3TAX3DdsjBq73OwU1Bmj7OwX7Ogau
9zsFMwZo+zsF+xY79wUGZftMBfsPPfYG8tkVsvdMBfc6BmT7TAUOYfg++RsVbZpnlGiQCPcBNiAH
+wWAO0ggGiDZXthoHtto03NIGk5baENKSKCxWB4gB7F1vX2+hggg3/YH9wKX2M73Ahr3BjS3Oa8e
RKpLpskawLav1cDHenKyHg7347v4nBUu1kDn6NbW6OdA1i4vQEAvHvc4/J0V5wb4Afk6BS4G/FH7
MRW5sbG5urFlXVxlZVxdjgreFrqxsbq5sWVcXGVlXVxlsboeDvc6+VwWZK9ftV+0qbidwY7GCC8G
iWeCa3xxTcZUv2ypCPcFvrTJ1hrzPtX7DvsHO0kgTLBYvFceImZZVDoaIvA69zTe0KOyvh6geJ94
nXoI+/X4mRXEtKm/za1hVltsYzljHlfCb7G2Gkb75BW9r6rYqB6MigWL5DfpMx5wZVp+WBswR7PK
Hw78Dq8KDvt79235VxUs+wxP+zD7Phr7O8L7MPb7Gh72BvsC9yBV9zz3JBr3Kr73OPT3HR4O+3vx
+VcVIQbz+x2/+zj7Khr7JFT7PPsC+yAe9wAG9fcawvcw9zsa9z5Q9zAs9wweDvsE91v4GxWVmZKY
jpiPf5F9lX3EPRjLulPagJqAlYCSGYyNi40blpmMkJof56ly1y9ueYV+g4GDGZCXjpqdGuw7Kgd4
j3yQfh6BlH2TepEuqRhzP+dsBYaamIqXG5EGf4OAgYF9UT0YzFwFDprA97sV90n7Tub3TvdN5PtN
908w+0/7SQYOg/sQngr7W6QK+/ioxxU/Cg77FIQlFfAG9//5vQUmBg6HtPfdFftd4Psc9yX3Ltr3
H/da92E09xb7JvsjNPsW+2Ee7xb3OMfb0dbEO/s4+zRYNTpBU+H3NB4O+2Wb+FgV9y/qBfy37Pki
Mgf7NyoFDlavFvg34PuwBvc29w/z9xb3ERr3GCvN+whOSHVqYB4qB664yKS+G9i6YT/7C/sx+yf7
IiMfDj33RPgJFWM3swbvu2VNT15eOk5WmaVbHysHdbfPf8Ib9yXX3fPbXMBBnR/Rp67F0RrqQdr7
H1ZVeXlsHiwHoa7An7obz7ltSUhOZ0YfDoj3HfeCFfdZ9/kF+/kHTvg1Fft//DUFNve8+y3t9y3n
4C/4NQcOYd73sBWcr8SdxBvZwGVFN1ZfIlVNm6JlHywHcrzLgsQb9y/k4fcV9w052PscdXSIhnQf
90D3huD75wcOd/iE92kV9xFC3vsLUFNyZWQe9w2czvH3EButqYV9ph/qB5Rwa5FnG/tS+wn7NPtq
+0fZ+xf3MfcY3er3Fx/7Z/cOFc23XD87YVNFRFDF9xyFH7Ctu6fDGw4x90cW9574zQXg/EM299sH
+5/8zQUOgLn3PRX7AulH9xL3FO3S9wTeXrxIoh7Hp7G9zhr3FibG+wP7ASdK+w9GslfIcR5IcV9W
Oxr3cPguFdyqW1VGW2dPTVir08GwvNMfjPu8FeOxWVVVY1k1N2a6vsKuweGMHw5m+Gz4AhX3OkL3
Fvsw+xo9KvsO+xfmO/XOtpyxrB77F3pPQvsNG2RllJlsHywHf6uzhLYb91Lx9x73gB/759oV2ri8
0OKyOvsJjR5ob2RzUxtDXLvcHw77v8X4GxWUCvvZBJQKDtL4GhVmqG6wsamosLFtqWVmbm1lHjz8
lp4Kh8D3uRX4UPtNBe8Hi/ue7z+sHtWr96DvixrvB/xQ+00FDprA+CcV+F3f/F0G+7oE+F3g/F0G
Dof4f/gYFfxP900FJweL958n1mseP2r7nieLGicH+E/3TQUOLL74uBWsvruavBvcsF5QPEtl+wkf
jPs1BegGjPAF25H2wPcRGvcINs77EUxSe3ZmHsr83RVkqW6xsqmosrFtqmRlbWxlHg74DfjV+DcV
inWJdop3CLdyY6JVG/sBMzD7EyLHNPPMwa7HqR9dma5c2hvm6eX3Nvd2+0b3Hfti+4f7XvtM+437
Z/cd+zz3g8HSlKbDH4/mBWtPSn9QG/sq+xzu91j3Wfcw9y/3V/c79xss+1QlYUlVX3mt0KCNrpDL
H5XyBfvJ+28V4LzJzcasZkmVHop5inuKeghHd1hnWhtWYrbPHw73A6oW9wEGwTEK96QGwPs5BfcC
Bvt6+TYF+xtiCuL3nZa5IAqVXQr7bAYOq9QW95cG9xvU2PPuS71Jlx/Mm7rH1xr2NtT7Ix77cQb3
aTYV57JgVU9hWSEfLvdjBvcO+7cV57hhSUZeZzkf+xj3aQYOw3AKDvcK97EWqAr7Ivce+1wf+2b9
Ngb3ZPjeFfco5V4K+zUfIfiHBg5o1Bb4GVcKVNQW8vet94nh+4n3cfer4fwSBg73GGwKDvbUFvL3
u/fD+7vy+TYk+7b7w/e2JAYO+7HcFvH5NiUGDvtJqaAVfaS1hKsb7NK/9xYf+IAk/IQHT25wVm1u
lpl0Hg69hwoORpoKDvfTyxbxBp/3nAWU9xGS9welGouv+wLC+zAe5vuPBdwG6fePBcD3I7j3EyAK
k/sTmPsjHqP7nAXxBk35NgX7DgYt+4oFVPsmXfscIApf9yBW9yIeMfeKBfsOBg73F3sKDvc2uffo
JwqM1Bby94PrBvcl8OL3FfcSLOj7MR/7VQb3UTYV8L5WOkBaUyYfM/edBg73Prn36KwKlpWLjJYe
91n7HfcGuPte9w0F9b/J9wb3LBr3ZfsI9x77VvtRYAoeZQrXaArVZgpBZwo7YQqeUgoOb08KDlpZ
Cg7y+HL3lCkK6fj5+TYV+wIGNPugBUv7Vmv7DIsai2z3DE33Vh4196AF+wIG93f9NgX3DgYO+CL4
n/ksFTAGRvuDBWD7KF77PCAKYfdRa/cTHkz3jQUgBvdF/TYF9xAGyfdpBcj3YqLqIAqkLMn7Yh7L
+2kF9w8G9zn5NgUjBlD7jgVr+xtm+0qLGomSVvdNZ/cRCA7auvk2Ffdg++H7bPvpBfcPBq3F3/cc
rsb3NPuRGPcNBvtz9+j3YPfiBfsPBmxVPPsabFX7I/eGGA7G+N35NlQKrviY+TZHCvt01PtOFfeK
4vsq+WP3KuL7igYO+xX4QCQV+//5vgUlBvgA/b4FDvt095D7ThX6EfuJNPcq/WP7KjQHDjy09+AV
6wbu91Ls+1IF6gb7IveaBScGDpOl+wsV+I3f/I0GDiL3evmySwoOWffnxyMKrNIW7tgGV6y+a9Eb
9yHX9w/3G/c1L/H7EkpVbFZpH/epKAfu/FYV9xTZtsTVyFD7DCVRR0FFR7z3FR4OPXUKDqp/Cij3
lVYKc/hTpiYK+2up+I8VP9wrCvbXILEHy6yis5ubiISbHuEHkHl1jnobJGMKBw6V6fs0TgqN0Bbt
96cG9wXRtMTCtGVETQr36Af3BEjJKj9Wak5vHvezKQcOkQqX/So3CvvHyZIKIf3fFYGmoIakG+i+
xegf+Lwp/LoHV3V4anh0kJZ1Hg5a0Bbt+VApBve9/VAV9wkG+1v3nfdV94ZMCvtT+4YFDtQW7vlX
KAYO963QFu33pwb3Asq3vceoY0ZNCvenB/cCybe+xqhjRk0K9+kH9VbOIUlTaUtuHsl3Wq8+G0tY
bFJvH9wpBw6NhAoOmvetghX3MOH3CPcm9yU59wj7NPsnLvsI+yn7I+D7B/cvH4r4TBXxsTcrK186
LDNZ3evqud/mHw6qhQrZKQft+5CPCqr4k/iPFSg/Br5qWatEG/sdO/sD+yb7K9/7BfcazMCpwq4f
+6TuByj4VRX7FEJbTUFOyfcH9cXN1czUYPsWHg77ZoYKDvsWUAoO+0NTCg6N9zb4jy0KaJ74jxX3
SPyPBfcEBvdM+I8FJQZE+2oFUvs7glogCoC8Vfc7Hkb3agUO94ue+I8V9zP8jwX3Awa59zoFuvc9
mcwgCphLu/s+Hrr7OgX3BAb3NfiPBSgGWfs7BVP7T39QixqLf8ZU908eWfc7BSwGWvs7BVb7Sn5M
IAqAylf3SR5c9zwFDlL4aRb7PfeV9z33jwX7Agb7AftHIfdHBfsDBvc2+477QfuWBfcABvcJ9073
A/tOBQ5ekviPUQoz+Cn4j0gK+133HfeYFdaWuMbWwXm4uhqxoKmxlZeIhZYe6QeReXmOehs/TU0r
H1qdYGAaVW5YUYUeioCCi4YbKweQlouKlB/IgqVaVWB5YFoaK8lN15ydjpGdHukHhYB/iIEbZXap
sh+5nbjBGtZex0CWHg77xtf7VhXm+g0wBg77Xfdm95gVQYBeT0BVnV5dGmR1bWWBf46RgR4tB4Wd
nIicG9jIyesfvHm2thrBprzIlB6Mk5eLkBvrB4aBi4yBH1CRbr7Btp22vBrrTsk+enqIhXkeLQeR
lZeOlRuxoW1lH1x5XlUaQLhQ1YAeDs34kvfpFWhzb3NgR1zNIRtMUmFSYx/NUwW5ra2ft83ESOkb
0rq3v60fDvvDDvuzyfhVFWWobLKxqqqxsmyoZWRubmQeoPsuFfxg6/hgBw4y9yL3jxXxjNDV9Rut
r4J5qx/jB3CYcJJyjgj1N/sAB/sedT77A4r7EAj7Ft0h9xp2HiHf9Aemj6aSpJcI4wd5bGWBahv7
BE3X7YkfDnXD3RU5+Ebg+80Ht6eptumWipeXGvc81vtEBoiniKekGuK2sdqxq4F3qx7rB5xtYZVe
G/sdQDv7HnOOb49uHz1A4QaMf4x/gBo1d1xDaB4OjcP3yhVdl2Ciah5QUchQxcUFda21gLobubaX
oq0fyU/Hxk7HBaKtmre5Grh9tXasHsXFT8ZRUgWgaGKYXBtcYH5zaB9Px05Qx08FdWl9YF4a340V
2MPH29vDTz49U1A7O1PH2B4OvtH3aRVH90T7JfL3JfdFz/tFtAehswX3L8/7CQb3Nve4BfsJBvsx
+8D7LffABfsKBvc0+7gF+whH9y4GoWMFYgcO+8b3O/gDFffhMPvhB+b8oxX34TD74QcOf/hveRW2
fKt0ph6lqJu1uRr3AT+1N7MeL7hPl8YavbSp1sDGeXOzHvEHol1RlFgb+xMuTvsGY5ltoXQfcW16
ZF0a+wDeXOJkHvcBW7F1VxpRXm1ASkihCvcX6Mr3CR/7T/dWFTuuVKXHGp+SopqeHqKAo4CigAjZ
ZcRzTRp1hXZ+eh5zmHKWc5UIDiK++WMhCg73c7T35RX7Ufcw+zH3UfdR9zD3MfdR91H7MPcw+1H7
Ufsw+zD7UR7WihX3K/cL9wz3LPcq9wv7DPsr+yv7C/sL+yr7LPsL9wv3Kx73UYoV0Lu2yKOrhHyi
HtQHm25qkHQb+wpINSkm1Dv3Aaquk5ihH9UHfHZtgW4bTF+6y4ofDvtM95H4URVW3fekB/VZw/sJ
Vlh+e28ePAehq7uathvRoWlUH3VFB/sESlk6QL9Z3cKypaqgH4nhFWFoaFdacqSwtbCjzh7EBg5m
9x33kRX3J/c2BSAG+yr7Nvcq+zYF9ga89zYV9yZDCvsr+zb3K0QKDpv4ovctFfeZ/IM3+Cz7RQcO
+1ukCjSV+MsV+xToL/cU9xPp5/cU9xQt5/sT+xQuL/sUHr8W8M7R8vHORSYmSEYlJEjQ8B7wJBW6
25wGuzsFwwZT4wWjl5egqBq3cqVQHksG70UVeYJ9dx5zyqAGoJaDdB8OIqMK+z2p+JwVMM9J5uXS
z+blRs4xMEVGMR7WjBW7r7K7u7FkW1tnZFtbZbK7Hg6a9373PRXm9zT3TeD7Tfc0MPs0+0k290kG
+0n7vxX4Xd/8XQYO+0y2+Bx9Cvts9xL5FhV2SqAGzKhyZmdwc1xlZpSeZ64K6L6+0MdhsVuQH7uW
qq3BGstbwC5nsQqor5ioG7OleWRjZndeHw4i9w35EDQKDpP3O/iPFSn9Qu33XgZ4pqyBsRvGtqe9
oh9D7fiPKfuoByhiVUVRVa/SHg6V9735NhVABvsfTTQ3Mcw89xUf/HbdB/cAFt75yjkGDvvHwffA
FT8KDiL3wfsPOwr7t5X5OhX3AcenCkUFDvsu91n4FhX3FdHs9xH3Dknt+xn7Dj8p+xL7DdAq9xUf
ivgJFeCnQjs5aEY+Q2PR3Nyw09UfDmj4C/eRFfsmRAr3Kvc2+ypDCln7NhX7JkQK9yv3NvsrQwoO
966JCviD/HoV9w2MCvewiQr4Z/0WfQr32/cp+KUVdUuhBsyocmZnb3NdZGaUnmiuCue/vdHGYLJc
jx+7lqquwBrMW8AtaLEKp7CYqBuzpXlkY2Z2Xh+3/KUV3Qb4UflcBTgGZvzAFfcMjAos9/f4VRWy
bahlZG1uZGWpbbKxqamxHsr8fBVqWFt9Whs5Z7jG2cux9wkfivc2BS4GiiYFO4UgVfsRGvsI4Ej3
EMvEnJ+wHg73A/emQAr75v1pKAr3A/e+Igr7/v4LKAr3A/gORgr8dv1pKAr3A/hZ+fguCvxy/c4o
CvcD9zj5uyEK+/b9uygK9wP3b/nROgr7jf3TKAr38J4W9wAG5jEK94X7OfgWmAr8WwYn/BkV3/cp
xfcBq8wI+/n7VQcOw3AK96j8YTsKaPd8QAr7kv1pLwpo94IiCvuY/gsvCmj30kYK/BD9aS8KaO35
uiEK+4r9ui8K+7HVQAoz/Wk2Cvux6SIK+wD+CzYK+7H3RvoLPQr7fP1pNgr7sWf5uyEKI/27Ngr3
T3EK9xf4afn4Lgr8WP3Oegr3NvfMQAr7/fwVJwr3NvfUIgr8Bfy3Jwr3NvgrRgr8hPwVJwr3Nvhy
+fkuCvx8/HsnCvc291L5uyEK/AH8ZycKXfcN9ygV9xb3FfcX+xbKyvsX9xb3GfcYS8v7GfsY+xn3
GExM9xn7GPsW+xYFDvcds4MV8wavuwVsusV6zRuyCu9w3lvHH9fyBSMGaF0FqVxRnEgb+1JgCien
N7xPH6j3iBX3Mdjt9xO4soB1qR77rvwQBXS0fsDLGvgsFvsyQSn7FV9ll6FsHveu+A8FoWKXVkwa
DvL3qUAK9fxpKQry970iCuH9CykK8vgIRgpu/GkpCvL3Mfm7IQrv/LspCsb3qiIK92j7aVQKhtQW
8vcM5gb3Kuvi9xT3EzHn+zYfNvcMJAb3TvthFfcAtU5ARF9SJx8y95wGDpT3nO0VMQd/pq+Hqxv3
AcrL4h/3G/sgo8W70qTtGuBC1fsI+w47R/scHvx67Ph+B9ixrc/BrW1eHkVBcT0g9yh5NBpja3FZ
aXORnWseDln3YkkKsfyGIwpZ92skCqj9KCMKWffARQor/IYjCln4CflRLgox/OsjClng+RIhCqz8
1iMKWfci+So6Cvcc/PAjCvef+Zb3aRWOnI6pmhr3MD7d+xdDTW1WZx7AdVSrOBtMU3x3ah8uB6Rb
Cm85B/sZPVEqMcxR8uzGusGiH0qz3GfdG7rGlqCwH+MHc2lZfVkbNke55Xwf9xb3bxXPtV48jR95
+4gH7ZfFt8kb+3j7lRVNXmRRUW6ot722p9sezgYOPXUK92L8CjsKc/d5SQr3D/ynJgpz94gkCvcA
/UkmCnP310UKgPynJgpz9wP5FCEK9wf8+SYKykkKNvzCNwrj+MI0CvsC/WQ3Cvc9RQr7e/zCNwpb
+RUhCif9FTcKdvc0+F4V9yHSslepTZdEGbFnWKNQGyAvQfsV+wXdKPcd9yLg8vdJ9wRh8k/aH9uz
Bc4H+wxPdaJ0nnObGfsiBrhyuGqzYidZGHb72xXZu7bLxLlvYqse+xSEUGFLG0ZbuNQfDo34KPlR
Lgr8G/0ngwqa935JClv8yywKmveQJApJ/W0sCpr33vljPQr7TPzKLAqa+Cr5US4K+0n9MCwKmvcM
+RMhCk/9HCwKmvdx+JoVa6Zvq6ump6urcKZra3Bwax77PPtyFfhd4/xdBvc8+3IVa6Zwq6umpqur
cKdra3Bvax4Omb2CFegGoqoFd621gLsb9zDi9wj3JtJ3y2S6H8baBS0GdGwFn2lgllob+yYt+wj7
KUWfTbJcH/dJ+AYVq6WDfp8f+177pAV8qYOwsRrwvOLtHvcp+1EVJlw2Jm5xk5p2Hvdf96QFmmyR
ZWMaDo33c/ljSwr7MFktCo33hCQK+0H7aS0KjffURQr7uVgtCo3z+RMhCvs3+xgtCl73cyQK+8v7
aVEKqoUK96opB+38WI8KXuX5EyEK+8T7GFEK9wP4evmZMAr7K/2ZKApZ+CdBCveE/LUjCvcD9975
qTwK+7/9qSgKWfeP+QE8CuP8xSMK9qgW9wEGwDEK96UGvfsxBV5qZFpOGk20WeGtXwqcCsC4yKsf
+3r5NgX7HGIK4/edlbkgCpZdCvttBg5X+Fr7dhWcCsG4x6sf99YH9xJOzvseTU58d2oeLgekWwpv
OQf7GT1RKjTJT+zNuKmwpR9bB1dqW1dKGk20WeGtXwr7CvgbFVliYk1Rbqi3vban2x7OBg7D99ci
Cvuccgo995H4wTQK+2L8aHcKw/fcKgpkcgo993syCrn8aXcK9wr3nSoK9y/+CxX3bvcO9yr3VvdU
+yL3HvtcH/tm/TYG92T43hX3KOVeCvs1HyH4hwYO9xx/CsH4khXYBvcF91k5Cvt+/FZWCvdPcQqq
+Nb42BXKSMsoS/tJTPdJ+yoHwGlVqkob+xIvJfs1+xvX+w/3INK+q7+sHz7u+NgHKPvXVgpo+Db5
mjAKYv2aLwpz+D5BCvfZ/NYmCmj3bPm8Mwr7I/28Lwpz93D5FDMK93f8+SYKaNQW92QGYWpnXVOL
CspXCnP4K/ttmwq6u7bDqx+lkKOTnZUIggr7Hd0m9xp7Hmdrb2FZNQr7Hfkdkwpo93kqCnb+Cy8K
c/d5Mgr39f1JJgr3GPgH+ak8CpH8KG4KDpX3vfkCPAr7X/2iTgr3GGwK/Av9DiUKlfhT+YcVPwb7
BftZBfcBBvul/WJOCvux97D5mDAK8P2YNgr3p0EK8fzxNwr7sfdd+3YVSgr5NiX9Kwdaal5ZTDUK
DpEK9xX+DBVKCviPKPyCB1hqXVhLNQoO+7HT+bwzCpT9vDYK1Bbu+I8oBg69hwr8JvuNJQpa0Bbt
+VApBvH8RxX3V/udBfcJBvtb9533VfeGTAr7gP2IJQpG95QiCvuq+2mfCt35ijQKI/4sswpGmgpm
/i8lCtQW7vlXKAY1/lAlCkb3lfiLFdhcCvudcJ8K+7H3gfiSWgr7iP1YswpsrfdPFdK5Bft9+A7m
+6j3ZAf3Lu4F5Qf7LigF97El+/MHRF0FDvuH8Bbu9/0G3cQF5Qc5UgX3lCj72QdFWgUwB9G8BQ73
F/fTIgr76XYKjfecJAr7toAK9xd7Cvci/i8lCo2ECtv9iCUK9xf3yCoKJ3YKjfeKMgphgAr3NviQ
+ZgwCvsy/EQnCpr4SEEK9yn8+iwK9zb4MflpPgr7vPy3Jwqa9+34wj4Kkv1tLAr4S7n36BX7ZvcJ
+x73UNvOqL+9HkL4GeH7t/dk95Lh+5L3ZPey4fwUSQe9WkeoOhv7UfsH+x77ZR9lCtJoCtFmCkVn
CkBhCvfo96eCFeDKscayH1C41GnhG7rJlqCxH+MHc2lYfVobNEe65Hwf9+AGjpyOqZoa9zA+3fsX
RElsUGAew2VNrjcb+yYz+wj7Kfsj2/sH9y4f+AH4TRXNtmA+jh91+4gH7ZfFt8kb/AGKFfGrNysr
ZDosM1/d6+q03+YfDp73gCIK+5ZzCvtm9zokCvtUgQqeUgr7hP1eJQr7ZoYKMv2IJQqe94kqCmZz
Cvtm9zQyCreBCm/3fiIK9wD7hGoK+xb3TiQK2G0Kb08K+wj9MDsK+xZQCkD8oDsKb/dvKgr39fuE
agr7FvdQMgr3xW0KWlkKM/3ZQgr7Q1MKa/08Qgpa92IqCvcT/gsVogoO+0P3kfjRWgr7gPz9fgoO
8vh3+ZgwCve//JgpCo34PUEKtCkVKPvuBiLKTe/XwqrJph407ZUK8vdq+dE6Cvdf/NMpCo33Ofkq
OgpL+zEtCvL4BflpPgr3SP0LKQqN99f4wj4KMftpLQry+FL7b5sKvcC3x6sf66zF3vccGvg0JPw2
B/sTSmAzN0i29w4e+Dsk/DwH+zPhNPccfx5obHFiWzUKDo33NviPlwpCB1hqXFdLiwr4jyn7qAco
WFVAUWWv0h4Oxvcc+bohCvd4+xhUCq73niIK9y/7aUcKM/dcJAr3AvtpSAqu94b5vDMK96b7GkcK
M/dM+RMzCvdx+xhICq73jSoK+Cb7aUcKM/deMgr35vtpSAr7C8v4CxU/6QdO+/wFQ39yY1cbc3aQ
k3gfNgeEnauGphvyvtT3B54fyvgEBfcC1ykGnvcBBdSXprK/G5+fh4WcH+AHkndsjXYbJFdD+wh4
H3f7CQUOb08K+8b9rkIK+xZQCvul/R5aCg5aWQo2/dlCCvtDUwqZ/TxCCiL3n/myPQoOIvdF+RBV
Cg4iowoi93L5UDwKDiL3NflkMwoOIvb5YToKDiL33ftqFUoKZ7gFSXMtSjA1Cg4i9/H5jy4KDiL3
XPkQPgoOs/cG90EVQnZ7Vh43B/cByrP3IB/3j/dAKwrn1/y7P+YHDobA93sV+ErZ/EoGDvepwPd9
Fflk2f1kBg777Pdx+UsVOgb7EPt/BfcIBg7765YK++uK+xAV3Ab3EPd+BfsIBg77UPdx+UsVPQb7
E/t/BfcHBveK938VPAb7Cvt/BfcCBg77UPdA+GAV2gb3Evd/TAr7ift/FdkG9wr3fwX7AgYO+1D3
MfsQFdkG9xP3fkwK+4r7fhXaBvcJ9345Cg5893AW5Pg+907e+073OTL7OftKOPdKBg6JuPdAFfdJ
+0Dk90D3T9/7T/c+90/e+0/3OTL7OftJOPdJ+z77SQYOIOP3+BVAw1HY1cXF1tZRxUA/U1FAHg73
frbHFT8K960WPwr3rRY/Cg75Zbj4nBUu1kDo59bW6OdA1i8uQEAvHvc4/J0V5wb4Afk6BS4G/FH7
MRW5sbG6ubFlXVxlZV1cjgr4KBYu1kHn59fV6Oc/1y8vQD8vHvvVFrqxsbq5smVcXGRlXVxlsboe
+CgWurGxubqxZVxcZWVcXWWxuh4O+3n3H/eRFfcmQwr7K/s29ytECg77e/dJ95EV+yZECvcr9zb7
K0MKDvuPaJkKvrv3rhVI7gf7Ha/1NfccG8qwlJ2uH+0Hdmthf1kbOUe54Gwf91jO+2cGipiKmJka
nYybjZse92bO+1YG3qrOuOEbvLKAd6of7AeeaGGUUxv7F/sBO/siZB8nSOMGinuKe3oafYx9jH4e
Dqz3JRbPBvdh9xf3NvddHywG+xo5+w77FXYe93KqCuGqCuop+yWrCjWrCg6i9wUW8eD3Xtf7XuLb
Bvcq59b3EvcNNuD7Nx/7RPvfKj/sNCo/7Ab3QPh7FfK8Wz0+WV4nH0P3jAYOYPhhphXdB3hsaH5i
G0FsueEfkwf3GrvU9wr3DhrqXdr7APsDZDD7Bh77VweKfXyKfBt1bpCReB82B4Wgo4ilG5qZjIyZ
H4EH+xPSS/cEvreYnqoe+2j4TxXRm764s55jWTxjQDtjHg73Nvep998V0QaU9yIFkNmJtSAKlGSo
Oh67+xwFzQa/9xwFqdyUsiAKiV+QQB6W+yMF0AZu9+sFNgZW+yIFb0F+YSAKgrRv1h5Y9yIFNwb7
wU0V4vuu0feu38n7hQYO936+Fve84QYmoVb19xca9yrT6/cR9xTQK/sq+xdeICJ2HjX3vOH7KgfU
wbLl9wca92D7BPce+1X7UvsH+x/7X/sHtDHVVR77KQYO97L3WPfJFfjvoAb3VPtC9zb7a/ts+0D7
NvtU+1H3QPsr92z3G/cGyObWHisGSVU9XysbOD2vy1Yf+ED4MBX7VPxA91EHxrrZsuIb6thiVbcf
DnT3n/k2FfsdBuxQ9wH7A7D7FAiqamCdVhsiJjz7GvsK0yT3Hvcr3PcK90T3KCT3OvsC1h/7FPxl
Fdu9vc7EtXRmqh77D4lbQDcbRGHC1B8O4vjw1xX7bPjqBfscBvtw/OoFP/jQB/wl95wV5vebpNEg
CqRG5fucHsf7RwX79AYOx2v7QRWFm6mFnxvyxsr3Fx/40/eD/ZDy+er8UP0zB0p0bFh4eZCSfB4O
LKn7XBX4WeH76gb3PPf6+zv37AX36eH8WTUG9z777Ps++/oFDprA97wV+F3j/F0GDvstrZkK+7LL
9+UVqQqpZmVtbWUeDvd294L4RRX7UAZ4OgX3EQb3XPy4BfcUBvfl+twFJAZQ+1T7Avv9T/tVCF77
KXT7A4kaio9r9wJZ9yQIDvew+DT3shVPvMFb4hv3AtHT7u5LzfsEMVBUU18fx1pUvDYb+wNGRScm
yEr3BubEw8G4H/erxxVVa2hPVGW1t2Yes6e0v8gbxqxiWx/8wha+rK/HwrVdYqweY29gWFAbUGmz
vh8O+3v33vj5FeEHkHl1jXobJFBKIx/8sgdLa3Rie3yOknseNQeGnKKImxvyxsz0H/iyB8usobOb
m4iFmx4Ox/iH+I+NCkrkG8+4s76sH0j7K40KSeQbz7i0vqwfDprA91UV9xcGZTYFyAay4AX3nN77
dwbG9xUF9zzd+xcGsuAFTQZlNgX7nTn3dwZR+xUF+z0GDpW79+kV+F0tBeQH/C/T+C/TBeQH/F0t
Bfhd+7AV/F05+F0GDpX4kvhvFfxd6QUyB/gvQ/wvQwUyB/hd6QX8Xft8Ffhd3fxdBg6l93r5NhX7
Tfvl90375QX3BAb3UPfl+1D35QVUOxWLqU3R+w8eskNkQwVF+w9tTSAKbclH9w8eZdOx0wXP9w+p
yYsaDnr4CBbt+I/7mbEGy6miucG4ena4HuAHoWBYmlAbIWMKOj/cKwr3NwcOfPgDFu35KwaoVUuj
QxsjT0shH2Q6P9wrCvbXILEH0K6wCg65qfiPFT+dCvbXILEHy6yis5uaiISbHuEHkHp1jnobXmZ/
dHAfnWelCgftsRXLq6K6rKtYCvs3Bw73tqn4QxWdCvc3/EPt+I/7mbEGy6miucG4ena4HuAHoV9Z
mlAbXGZ+dXAfnZAKq1gK+zcHDveLqfhDFdwrCvc4Kwr11yGxBtCtsAr8/u75KweoVEyjQxtdZX9z
cB+ekAqsWAr7OAcOd58G94kU+LkVlhMAlAIAAQAFACwAMQBuAHMAeACNAKwA1AD4AP0BAwE3AT0B
YgFnAW4BcgF3AYoBlAGdAaQBqwGxAbYB3QH8AhcCKQJBAksCUAJVAl8CZQJrAnACdQKOAqcCrAK1
AsECxgLLAxwDIwMqA2cDbANyA5gDqgPAA8YD0gPYA90D6APwA/kEAgQIBA8EFAQaBCAEJgQsBDIE
OAQ+BEQERwSHBI4EkwTYBR0FJAVTBVgFXgWZBaAFpAWnBd4GFQYZBh4GUgZ8BqYGzAbQBtYG+gb+
BwMHJgcrB0wHaweEB6QHqQfFB+EH/AgTCCIIJgg7CE0IXwhvCH4IjgieCKwIsgi2CMQIzAjYCNsI
6Aj1CQIJCQkUCR0JKQk0CT8JSglUCV4JaAlvCXkJgwmMCZUJngmlixqLCxVppHGvraWlra1xpWln
cnFpHvdxFmmlca2upaWtrXGlaGlxcWkeC/lpNAoLFU/s99YH9xJOzvseTU58eGoeLAelWwpuNwf7
GD5SKjjIS+3bs6+nnB+I9wEVU2VjSlFvqbi1ra/aHtcGDvjCNAoLFdhcCg4Vggr7K+4h9zO6y5ag
sB77RfgpkwqsCrIK92X7CPce+1b7UWAKHmUK12gK1WYKQWcKO2EKFfcBBsExCvekBsD7OQX3Agb7
evk2BfsbYgri952WuSAKlV0K+2wGDhX7E0pgMzdItvcOHvg7JPw8B/s/7zP3Lvcw7+T3Rh74NCQH
DvlpVQoL/EPt+EMLFfcw4fcI9yb3JTn3CPs0+ycu+wj7Kfsj4PsH9y8fivhMFfGxNysrXzosM1nd
6+q53+YfDpcKNO2VChV0gHp3bWFptFAbXGNoZHkfvF4FqZ+cm6yvsGLAG7qzprqhHwsV+BlXChXP
+8RHBwv3OQUL+MJVCgsVaaVxrq6kpa2tcqVoaHFxaR4LFd8G9wz3NjkKCxpNs1nirF8KCxXx+TYl
Bg4V7viPKAYO+1gG94ALBfsBBgsVTL5Yysu/vsrLV79LTFhXSx7IjRWooqSpqqJybm50cWxtdKWo
HgsVo4Wqf5weNwaZdpZ2cBpib3JViB5HB/cAjb7J0RoOFUlttcMfPQYjyE73BfcFyMjzHj0GU21h
SR4LFTEG+xv7NgXsBt3x3yUF7AYLFdYG9xr3NjkK+537NhXWBvcO9zYFJAYLqQqoZmVtbmUeC/oL
SwoL+PEwCgsV2Ab3BPdaOQoO9zYFIQYL+zYF9QYL+WQ9Cgv6Cz0KCxX8XTb34wb76PyQBTr4cOD7
9wf36fiSBQ4V+/U594EG+4r78gVA+Ave+5oH94339gUO+WRLCgugCr3BuMerHwsV+wEG9wz7NgXf
BgsF+wcGCx771O0LFXO8yILCG/cV9wDS9zkf+GQpPAe/b1ytQxv7Ezr7Avsn+zfxO/XOvKm/qh9X
ByNTYC5WUJmnYB73Q/czFU5NvPcE77rQ28jLXPsVI0pZSx8O+En5G2sKC/f6+H5vCgsV9178hAVE
cV5nShuBf4yOfx83B4eamYqcG+XZu/cnwh/3S/iBBSMGUvs5BUz7TIJtIAqDqUT3TB5MMQoO1BZ5
Cgvs9y5+CgsV+woGWigFIPtmgm0gCoGpJPdmHlvuBfsKBvd4/DsF+4/y948HDhXlBvcb9zYFKgY4
JTjxBSoGCxX7FUdaRUBSz/H3DMjG1cTZYPsUHg6YCvwUBg6CgKcehXeIdXMaZAv3WhaiCgsV11wK
C7HDnsAb3KZjSh8LBvcF91o5Cgtd4fudHpZpBQsg+xv7IkH7BwupkpmjHgv7DPse+2UL6/cwHg4G
bPwZFQtQSiIfZAsVcZ15pQv3ABb3Lwsr+y/7MAsr+xP7Dgvr9xH3FAtxeXlxHgtrCg4Vol1RlFgb
+xUsRvsJ+wrsYd5lH9Fsw3FRGk5caENJSaEK9xbr0PcO9wottjawH0epUabGGsC3r9XAxnpysx4L
+A34FW4KC/t6bwoOFTL3HftOB35rZYJfG/stLur3L/cs7e73I8XQfmLMH/UHrU9Dlksb+1r7J/sg
+2T7bfck+xX3Y+nYqK26H4qSBYz31wYLFZhwXZRUGys8WC85yGXFcx/LcLp4XRppb3NVV1Weo2Qe
Lgd7q8R9yBv3ANHA59pOsEqoH1ajWJ24Gq2no7u8u396qB4L9y735nQKC/f1FqgK+yH3HvtdH/tl
+7w7N9v7ugb3oPe6Fd/7OPdk8gf3KOZeCvs2HyH3YwYO/Ll0Cg7+CxV5Cg4V9y706/cX17J+bcIe
8AeoWE+TTRv7WPsl+x/7Yvtq9yX7GPdaxM+Vqrof8wdsYk14Txv7JSjr9y8fC/ci9494Cgv+C3oK
eAoOFfHO1/asuIF2rB7lB6BiXZJpG/s+LPsS+x77JO37Cvc3t72Wnqof4wd4bWF9Yxv7BFDZ7Ykf
C/L3lOQG9zL7lAX3Dwb7RPek3Ki9zo3rGfcTNt77MR77UAb32vtlFURiVzIeLveK4wbkuWA7HwsV
fAoO1BZ8Cgvy964G9z2D74sei7so8fs/Hvc7+60F9w75NiT7rwb7RJEwix6LXuUj90Ye+zr3rgX7
DgYLFfewzPtJBunP1OHeGuJIuT1gY3x5bh48B6KqspyuG7WpdV0/Ky8tRR8OFSa7UfcBoq+Rl6Ee
4wd9eXCDcxtdc6S7H/er9xnX+xn3ECj7EDw/2gcL+JP5VxUo+6kGwGlVqkob+xIvJfs1+xvX+w/3
INK+q7+sHz7uBwv9ZIMK/WQVigoO4wdzaVd9WhsvSbrkfR/34QaOnI6smhr3MDba+xL7FCgt+zsL
FYgKDtAWiAoL0PtWFe33owZVrcBtzhv3Gt/3Bfcr9yY79wP7HENXaldrHwvQFooKC9QW8vk2JAb3
g/voFfeL9+gF+xEG+4n76feT++EF9xYGC+33pwbxyL/MxLNnQk0K9+sH9UzMJ0FUak5uHuIpBwv3
HhbdBvhQ+VwFOQb8qfslFfcBxqcKRgUL7feiBtu609GbmomEmx7rB42AgYyBG0dgZVN1H+QpBws1
CkoKC/dtBfttB2L3pRX7L/ulBU73WCzU6sbIUPelBw4VaXRwdGJKXMsnG05VY1VkH8pWBberrJ+2
ycMLZbG6HvgG+/wVLtZB6OfW1ejnQNcvLkA/Lx4LFfcW1bbN1cRL+wD7CFBOP05Au/cUHg5mpQo6
B/dHsRXLq6K6rAvIkgoL+SoVaaZwra2npq2ub6ZpaXBwaB4LFdSyWUGNH3n7iQfql8K6yxsOZahu
sbCpqLGwbalmZW5tZh4L+I8p+6gHKFhVQFFlr9IeDpz4YBXbBvcR938F+wkGDhUo++4GIspN79fC
qsmmHgvh+7L3ZPeN4fuN92T3reELFvhQ+VwFOQb8UP1cBQ7U+TamCgsVoAoL0wd+eHCAbxtndZ2s
vQvcKwr3NysKCxXhBvcX934F+w0GDqYKDtMHfnlvgG8baHScrQugsVgeIAduvNB9zRsL8vjg90Xh
/Fw190QGC/gK+T0wCg7A93UV94jf+4gGDlGcVxv7AWMKCxX9NvgP5vuo+NsHCwX77tb4Q00H+w4L
9273Dvcq91b3VAtlqW2xsKmpsbFtCwfzwQXeByNVBQsHNl8FOAfgtwULFftm9w77HvdQC2QKpJ6d
pQsfRQd7q72CsBsLtvhJFeD3iDYGC525pKWGgqUeC2V/fHMeQQefC/dS9wv3HvdmCxXu+VcoBg4A
AAABAAAACgBmALwAA0RGTFQAFGdyZWsAFGxhdG4AGAAUAAAAEAACTU9MIAAgUk9NIAAyAAD//wAF
AAAAAQACAAUABgAA//8ABgAAAAEAAgADAAUABgAA//8ABgAAAAEAAgAEAAUABgAHYWFsdAAsZnJh
YwAybGlnYQA4bG9jbAA+bG9jbABEb3JkbgBKc3VwcwBQAAAAAQAAAAAAAQAEAAAAAQAHAAAAAQAB
AAAAAQACAAAAAQAFAAAAAQADAAgAEgBAAEAAYgCAANoBIgFEAAEAAAABAAgAAgAUAAcAgQB6AHsB
HgEfASABIQABAAcAGgAbABwBBgEHAQoBCwABAAAAAQAIAAIADgAEAR4BHwEgASEAAQAEAQYBBwEK
AQsAAQAAAAEACAACAAwAAwCBAHoAewABAAMAGgAbABwABAAAAAEACAABAEoAAgAKADQABAAKABIA
GgAiAIQAAwE7AB0AhQADATsAGwCEAAMAGAAdAIUAAwAYABsAAgAGAA4AhgADATsAHQCGAAMAGAAd
AAEAAgAaABwABgAAAAIACgAkAAMAAQAsAAEAEgAAAAEAAAAGAAEAAgAqAEoAAwABABIAAQAcAAAA
AQAAAAYAAgABABkAIgAAAAEAAgA4AFgAAQAAAAEACAACAA4ABAByAIIAcgCCAAEABAAqADgASgBY
AAQAAAABAAgAAQA2AAEACAAFAAwAFAAcACIAKAFVAAMATwBSAVYAAwBPAFUBVAACAE8BUgACAFIB
UwACAFUAAQABAE8C8QCrAAAAAAAAAAAA9gAAA5IASQIiAD8AzgARAAAAAAKUACwGcACTAQYAPgFC
ACsC0wAzAfsALwN0ADACywA9AKsAKwE+AD4BPv/zAbUAHQI0ADUA9f/4AV4ANQDBAB0Bpf/5AiEA
KQFUABAB8AAkAdcAJAIiACYB+wA0AhEALwHLAA4CGgAuAgAAHwD6ADoA9f/4AiEANQI0ADUCIQAw
AcYAMwOeADYClAAfAkUASQJdAC4CmwBJAgIASQHuAEkCqQAuApAASQEIAFEBcAAeAlcASQHgAEkD
ZABAAqgASQLHAC4CJgBJAs8ALgI4AEkCCQA6AfQAFgKMAEcCgwAfA7MAHwJ0ACMCYAAXAkgANgFF
AEkBpP/bAUUABwHWACkCLQAaAbwAeQHzACsCRgBHAdcAKQJEACkCDQApAU4AHgIvACsCJwBFAPUA
PQDy/9QB9ABFAPUASQM+AEUCJwBFAjQAKQJEAEUCRAApAVMARQGjADcBdgASAicAPwICABMDHAAT
AewAFgH4AAcBzQArAVwALgDzAEwBXAARAmcAIgD2AAABBgA+AcwAKQIPADgCJwAgAlgAGgDzAEwC
GQA1AbwAMwMEACkBbQAEAgAAGwI1AB8BXgA1Ac4ACgG8AEYBfAAeAjQANQFtACsBTQAjAbwAeQIt
AEUCLwAVAPIANgG8AI4BAgAKAYv//wICACEDPwAxA0EAMQNsADoBxgAzApQAHwKUAB8ClAAfApQA
HwKUAB8ClAAfA4EAEwJdAC4CAgBJAgIASQICAEkCAgBJAQj/3QEIAFEBCP/RAQj/3ALgAD4CqABJ
AscALgLHAC4CxwAuAscALgLHAC4B9wA2Aq4AKAKMAEcCjABHAowARwKMAEcCYAAXAiAASQIuAEcB
8wArAfMAKwHzACsB8wArAfMAKwHzACsDMAAwAdcAKQINACkCDQApAg0AKQINACkA9f/SAPUASQD1
/8gA9f/QAhAAJQInAEUCNAApAjQAKQI0ACkCNAApAjQAKQI0ADUCMwAyAicAPwInAD8CJwA/AicA
PwH4AAcCRABFAfgABwKUAB8B8wArApQAHwHzACsCkAAdAfEAKwJdAC4B1wApAl0ALgHXACkCmwBJ
Aq0AKQLgAD4CRAApAgIASQINACkCAgBJAg0AKQICAEkCDQApAgIASQINACkCqQAuAi8AKwKpAC4C
LwArAQj/7AD1/+MBCP/zAPX/6AEIAEgA9QBJAlcASQH0AEUB4ABJAPUASQHgAEkA9f/zAeAASQEI
AEkCBgAiATIAHwKoAEkCJwBFAqgASQInAEUCqABJAicARQLHAC4CNAApAscALgI0ACkD3AAuA3kA
KQI4AEkBUwBFAjgASQFT/+wCOABJAVMAGQIJADoBowA3AgkAOgGjADcCCQA6AaMANQH0ABYBdgAS
AfQAFgF2ABICjABHAicAPwKMAEcCJwA/AowARwInAD8CjABHAicAPwJgABcCSAA2Ac0AKwJIADYB
zQArAkgANgHNACsBrv/IAgkAOgGjADcB9AAWAXYAEgG8ACoBvAAqAbwARgG8ADABvAChAbwAawG8
AHMBvAAzAbwAIwJNABcCIAA1AzoANQDNABAAzgARAM7//wFpABABaQARAWkAAQIWACYCIwAtAboA
WAMPACsE9gAtAUAAHAE+ACMBKv+LAlgAMAJGADwCPAAQAfoAJgLHAAQDDwAzA0MAFgIOACYCfAAg
AmH/4AHGAB4CNAA1AYz/0AEHAEADBwAfA0EAMAE+//cCYQAqAjQANQIvADACLwA1Aj8ALQIUAB4C
FgAeAlMAHgNHAB4DHAAe

------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-ef9a2406-f6f9-4eb0-8ac3-08b889e46357@mhtml.blink

@charset "utf-8";
=0A
------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO----
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: chrome-extension://ofpnmcalabcbjgholdjcjblkibolbppb/static/global/src/static/monicaLogo.png

iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA
AXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACXdSURBVHgB7X0LlF1Vmea/97m3qvLCotVgGmkq
KKKAiwq2EIgjVc00CIgULhikXwka21ZnmmR0TfewZlaqXNP2rF4oSev0mmkQE5xpx4bVlHYLQqtc
WmlQe0EB8pAAuTSvJEupSiohSVWdvXs//n/vf597b6Uetx6h6s86Oc976t7zf//3P/bjCHiDS88G
3W5WZhnrANAd/qjoqH+1rgLIIbPGpVzt3y6G4A0sAt4g4hWddwGoDqnlWRp0pzncAU750xILgAHz
oIaU0PebRzYAUBp4owDjmAWAV/hoj1H2BRqgK1r3rIkBhRhQAr4NkFlAVOEYlGMKAEbpHVKNrdfC
Ktwt80kqWmgDhnL/sQSGeQ8Aa+kSRjdoLa6A+af0RLShIuGf6IABwzYDhsp8B8O8BUDPhtEumcP1
aO3tNd/U7muYfdH1/zYdBnbK7gsttqtM7+jfXq7APJR5B4Ce3xvtMla0Bay18wctYPxvO1OA0Mmq
9iuw80UAcBHWRYABwjdatsM8knkDAKd4zRRvhX07jfuicHxGRDc4pCPOBO4XL3Xn66AlbApR1bnq
6/+b+QGEOQdAz1VG8ZneAsIrXhjz1/Sk3QF8muhc67qC4vYUmUDrcSxc1x6zGyYT8N8Xjyf7jJb8
cfBnHZBlVWt1pQHCAMyhzBkAenp0uyiNbDV6XU/fRJsdq2eydreD1B8CrHoKn+6v0I33neIZMLTW
tZ+ZCuDCDeV2k0b29f//uQkW5wQAV/ccvl4J0Wv+entUNlIrAoG+mZDCWQyw64KwffrshEUXNnWk
76hsT0Cac/3R1hORWuBWQapt/d9s2wqzLLMKgI/1HOoYy8XXMbI3VVf/FVIF436y4AXSP2WNrqKu
8o/2i4pBm44AcB/XdAxPcAUX9wv3TEHAw8KCcCAnl4gKjJau6++fPTaYNQBcc+lhk9KpXpPPt2vU
luYKJuqXUMsGEm8iIQUGiAIr6Maxgk4zOGfZNVbM0NFoKV4/WVfQgMHY9x4yy+b+22cnSJxxAPR0
6fbWlkNbzOYm9wyZRWvBrF+yc+QSROoS3H4BBPE8sgNQIBkxUuPToQgAPb6yFW4odmwSriD5LsV1
8ZgMB7aCKvUZNpjRNocZBcCGrkMdh2XebzRylqbomFk/V2yMA8x1qGTy/0Kk1wMDggscHUPo8PCC
pRMuOAh4VN9I8WFBpdNnFdR1Cd5dCEhSBUZG/Ps4ET4rgOR3M3BDOF4Frbr7+5dUYYZkxgCwoetA
5yjAfUahIdBT9CRI0UWl43V22yrfPm8hoxsIYHAPSgQg6MAGooZii544UTwplC+q8XmtKEbQSXbA
XUkSUPKvwtwafTeubHdcpqAIIBDiyv7+mUkXZwQAv/vBQ+sF5NsDUzrjQCXiNf5cVLzbJ/pj7sCd
J4VL7gYYU4j0swDxgQcJytIFZUOqeJWe80r3xzW6DVHjJnSDOkFBBPteQgS3QMAOaS4xAQFCur+x
uf/vm58lNB0Af/CB4S3mB/YWlU/bngkY9UOMA7Rgig8PIyrePQjc99doxxQBWJJ8rUisXwMWbIqU
ryBVPFe6VbhKmUBz11ADgrimzYR5ODnhhpCQPBdBAS8DgmDPwPzX2/8P5T5oojQVABvON8oX2iuf
KV0j9yXPrOgG0J/zB6LJLMjfExtIdozOswfHfS/dzm1TEBesXKdAIKWHbcBgUUNdl4B/QDClBx8A
BQAA8/vsNybbXOki/Z3uuE+be/vvam0aCJoGgI8b5Sute+12ahiiVul4TtVlAMYObB9kQdlk+Swe
SKynKLqwqILV57ifA/P5BZcAca1ZCkjV6iStDKhDId2L+CxoPwGCFCHOSVwC/l7ht5sGgqYA4ONr
h7eYJ9OrOd2DV7Yn4PpAIOUHvTA2sBsqWAZ3AwiCjB1PUkMRtleuBOjokLBsKcAJbxVm37uBZUsF
LFsGiQ+323t3Axw8oOHgsIY9r2rYa5aD+wF2PaOCOxDcFQCkSi76fgJCUURhja4rBrOQBoQZHQMG
BAOC700fBNMGwMa1+4zyo88nF5lQPllIAgKRKh7QwiHGAolLwAeiWUBoHwyxwup3SDjzvWZ9ijRK
N8o+AZyimyXP79RQ/YWCx/9FwS6zfv4XqgACZvZFBjgaCMK2iFbPGQ1/s0D2E/Z3S7e/uf+e6QWG
03pCf3jeYI+x+Du5hVvhBTKu9KB43cAl0HmAtDbAgkKNQFh2nIBz1hmld2ZwznnWopun7ImIZQkL
hp/8MIfHf6Zg7ysqntQNPlS0fH48AYT/jSLJeiAwgGBuUGQmRby3tR+mKFN+an+0drBDKXhEuwYd
ERyapdio9NQFOOMgeocYKoUCmwD2OYgpIgLAKr37EqPwD2RwRqeE+SQWBD/89hg8ZABxcF8DBIij
bIvCAszvM0awDBBdoRgSUnb3/+PU6gRTAoBVvtGSKfJAh/fjqHBNLeHSqd0dx3bcem4gYQao4yIQ
EKe/zyj9g5lT/tLls2vpU5Ef9ufwnW+MwPNPNQgKBAsOaLvIDjweKPp/jAsQAPZ8Vei2Nf2VyZeN
p/Q0P33u4H3mW3QFhZtvpDjtY7Uj+ni/Hyxdx+tSd5CCwCr+qk+U4YyzMzgW5fGf5g4MP7hzDKNH
rvwCOMjiAwNEYKTVTqAgMILAb1e+fd+SbpikTBoAn1k7uMV8916vdB1o3FO5ZkGg/dKephUeoGt1
4hY0YxBwv/DdRuFXbSzD6ceo4ouy92UN3/xfowYIo/UvaOQOOCCoyEXuIINQBCMm0FL2fqcyucxg
UgD4zPv3dkpZeiSxVIrcNdShdhEYApLYIPp/ihmsvNtY/Ec3trxhFF8UywjbbhgxgFC1JxtlCkWX
wLMg7haQDUxQ2N1fWVKBCcqEAbCpa1d7fuhNj5g/3kHUX/TZKlB7tOZwDFJfT8fs+aUrJFxpFP+h
j5VhIch3bhszy+jEgNAoJuAgyJhLyERVyMMmHjh+QvHAhENpfah9i/mbHbzVQ4Ryjtd4rMFgQ4fW
jPiTdBdvav18Cf7sG0sXjPKtfOQPSvDFHW2w9sJS7cnayDgurEHKt1/oWL2023ada5OdtW6BCcqE
GGCToX4ts0eSFA1YtM6pvY5P1ywGcE285tgSE81fsbEVLrpm4Si+nnzzqyMuPmgsGmp6ORUCwpqg
MLMFJeMKfnx0VzAxBsiyO0MsIrilg7dy02oSmMku7lhq9bRh/+Bb3ibgT/5q6YJXvpVr/2ML3PL9
pbDyRNfmi0c5BUAwe/dMybKQCTRrxNI57ue2eVrfNJG/f1QAfO7cX11v/mgH/y703YSIbBC+EQq5
B3tM4nX2/9POLkHvbcvgN06dX4WcuZSVJwrnEk55tzVhnh6mqaKPvXTiEpJtcgN+u7PnvNc3wVFk
XBewae2rHVKXseCD9C8oeIu0FDMAwQLCSPu0nH9ZC1z335fAojSWW/58xASIIzXHk8pBwRX47EDE
dDFDd1CCIVEeWT1eQDiuGWaq3AsQrd9bNCC9o1o1/y7ePfjgDxJ4fWRj26LyJyAb/2sLXPvZlprj
3pxqD3K3ELq0x+CwHUZaxmWBhgxgrb+ky7vsdtoZViRWD1QK1jp2ejRFfCoKWURc9olW+LABwKJM
XHxwWJ8JiIXDsaQXEWssKjkmGBItjVmgIQOUVNbr/5gI/dXIyotW71NAEfvKsdTvw4vKn5LY4LAR
EySCviEapE4yMmOJ7WocFqjLAH9qrF9BaVdq5ZA26CAUg+XrtFHIIqbrP7TCVZsXaX868pc3HIkl
ZNQWjwVCX0NKCTEecMd9YcixwH4TC1TqsEADBmhZz9O44PvD+Rjh+7+Nff61Cv7/xHdmi8pvgvzx
F1vhzHOzqHzK/5FuBVOUd7nIAUK7TrP4r/04VarLAvUBoPMNeC+sQeiwTa6A07zN+7kbevMqCZ/6
i2WwKM2RG77S5lJFjYp3isWucI6ZpT8GqHBaa5azGw1e39U1WDNjWg0Abli7d4O5Z0fopxP8PStE
AM8EIKCTQPLHf7UCfm3VYp7fLFm2QsANX12CiobQB9IDgAChw7ZCdxDOgzvevgKyruK9a7Rk6Hx9
UtWDlPojG4gYBLJrLvlE26LyZ0BWnyZh45+0uRHSGhe/zZmAFs3AAQwY4vrifRNN9Zrgzyi0y26H
vB5YB9WgdGD+P7LCm1dl8KGNi35/puSK3yvDmeeUmKLZkum4ODZQ0T1ITMml7iq6gQQAuRY9abAH
PsjQNO4yTUIiO/jjnzXUvygzK5v62hKFQ1ii5QMHBW5btlBmvbRFJsFgAgABcr3gAZ89SHl9qABG
ZoifA2f5i9Q/83LCr0v43U+1Rks3a2UXq+AMcN+k/yV7DvxxXPz14gJ+v6AxS/84vy5wY49RPyTA
INdg5XhD/e+/rBUWZXak59oWWPom4RVtgVDyC+CaLN8pPVPIFp4hzPVdH+oZ7KB7RZPNoYt2qPMW
+Xce7PGsgDp8XLxo/bMqy5YL6PlYKyoevKUHJiDrR0AEVmDxgcEQ3StqLcvW21UoKInaMqFVNuX7
JL+2aP1zIlde3QrLDAtopH8CgmMCiUwgdbB+YAGjqQ5eQfeJAFCM/rG+DJB2/qCAj+9ftHEpLMrs
y3LDAlde1eqVa3uWSYg0XwLHBH6fZQK4KKE7u3p8NuAAYPx/l2lBaud9/IKSqa8fDwQYCE45e7FX
z1zJRz/a5kZLJRmBAwNmBcH38wzBrdtLbeAM3gFAatEZ2vCpaQlY8EfdkUSMCay877I2EwAu+v65
EssC69a1YG9gVhRylK/Dcad05gb8yGoGAEMYXUmkb309r/vTSc0yAYOE9y36/jmXi3+7JZaHM27l
sWysQ2fRpC7QZT/v+iVLkCe73rrASj00vAeo0ucpgNoXrOXPJP3v378f7r33XnjxxRfd/hlnnAGn
n346vP3tb4djRfhvOO6442Dt2rXudzRTzjqzDMuNGxg+iG5ZJp01sLVQQDq/kgWCOMteVurt3NVu
838/eEdEYxci1AM4KASOTDjl7BaYCXnppZfgc5/7HDz00EN1z1911VWwefPmeQ+Er33ta7B161YH
Ai4XXXQRbNmypanf//xzW+CeyuGkWdjpDkvAAlnB9RMAoP6DHV0bBttl1tbW6aleJNG9YE2JNAiF
2gDsudMvaD4AnnzySbjkkksaKt/KHXfcAddcc427dr7KTTfdBF/4whdqlG/FMoL9/vXOTVU631uK
k0dIZAE+cDSmcJ4RHBgADH93SFCq3Tfzph05YxFIB9cQAaLhbaeWoJliLX+iD4autev5Jlb51vLH
E/u9+/r6oFnygfe3esun1j/Jy7e+hs8B4o+b2p/MO6WU0ClCZEcZgA69Sygz4B0+3vaukiv/NlMm
axX2Wusq5pPcfvvtR1U+iWWCZrHA8mUC3naCCJ1DSZ1Gt2bR6SSVNA2NOyc6LFY6/G3S0TwS8QBh
HVsCm536Pfjgg1OyZusqxnMXsylW+Z///OcnfL1VfjPdwFlntPjmehy5Fela+J7CFNDzkV2ZPNmA
RJxMvX1Igq8XTO/MHaw6tbnRv7WGqco999wDcy2TVT5JMwHwzpNLsc+GwL6CoWCnQ3YQkjt7jYLj
nSMPBaDCluapIMRswLqAZsp0Arq5jgPsd5+K8m1aaNPaZol1AyCVy/WCSwcfEPqXYIg42xgFCFKc
XDI7HfSOHoobKPXj7QIcHm3L50/1r5lWNFmxyrexy1Tk6quvhmbKOzvKUfnUf0NiYZ8sHv25iwn8
qfaSif7DO/nChC+h8O9ZwANKuvF+lk7aF8u/QflTAaCtAWzadNRxm5OS5Uuif/cBn47+280+GnN5
HYtDBgDCv1w5RImx6uM2JQ370io0HS6ZRwwwF2Ldzic/+ckpK/9b3/qWcwHNlGXL/PByZ+d2pmtB
RR/J5hHAei8NHwMDAAoUJJaQfOjgL7TXKNb9i0pDrSsELFSZTg2ClD8TVczldlZUiRpyCtVsAAmk
nTxkLA+XBFk6QNLl0+2bi7Iw6NNHAUrDgpX5qnwSEXvvUhXPWDoO7cXCQKgFYGNRidJFmlMfIAZ7
yTToeCyDhWn98135TsjvYyoI2AYQa/nKTiXn9Y3xQClUDN3/YRgRvqgxwoIGgQqxMClg3isfUF9E
+9QBRKBroPZ9d0x6djD7dsqfISwTuzjA9SEwavdDy83aRAF2nZkLS3YMoFn2v5rDQpKpViqtzFar
5Z5f5mjtvmeQ7Q3sgj67zmLnEOF6DSm8Rg+ZcrAYwoml3Ay/btHaK919RsdF+A4EI8MLiwVefvll
mKrYUvW6detcI9FMysHXc0fxIO06j8GeU77tGp5jt3HFupCBBYBBgdA4wleznkQm7TOLG15ublwC
zwB2Pbx7DBaSrFgx/RFPtpHIAsGWjWdCDhyiZl4de/+UcFxAGDOQY1dyA4ayO16VpijwAsULRPV2
cTOMuEUFxbttsz7wyigsJDnvvPOaQuXWjdiysW3FbHYJ+7mXjqDvh2D1zvKtxZdztyijdGVBYIuG
ZQ8EaZQ75KabFRrCbKNB4d7q3b47ZoGkYN8zI7CQxBZtbr755qb5c9upxXZ8sb2GmiV7fjWWKF+T
8tHqFVq9t3wDhMyCwTCAiRyr4Q0s6AYyDAApDvBMgEAw2/t2HoGFJrbhxkbzzarh2yqi7TXUrD4N
z780AqLEFO98fh4UjpRvWMBYfotyiyqNvWDzgapEyncMIMj6MQAkJhC2C5Hf3m8YYHRYwUITywA3
3nhj09mgGUzw2HOH/JwBFgAmCBRlHfy9Lo052rcuwFK/BYFjBDk2IDOQA876JetGBt4l2GMOCKIA
BrMM7WyeG2h2XXymxXbsfOCBB1zn1GbIRHsRNZLHdlrl597ypbd2VSL/r1H51vLNusWv7QJLTRZQ
bhmtUj9/EZhAh6BQkisQlCp6oLx6/0FolkzHmprZpj5ZsS16FgjTdQvWHUwnKPznxw+4KN/l/cHy
xzDQs3TPlO8YwG4bZS6HAXldZbXJBaHq0kaJC8TOpJIUT8rH47ubCICLL74YpirT+WwzhNzCl770
pWkBeVoAeOKgz+1J+c7f+4GiuiXzlG9Zwa4tEDwzDFSuWz3kGwUlPIrVQa94iQoXrAEJAGcK967h
sKkF/PLhw9AMsQMm7DJZsQ98Kp+bCbHjFe6+++4pu4WpMtnzrxyBPfuMO3ZBHwZ8lg1cqqcQEHYx
5X3b9FfyLiEv6Rfs57FhX1cE1oYhKF2zoWHYtRioT4E/96uHD0GzxFrQZGIBe62NyueT2O9EbmEy
bGBBPNU46O9+NIjW7yeM8OVa47hLJlIrl9xIYbdt1w4Uwq9LumI/T2MDB/joj9hNHEKjQRghHBYN
u7416beUNZTJNJqQ8ufr6CD7vSwIJuIW7G+x101VHqseQr9vdITW7pRexpJvWaI7kAYgdhHuvChL
955B6tpjAABDYWiRXePLCWnaUdfVIPYlc/+NHtTw4l3D0CyZSK5trcVS7VwGfxMV6xbG+z3TLTDd
+/B+2D085tt0XbrnFQ3lzM4FZJSfufTOK19EFiiJoYeuXl2x9wiN+/+3+8X77BRxGbb4SYgTQwad
Kz45lHZoeMuaNjj/q6ug2WKDItvv7oknnnD7J510kku/jrWUkcT+nltvvdX9HqtwC2ALjOn8nt//
8i7YvX8ELd1E/aXMR/iO5m3g5/ctO6iSj+aVGx0kK/9y+Snd9h5Bn7f91gubMhA3SQRAZHo+Q6im
QcJh4KiVdX+5ygFhUWZP7h0Yhhv7d7uSLhiaV1TssdZe9tRvgaBK3vIVFnTchBEgrnv4sndst/cJ
vTtzpfrDW7ulfXW7p3477aiSHjn2OJ1zC24/tb15scCiTEy+UfmlVz6le9bKHc1LT/ukbDdvEPh9
XCvDAHSfAABTD6gan1/xSvVdhhwIJAFBQI5K13gNgWPvo0dg5x1z1z9/ocm9A/vg1eEjGO1bRaPC
bbTvgrzMg4GOYysfTg4xMHCJ0TVK0r87F3C/Jf9g4bjk0qPLKjuXgIs/bj7jlid27IPRAwu4x+gs
yZ59Y3Dbj15Dq5fo3+12i4sB3LFMhuAvWj4uQu3g90sAoEbGttaj+LgPteekXw6/ruHx2xZdwUzL
jn96DV49MOIt3dG7VXrZVff8XIEiuAQdZgpDF24DudJYP79fAgBbFjYfqhDta/L/RP92dJBbUhBo
BMHTf3cA9jy68JqKZ0vueWwY7jFlXzAK90o3enEBnnBAcEFeCfVhjucZxW80RRxUBrrfU+X3rBni
o5TaRj7fB4I8DqAlZYncug10HQ/e+Boc3LOwOo3Ohljq3/HAoLPoXAJW+LIQ7DnrL9G2iPMEZnG2
ECX0juJ9a8d4Lc0rRulDqcIxAxBpFhCYAgNDu+w3yn/AgGBRmiv/87t7DPUrT/tlH/ApjAP8fMGZ
nyAyQ3DQPIHB+lX18e53bS/etwYA1/WvHlLCsgAqXMR3/qqQJqJ7AGIDCAxhQfDq4yPw0/+9Dxal
ObLjx0PwyMuj6POlz/VxO898rq/CLOEIAnqDiAFJ7mYHhR317l13lKdsMcEggIvofAnYNwSEuAAA
eJxAaWE4Z5Yn+g+YpXlNxgtVdjwwDF9/cD9W+YzCy76mn2N519cBAKeKJ+vXWPyJDDCm1PZ6968L
gMACEAeEamwg0ji6lIDhXxrJtgMTAPzkr/fBzu83r8VwocndPz8Atz44GAo8ihp0SgILPxjo4fsB
FFK+XedSORbIfe6//elC8EfScJx3ybBA0kCEw8XcNo0Z5I1EwNhCeqBYNrj/pkF45geLIJis3P3z
1+HPvzdkrDlzhR1r8Y5ps0jxPvDTtm0ftyG8PCLk/ZnrAdzX6O80BIBjAVDbYlOQThRO28CaiBNQ
uG0PhMqXh+AXiyCYsFjlf/Fuo3yZOat3dI6zgIc3hGB9P8/4W0OU9/eMAQxotj99Xn3rtzLuTA8l
FwvoIY1DyINi2XZyvEb5USpf3geP9b8OizK+3P3zQ0b5+32AV4oUT6+CyalJN3T/jq+LUezFEb7h
R1fNkb7x/t64ALAsYCLJPgGTlaTRGOi18g/cvB9+9v8WA8NGcusDB+HPnPJR6SX2JhB8GYRGS3fU
H6wf4ssh6B1BdpygVtvGs34rE9Lt1y59+RGjwM56Hy5W/3GWoQJbxFTSxginXbgE/t0froDWZZOH
1htRho9o+MoPhuG7Tx52ChRMuUD+PYz1M+dtnz4c82eVDQgUCgDxTWLVZ9a+Z/XR/vaEJvsxiHM9
Hfl8wlYaKb+eBGCYjadMPPA3/+lXpmi08AaXFGXnnjH4+Ndfc8oH9hYw7cfpox+PRR1A/+6uE+kb
wRQNDLXX5+rKifz9CZvgLZe+uFWAdG+e1OzDOuEBUSdOiMcUpowKswqr/nN/Zzmc/zsL87Uzf/uz
Q3DrPx+E4VHllVtCZQfLRmVj8Ac42tf18nFAUSE+APY5U/Xb9tza0yc0DdmEAfD1nl3taqTVuALd
UY/6AQgMUEP/CiIYFAaKCo9bUKxYmcHHvtgObzphYcw+ttOUy7/y/WF42FT3qFoXXuaQ6fQtX6RU
eh1cWQflx1QvviDKsEZ1tLV1TXXN6gk1zU7KCd/84Re7hJL31TvHfT/f58oP5WOA0HgUts3ym1e0
wTmXL3nDAsH6+jt+aqz+xwdRYRBonStTIcU75WMuD5jzezZQwU0ofCWMwokdhM7X7Fx3xsBEv9Ok
o7CbL32513xoS/H4UYM/BgC7bdsLEwAIPwPZcYYNPmhcQueFM/NCirmQA0bxt//kENxulE90T2/1
FEz5LnIv8TeAqvAyqJgRRJegw+ti0fpB9z277j29k/luUwrDb7nslfuMM++ifR781QcArgsA0MJb
fk7g0CJcY4HQde0SOPsYBsKBw8bif3LYKP51GB7RidVrtNwQ6Lnj0bKT9/6VCm4hgCa089vtyrPn
v7sbJilTAoCNB3ITD5g/22H3ucJpPw0A0RUISCjfK7u4na7fdEIGq88swb+/tg2OX3lspI1W8bcb
xd9hrH54RPkCmUwtFtDfA3vNK0/14ksf6Rj4TqD0bkAGAJMNVE05uLt6lJy/nkz5if71pS91ShA2
Hmiv5/9ron/g1h+DwTzEAiLEBxqIGaKbsMdOMUD4zQvL8P7fmn/vKrRKH6iOOYsfeGEEW0rROmnm
LhEDPVKk66jBLDv4fBmtnF4FqwuBIr4efmg0V2uq3ZNXvpVpmdQtl/9rj86zO2Hc6L8e/YuQChL9
5yxeCG4BsDdy4VzbcgHveG8J3ntOCU49M4M3zxEzWKX/+KlReNQo/kdPH4EDI6hk+8tsOz2br4+/
uRPwvX7xBc+aNdzwwBCLPNKDQEkVe/cioJSCK5/rPq0fpijTfnI3X/bKJvN7b0qtv+D/BbdsqIn+
G9F/eh27h/T1BALSiadIB4R3nZHBb6yW8Ja3zgwgdg8qeHZ3Do/tGoNHqqNum4ZOeYv3dG+/kwiK
977dnc8i9Yf3+2UcBAX6LyFwWLu+wgkaHDNA3vfsBZML+orSlCdlMwOjmC2Ngr/IAFyp9ZUcGAJS
oBAbKB1dSk6fww4pueu8qmHJCgknrRZwUoeEtxow2GWpKTu/9S1+SNMJb67/s/cM+l9gFb37NWUs
XMFzr5rtoRyeNesDR5QbOq+wZRSQ5uNahylYo8WjK6C+eQJCwJcoPwSEaOWszKtDyx4E12H+9T3T
fVovTFOaZir/x4AAAgiiMmPhp0HwR8dZgYjTP8UCOrmOfRYVT51VHSikb0zJBW5LiK9WxzW9U9eX
TzV1mgzTrcYpV8FTuvTTaofBseTPwb+RS+EUurVv7tTR8iUERRcbbwgU8Z2/CAh2DdG/+Zl9T3ef
2gtNkKZVXD5114m9BtN9NcUgXUgT60FO0PWiJoVMMgyBFxeancNNNMSXXejCPeIHwraGtF1DCHZ9
AAKCA8i6Ix1rRv9k9cAtX8ZUz/0hl/fH4E+LmBGEOf7CJM8QQYSMo/3ppikfoIkAsPJpAwLzJfv8
nkhWFBcUFVMvZQx9DaEYWCIT6LjPp69351HJ7i2obmCr8ANbNTZlad+o5a7S/PvpGuUnNC85xetE
6bqg9Bjsect295chZfPBW3APEWThFfACG3oYC7l3/lnlX9g85QM0GQBWPn3Xql7zAzbXBoW4iDoK
L16j4zko3MeLSKyfX0coEFD4o7gfrmTHYjsnvhqXTY6hRdHf6+AedPKePYgRv4CQ8kVrhsgWeC0U
4oTIChDYIABRyeue/u3mKh9gBgBg5TPf/fWt5tZrjEerjmfVqVK9BJZmVk7HoNHn3CttGOREZILg
gkjhVJEqIrKOpMqPa82DQOqAATrx8fz9PNE1QOI+wv1ZWhep358zMcmQeXprnr7ID+dutswIAKx8
9q6VA7nS3ea5VO2+1sxXh1Xqz3klMfHzCVtE60/AIYAceVC2SJSegkIERDKkAQRXwL8qFCwfEqqH
4OcxOo8+XqbXKnILgqeIGt1LbPun36OUelSp0ponL3rXhBt3JiszBgArm7+3qqpaWteYH7wtUXTo
Sg41bgDqHNMiBQf5+gAO6zKUp26NihbM8gWjDR0rUsDyUQg3B4Rb0atwBiAwBJpmQWEJouULiC7B
pXDxGBRcRMIYHszbDo+Uu55mQ7lnQgTMkvzFpXs3gBQ3mTStnfcFSFoHwY8tyPEYTxFDLQCKqSO1
M8S0MKSZ0qeCZGm1aSDV3yHk5UnrmlOaitF4gaJJgRQkaor2uYUTtYfePeiiWO6fNA2b0m4uVd9T
l546velDJygzygBc/stdK7fnpbE15tdX7H4M3HjAV2xPwO1iPICuI7leQ3Kf5ANk/WHUimUMoPdk
u1SCsoUQ/Hv6iPfkJ4L1R+WHVE9waocAFMV8fkj9eNrnWacylsk1s6V8gFlkAC7/4/K9mxRk1xsd
dBy19IvFoMjYIrV+AYEZeJtCHnQtgm91zMKLK/galdgHT/t6fLBMFQsykgVp5MezaM3Aonxq6k1T
Q84cOrQHKA+EITt444mPvGPWFE8yawzA5b/9/cqtKpPd5vHuKBgp8GKQ9++15ygmCLEABntaU9Qf
c35/QoT35zojRHSF+oAS7JjAAJEViRgzhPySp3/hz+hYL2CFJB8v6MTyYwAJ2w0WVs+F8gHmiAG4
9PYMdo7kcKd5SB00z0Bi7aI2HtCF63SxPUHEbWtpVB4OpdnQCodrbHQB3vlC8t44zIJDJwx/zk27
lmlW849AUDKtCPJavlF8xRSq+gZwvr65kjkHAMmfXj64wbiALUZxHSn9p+0GUbn1+htgwKh9MKnQ
+oIrEEz5CIAcI3enHPZCpaBo1hsHeOdLSUCh8i7UVgOz1A2g/68YwMy54knmDQBI/nPP4Aats/WG
drt4M7GGtNmY9zZWQkDS/8DGAjqOVHYKd8cREOizFbfqMJuGBt4z1zMAtdxh50zJY4aYMShWFwg5
fwCCCX5F3jdw7fxQPMm8AwDJpp7hrjFQBgxyvUsTecpXYIMQBEKaWvp5DHx7AW+mVeiT7T0pwAMO
gpIOKaLvpKmCsott91DsqZMwAAzZvnpKjG0b+P35pXiSeQsAkj/qGewAKHcZFVxvlNoZ6F7HYJD3
GdA0fQ1A0okEQi4P2BgD2AQMiSUnXa4wK6DeOmGollQhg4jHNO/gWdFCfXusNLp94LrV83rqtHkP
AC4beg51SMh7tMiuMI+5S0Gx02lchxFIeIxydrdNRRrBAjcq2LCAj8bl0bv3wjGp0l673l1UDADu
N/HE9oc+vaoKx4gcUwDgYsFgXEQnCNljAHCWUXQnVQI1Y4OYNkJoyElb7IRP21jFjmICkLGnLoTB
GIEVqrqsKybDuL/lyHB/pXd+W3ojOWYBUJSeHt3eVjrcad2EYYgLjItoN6qyLqPdnk+AQBE55vGe
FXh6F0FgrH3IDrcy2wO6ZfRRQ/1VY+WVSu/xb4hZMf8NIdkRQKhwiigAAAAASUVORK5CYII=

------MultipartBoundary--Z8VJEPGodSf00JkUsP5Wt2OgGy9HGmsw75gxznnKyO------
